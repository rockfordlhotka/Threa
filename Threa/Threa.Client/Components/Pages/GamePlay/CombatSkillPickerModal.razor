@inject Radzen.DialogService DialogService

<div class="combat-skill-picker">
    <!-- Search/Filter -->
    <div class="mb-3">
        <input type="text" class="form-control form-control-sm" placeholder="Search skills..."
               @bind="searchFilter" @bind:event="oninput" />
    </div>

    <!-- Flat alphabetical skill list -->
    <div class="list-group">
        @{
            var skills = GetSkills().ToList();
        }
        @foreach (var ctx in skills)
        {
            <button class="list-group-item list-group-item-action py-2 px-3 d-flex justify-content-between align-items-center"
                    @onclick="() => Select(ctx)">
                <span>
                    @ctx.Name
                    @if (ctx.IsChipSkill)
                    {
                        <small class="text-muted ms-1"><i class="bi bi-cpu"></i></small>
                    }
                </span>
                <span class="badge @(ctx.IsChipSkill ? "" : "bg-primary")"
                      style="@(ctx.IsChipSkill ? "background: var(--bs-info);" : "")">
                    AS @ctx.AbilityScore
                </span>
            </button>
        }
        @if (!skills.Any())
        {
            <p class="text-muted text-center mt-3">No skills found.</p>
        }
    </div>

    <!-- Cancel -->
    <div class="mt-3 text-end">
        <button class="btn btn-outline-secondary btn-sm" @onclick="Cancel">
            <i class="bi bi-x-lg"></i> Cancel
        </button>
    </div>
</div>

@code {
    [Parameter]
    public GameMechanics.CharacterEdit? Character { get; set; }

    private string searchFilter = "";

    private static readonly HashSet<string> StandardSkillNames = new(StringComparer.OrdinalIgnoreCase)
    {
        "Awareness", "Bearing", "Dodge", "Drive", "Focus", "Influence", "Physicality", "Reasoning"
    };

    private IEnumerable<GameMechanics.SkillCheckContext> GetSkills()
    {
        // Native skills â€” exclude the 8 standard ones
        var native = (Character?.Skills?.AsEnumerable() ?? Enumerable.Empty<GameMechanics.SkillEdit>())
            .Where(s => !StandardSkillNames.Contains(s.Name));

        if (!string.IsNullOrWhiteSpace(searchFilter))
            native = native.Where(s => s.Name.Contains(searchFilter, StringComparison.OrdinalIgnoreCase));

        var nativeContexts = native.Select(s =>
            new GameMechanics.SkillCheckContext(s.Name, s.PrimaryAttribute, s.AbilityScore,
                SkillId: s.Id, PostUseConcentrationRounds: s.PostUseConcentrationRounds));

        // Chip-only skills (granted by chip, not already a native skill)
        var chipOnly = (Character == null
            ? Enumerable.Empty<GameMechanics.Items.GrantedSkillInfo>()
            : Character.GetChipGrantedSkills()
                .Where(g => !(Character.Skills?.Any(s =>
                    s.Name.Equals(g.SkillName, StringComparison.OrdinalIgnoreCase)) ?? false)));

        if (!string.IsNullOrWhiteSpace(searchFilter))
            chipOnly = chipOnly.Where(g => g.SkillName.Contains(searchFilter, StringComparison.OrdinalIgnoreCase));

        var chipContexts = chipOnly.Select(g => new GameMechanics.SkillCheckContext(
            Name: g.SkillName,
            PrimaryAttribute: g.PrimaryAttribute,
            AbilityScore: GameMechanics.SkillEdit.GetAttributeBase(Character!, g.PrimaryAttribute) + g.SkillLevel,
            IsChipSkill: true));

        return nativeContexts
            .Concat(chipContexts)
            .OrderBy(c => c.Name);
    }

    private void Select(GameMechanics.SkillCheckContext ctx)
    {
        DialogService.Close(ctx);
    }

    private void Cancel()
    {
        DialogService.Close();
    }
}
