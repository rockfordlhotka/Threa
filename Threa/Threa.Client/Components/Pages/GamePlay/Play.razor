@page "/play/{CharacterId:int}"
@page "/play/{CharacterId:int}/{TableId:guid}"

@rendermode InteractiveServer

@attribute [Authorize]

@implements IDisposable

@using GameMechanics.Messaging
@using Threa.Services
@using Threa.Client.Services
@using Threa.Client.Components.Shared
@using Threa.Client.Components.Pages.GamePlay.Targeting
@using Radzen

@inject Csla.Blazor.State.StateManager StateManager
@inject ITargetingInteractionManager TargetingManager
@inject RenderModeProvider RenderModeProvider
@inject NavigationManager NavigationManager
@inject IDataPortal<GameMechanics.CharacterEdit> characterPortal
@inject IDataPortal<GameMechanics.GamePlay.TableEdit> tablePortal
@inject IActivityLogService ActivityLog
@inject ITimeEventSubscriber TimeEventSubscriber
@inject ITimeEventPublisher TimeEventPublisher
@inject IChildDataPortal<GameMechanics.EffectRecord> effectPortal
@inject IJSRuntime JS
@inject ICharacterItemDal CharacterItemDal
@inject IItemTemplateDal ItemTemplateDal
@inject IGameTimeFormatService TimeFormat

@using GameMechanics.Time
@using Threa.Dal
@using Threa.Dal.Dto

@inject ITableDal TableDal
@inject IDataPortal<GameMechanics.GamePlay.TableCharacterList> characterListPortal
@inject DialogService DialogService
@inject PlayerConnectionTracker ConnectionTracker
@inject CircuitIdProvider CircuitIdProvider

<PageTitle>Threa - Play</PageTitle>

@if (errorMessage != null)
{
    <div class="alert alert-danger alert-dismissible fade show" role="alert">
        <i class="bi bi-exclamation-triangle-fill me-2"></i>
        <strong>Error:</strong> @errorMessage
        @if (errorMessage.Contains("not attached to this table"))
        {
            <div class="mt-2">
                <a href="/player/browse-campaigns" class="btn btn-sm btn-outline-primary">
                    <i class="bi bi-search me-1"></i>Browse Campaigns
                </a>
                <a href="/play" class="btn btn-sm btn-outline-secondary ms-2">
                    <i class="bi bi-arrow-left me-1"></i>Select Character
                </a>
            </div>
        }
        <button type="button" class="btn-close" @onclick="() => errorMessage = null" aria-label="Close"></button>
    </div>
}

@if (isLoading)
{
    <div>Loading character...</div>
}
else if (character == null)
{
    <div class="alert alert-warning">
        <p>Character not found or you don't have access to play this character.</p>
        <p><a href="/play">Select a different character</a></p>
    </div>
}
else
{
    <!-- Character Status Header (themed) -->
    <div class="character-header p-3 rounded mb-3">
        <div class="d-flex flex-column gap-3">
            <!-- Top row: Character identity + Resource pools + Table info -->
            <div class="d-flex flex-wrap justify-content-between align-items-start gap-3">
                <!-- Character Identity -->
                <div class="d-flex align-items-center gap-3">
                    @if (!string.IsNullOrEmpty(character.ImageUrl))
                    {
                        <img src="@character.ImageUrl" alt="@character.Name"
                             class="rounded" style="width: 48px; height: 48px; object-fit: cover; cursor: pointer;"
                             @onclick="OpenChangeImageModal"
                             title="Click to change image" />
                    }
                    else
                    {
                        <div class="rounded d-flex align-items-center justify-content-center"
                             style="width: 48px; height: 48px; background: var(--color-bg-tertiary); font-size: 1.5rem; cursor: pointer;"
                             @onclick="OpenChangeImageModal"
                             title="Click to add image">
                            @(character.Name.FirstOrDefault())
                        </div>
                    }
                    <div>
                        <h4 class="mb-0" style="font-family: var(--font-display);">@character.Name</h4>
                        <small style="color: var(--color-text-muted);">@character.Species</small>
                    </div>
                </div>

                <!-- Resource Pools -->
                <div class="d-flex gap-3 flex-wrap justify-content-center">
                    <!-- FAT Pool -->
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 100px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">FAT</small>
                        <div class="fw-bold fs-5" style="color: var(--color-fatigue);">
                            @character.Fatigue.Value<span style="color: var(--color-text-muted);">/@character.Fatigue.BaseValue</span>
                        </div>
                        <PendingPoolBar CurrentValue="@character.Fatigue.Value"
                                        MaxValue="@character.Fatigue.BaseValue"
                                        PendingDamage="@character.Fatigue.PendingDamage"
                                        PendingHealing="@character.Fatigue.PendingHealing"
                                        Height="8px" />
                        @if (character.Fatigue.PendingDamage > 0 || character.Fatigue.PendingHealing > 0)
                        {
                            <small class="d-block mt-1" style="font-size: 0.7rem;">
                                @if (character.Fatigue.PendingDamage > 0)
                                {
                                    <span style="color: var(--color-accent-red);">-@character.Fatigue.PendingDamage</span>
                                }
                                @if (character.Fatigue.PendingHealing > 0)
                                {
                                    <span style="color: var(--color-accent-green);" class="@(character.Fatigue.PendingDamage > 0 ? "ms-1" : "")">+@character.Fatigue.PendingHealing</span>
                                }
                            </small>
                        }
                    </div>

                    <!-- VIT Pool -->
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 100px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">VIT</small>
                        <div class="fw-bold fs-5" style="color: var(--color-vitality);">
                            @character.Vitality.Value<span style="color: var(--color-text-muted);">/@character.Vitality.BaseValue</span>
                        </div>
                        <PendingPoolBar CurrentValue="@character.Vitality.Value"
                                        MaxValue="@character.Vitality.BaseValue"
                                        PendingDamage="@character.Vitality.PendingDamage"
                                        PendingHealing="@character.Vitality.PendingHealing"
                                        Height="8px" />
                        @if (character.Vitality.PendingDamage > 0 || character.Vitality.PendingHealing > 0)
                        {
                            <small class="d-block mt-1" style="font-size: 0.7rem;">
                                @if (character.Vitality.PendingDamage > 0)
                                {
                                    <span style="color: var(--color-accent-red);">-@character.Vitality.PendingDamage</span>
                                }
                                @if (character.Vitality.PendingHealing > 0)
                                {
                                    <span style="color: var(--color-accent-green);" class="@(character.Vitality.PendingDamage > 0 ? "ms-1" : "")">+@character.Vitality.PendingHealing</span>
                                }
                            </small>
                        }
                    </div>

                    <!-- AP Pips -->
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 90px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">AP</small>
                        <div class="d-flex justify-content-center gap-1 my-1">
                            @for (int i = 0; i < character.ActionPoints.Max; i++)
                            {
                                var isAvailable = i < character.ActionPoints.Available;
                                <div class="ap-pip @(isAvailable ? "available" : "spent")">
                                    @if (isAvailable)
                                    {
                                        <i class="bi bi-lightning-fill" style="font-size: 0.6rem;"></i>
                                    }
                                </div>
                            }
                        </div>
                        <small style="color: var(--color-text-muted);">@character.ActionPoints.Available / @character.ActionPoints.Max</small>
                    </div>

                    <!-- Wounds Summary -->
                    @{
                        var woundCount = GetWoundCount();
                    }
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 80px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">WOUNDS</small>
                        <div class="fw-bold fs-5" style="color: @(woundCount > 0 ? "var(--color-accent-red)" : "var(--color-text-muted)");">
                            <i class="bi bi-bandaid"></i> @woundCount
                        </div>
                        @if (woundCount > 0)
                        {
                            <small style="color: var(--color-accent-red);">@(woundCount * -2) AS</small>
                        }
                    </div>
                </div>

                <!-- Table Info -->
                @if (table != null)
                {
                    <div class="text-end p-2 rounded" style="background: var(--color-bg-tertiary);">
                        <div style="font-family: var(--font-display); font-size: 0.85rem;">@table.Name</div>
                        <small style="color: var(--color-text-muted);">@TimeFormat.FormatCompact(table.CurrentTimeSeconds)</small>
                        <div class="mt-1">
                            @if (table.IsInCombat)
                            {
                                <span class="badge bg-danger">In Rounds</span>
                            }
                            <span class="badge bg-info ms-1">Round @table.CurrentRound</span>
                        </div>
                    </div>
                }
            </div>

            <!-- Active Effects Row -->
            @if (character.Effects.Any())
            {
                <div class="d-flex flex-wrap gap-2 align-items-center pt-2" style="border-top: 1px solid var(--color-card-border);">
                    <small class="me-2" style="font-family: var(--font-display); letter-spacing: 0.05em;">EFFECTS:</small>
                    @foreach (var effect in character.Effects)
                    {
                        <EffectIcon EffectType="@effect.EffectType.ToString()"
                                    EffectName="@effect.Name"
                                    Tooltip="@GetEffectTooltip(effect)"
                                    Stacks="@effect.CurrentStacks"
                                    Color="@GetEffectColor(effect)" />
                    }
                </div>
            }
        </div>
    </div>

    <!-- Targeting Notification Badge -->
    @if (pendingTargetingRequests.Any())
    {
        <div class="mb-3">
            <TargetingNotificationBadge PendingRequests="@pendingTargetingRequests"
                                        OnOpenTargeting="OpenTargetingModal"
                                        OnViewRequest="ViewTargetingRequest" />
        </div>
    }

    <!-- Tab Navigation -->
    <div class="tab-buttons">
        @foreach (var tabName in tabNames)
        {
            <button class="tab-link @(activeTab == tabName ? "active" : "")"
                    @onclick="() => SelectTab(tabName)">
                @tabName
            </button>
        }
    </div>

    <!-- Tab Content -->
    <div class="tab-content">
        @if (activeTab == "Status")
        {
            <TabStatus Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
        else if (activeTab == "Combat")
        {
            <TabCombat Character="character"
                        Table="table"
                        OnCharacterChanged="SaveCharacterAsync"
                        AvailableTargets="@GetAvailableTargets()"
                        OnInitiateTargeting="HandleInitiateTargeting" />
        }
        else if (activeTab == "Skills")
        {
            <TabPlaySkills Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
        else if (activeTab == "Magic")
        {
            <TabPlayMagic Character="character" Table="table" />
        }
        else if (activeTab == "Defense")
        {
            <TabDefense Character="character" Table="table" />
        }
        else if (activeTab == "Inventory")
        {
            <TabPlayInventory Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
    </div>

    @* RadzenDialog must be in the interactive context for DialogService to work *@
    <RadzenDialog />

    <!-- Targeting Modal -->
    @if (showTargetingModal && currentTargetingInteraction != null)
    {
        <div class="modal d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
            <div class="modal-dialog modal-xl modal-dialog-centered">
                <div class="modal-content">
                    <TargetingModal Interaction="@currentTargetingInteraction"
                                    IsAttacker="@isTargetingAttacker"
                                    maxAPBoost="@GetTargetingMaxAPBoost()"
                                    maxFATBoost="@GetTargetingMaxFATBoost()"
                                    defenderDodgeAS="@GetDefenderDodgeAS()"
                                    defenderParryAS="@GetDefenderParryAS()"
                                    defenderIsInParryMode="@GetDefenderIsInParryMode()"
                                    defenderCanActiveDefense="@GetDefenderCanActiveDefense()"
                                    defenderCanParry="@GetDefenderCanParry()"
                                    OnAttackerDataUpdated="UpdateTargetingAttackerData"
                                    OnDefenderDataUpdated="UpdateTargetingDefenderData"
                                    OnAttackerConfirmChanged="ToggleTargetingAttackerConfirm"
                                    OnDefenderConfirmChanged="ToggleTargetingDefenderConfirm"
                                    OnCancel="CancelTargeting"
                                    OnClose="CloseTargetingModal"
                                    OnAcceptDamage="AcceptTargetingDamage" />
                </div>
            </div>
        </div>
    }

    <!-- Activity Log -->
    <div class="activity-log mt-3 activity-log-container">
        <h6>Activity Log</h6>
        @if (activityLog.Count == 0)
        {
            <p class="text-muted">No recent activity.</p>
        }
        else
        {
            @foreach (var entry in activityLog.TakeLast(10).Reverse())
            {
                <div class="small @GetActivityClass(entry.Category)">
                    <span class="text-muted">[@entry.Timestamp.ToString("HH:mm:ss")]</span>
                    <strong>@entry.Source:</strong> @entry.Message
                </div>
            }
        }
    </div>
}

@code {
#pragma warning disable CS0618 // Using legacy round-based properties for UI display

[Parameter]
public int CharacterId { get; set; }

[Parameter]
public Guid TableId { get; set; }

private bool isLoading = true;
private static readonly string[] AllTabNames = new[] { "Status", "Combat", "Defense", "Skills", "Magic", "Inventory" };
private string[] tabNames => GetTabNamesForTheme();
private string activeTab = "Status";

private string[] GetTabNamesForTheme()
{
    var theme = table?.Theme ?? "fantasy";
    if (theme == "scifi")
    {
        // Hide Magic tab for sci-fi theme
        return AllTabNames.Where(t => t != "Magic").ToArray();
    }
    return AllTabNames;
}

private void EnsureValidActiveTab()
{
    // If current tab is not in the available tabs (e.g., Magic in sci-fi), switch to Status
    if (!tabNames.Contains(activeTab))
    {
        activeTab = "Status";
    }
}

private GameMechanics.CharacterEdit? character;
private GameMechanics.GamePlay.TableEdit? table;
private string? errorMessage;
private List<ActivityLogEntry> activityLog = new();
private IDisposable? activityLogSubscription;
private bool timeEventSubscribed;
private bool _disposed;

// Targeting state
private List<TargetingRequestMessage> pendingTargetingRequests = new();
private TargetingInteraction? currentTargetingInteraction;
private bool showTargetingModal;
private bool isTargetingAttacker;
private List<GameMechanics.GamePlay.TableCharacterInfo> tableCharacters = new();

// Semaphore to prevent concurrent processing of time skip messages
private readonly SemaphoreSlim _timeSkipSemaphore = new(1, 1);

private record ActivityLogEntry(DateTime Timestamp, string Message, string Source, ActivityCategory Category);

protected override async Task OnInitializedAsync()
{
    await StateManager.InitializeAsync();

    if (RenderModeProvider.GetRenderMode(this).IsInteractive())
    {
        try
        {
            isLoading = true;

            // Load character directly from URL parameter
            character = await characterPortal.FetchAsync(CharacterId);
            await LoadEquippedItemsAsync();

            // If TableId is provided, load the table and verify character attachment
            if (TableId != Guid.Empty)
            {
                try
                {
                    // First verify the character is actually attached to this table
                    var attachedTable = await TableDal.GetTableForCharacterAsync(CharacterId);
                    if (attachedTable == null || attachedTable.Id != TableId)
                    {
                        errorMessage = "This character is not attached to this table. You must request to join the table and be approved by the Game Master before you can play.";
                        isLoading = false;
                        return;
                    }

                    table = await tablePortal.FetchAsync(TableId);
                    await LoadTableCharactersAsync();
                    SubscribeToActivityLog(TableId);
                    await SubscribeToTimeEvents(TableId);

                    // Register this connection with the tracker
                    if (!string.IsNullOrEmpty(CircuitIdProvider.CircuitId))
                    {
                        await ConnectionTracker.RegisterConnectionAsync(CircuitIdProvider.CircuitId, CharacterId, TableId);
                    }

                    // Apply the table's theme
                    if (table != null)
                    {
                        await JS.InvokeVoidAsync("threaTheme.apply", table.Theme ?? "fantasy");
                    }
                }
                catch (Exception ex)
                {
                    errorMessage = $"Failed to load table: {ex.Message}";
                }
            }

            AddLogEntry($"Playing as {character.Name}", ActivityCategory.Player);

            // If joining an in-progress table, announce the current game time
            if (table != null && table.Status == Threa.Dal.Dto.TableStatus.Active)
            {
                var timeDisplay = TimeFormat.FormatFull(table.CurrentTimeSeconds);
                AddLogEntry($"The in-game time is: {timeDisplay}", ActivityCategory.Time);
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load character: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }
}

protected override async Task OnAfterRenderAsync(bool firstRender)
{
    // Ensure theme is applied after render, especially important when rejoining tables
    if (firstRender && table != null)
    {
        try
        {
            await JS.InvokeVoidAsync("threaTheme.apply", table.Theme ?? "fantasy");
        }
        catch
        {
            // JS might not be ready yet, ignore
        }
    }
}

private async Task LoadEquippedItemsAsync()
{
    if (character == null) return;
    var equippedItems = await CharacterItemDal.GetEquippedItemsWithTemplatesAsync(character.Id);
    character.SetEquippedItems(equippedItems);
}

private async Task LoadTableCharactersAsync()
{
    if (table == null) return;
    var charList = await characterListPortal.FetchAsync(table.Id);
    tableCharacters = charList.ToList();
}

    private void SelectTab(string tabName)
    {
        activeTab = tabName;
    }

    private void AddLogEntry(string message, ActivityCategory category = ActivityCategory.General)
    {
        // Only publish if we have a table context
        if (table != null)
        {
            ActivityLog.Publish(table.Id, message, character?.Name ?? "Player", category);
        }
        else
        {
            // Local-only for when there's no table
            activityLog.Add(new ActivityLogEntry(DateTime.Now, message, character?.Name ?? "Player", category));
            if (activityLog.Count > 100)
                activityLog.RemoveAt(0);
        }
    }

    private void SubscribeToActivityLog(Guid tableId)
    {
        // Unsubscribe from any previous subscription
        activityLogSubscription?.Dispose();

        activityLogSubscription = ActivityLog.Subscribe(tableId, msg =>
        {
            InvokeAsync(() =>
            {
                activityLog.Add(new ActivityLogEntry(msg.Timestamp, msg.Message, msg.Source, msg.Category));
                if (activityLog.Count > 100) activityLog.RemoveAt(0);
                StateHasChanged();
            });
        });
    }

    private async Task SubscribeToTimeEvents(Guid tableId)
    {
        if (timeEventSubscribed)
        {
            return;
        }

        // Connect and subscribe to time events
        await TimeEventSubscriber.ConnectAsync();
        await TimeEventSubscriber.SubscribeAsync();

        // Connect publisher to send character update notifications
        await TimeEventPublisher.ConnectAsync();

        TimeEventSubscriber.TimeEventReceived += OnTimeEventReceived;
        TimeEventSubscriber.TimeSkipReceived += OnTimeSkipReceived;
        TimeEventSubscriber.CombatStateReceived += OnCombatStateReceived;
        TimeEventSubscriber.CharacterUpdateReceived += OnCharacterUpdateReceived;
        TimeEventSubscriber.TableUpdateReceived += OnTableUpdateReceived;
        TimeEventSubscriber.CharactersUpdatedReceived += OnCharactersUpdatedReceived;

        // Targeting message subscriptions
        TimeEventSubscriber.TargetingRequestReceived += OnTargetingRequestReceived;
        TimeEventSubscriber.TargetingResponseReceived += OnTargetingResponseReceived;
        TimeEventSubscriber.TargetingUpdateReceived += OnTargetingUpdateReceived;
        TimeEventSubscriber.TargetingResultReceived += OnTargetingResultReceived;
        TimeEventSubscriber.TargetingCancelledReceived += OnTargetingCancelledReceived;

        timeEventSubscribed = true;
    }

    /// <summary>
    /// Handles the authoritative notification that characters have been updated server-side.
    /// Time processing is now done by TimeAdvancementService on the server.
    /// Player clients just need to refresh their character state from the database.
    /// </summary>
    private void OnCharactersUpdatedReceived(object? sender, CharactersUpdatedMessage e)
    {
        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.TableId != table.Id) return;

        // Check if our character is in the updated list
        if (character == null || !e.CharacterIds.Contains(character.Id)) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Reload character from database to get the updated state
                int characterId = character.Id;
                character = await characterPortal.FetchAsync(characterId);
                await LoadEquippedItemsAsync();

                // Also refresh table state
                table = await tablePortal.FetchAsync(table.Id);

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error refreshing character: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnTimeEventReceived(object? sender, TimeEventMessage e)
    {
        // NOTE: Time processing is now done server-side by TimeAdvancementService.
        // This handler is kept for backward compatibility but the main updates
        // come through CharactersUpdatedReceived.

        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.CampaignId != table.Id.ToString()) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Just refresh the table state to show updated time/rounds
                if (table != null)
                {
                    table = await tablePortal.FetchAsync(table.Id);
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing time event: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnTimeSkipReceived(object? sender, TimeSkipMessage e)
    {
        // NOTE: Time processing is now done server-side by TimeAdvancementService.
        // This handler is kept for backward compatibility but the main updates
        // come through CharactersUpdatedReceived.

        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.CampaignId != table.Id.ToString())
        {
            return;
        }

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Just refresh table state to show updated time
                if (table != null)
                {
                    table = await tablePortal.FetchAsync(table.Id);
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing time skip: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnCombatStateReceived(object? sender, CombatStateMessage e)
    {
        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.CampaignId != table.Id.ToString()) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Refresh the table to get the updated combat state
                table = await tablePortal.FetchAsync(table.Id);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing combat state: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnCharacterUpdateReceived(object? sender, CharacterUpdateMessage e)
    {
        // Ignore events if component is disposed
        if (_disposed || table == null) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // If this is our character, refresh it
                if (character != null && e.CharacterId == character.Id)
                {
                    character = await characterPortal.FetchAsync(character.Id);
                    await LoadEquippedItemsAsync();
                }

                // Always refresh table characters to catch NPC visibility changes
                await LoadTableCharactersAsync();

                // Check if we're in targeting and our target is no longer valid
                if (currentTargetingInteraction != null && showTargetingModal)
                {
                    var targetId = currentTargetingInteraction.DefenderId;
                    var target = tableCharacters.FirstOrDefault(c => c.CharacterId == targetId);

                    // Target invalid if: not found, or is NPC that's now hidden
                    bool targetInvalid = target == null ||
                        (target.IsNpc && !target.VisibleToPlayers);

                    if (targetInvalid)
                    {
                        // Cancel the targeting interaction
                        await TargetingManager.CancelAsync(
                            currentTargetingInteraction.InteractionId,
                            "Target is no longer available");

                        // Close the modal
                        showTargetingModal = false;
                        currentTargetingInteraction = null;

                        // Log the invalidation for the player
                        AddLogEntry("Target hidden - select a new target", ActivityCategory.Combat);
                    }
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing character update: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnTableUpdateReceived(object? sender, TableUpdateMessage e)
    {
        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.TableId != table.Id) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Handle theme changes
                if (e.UpdateType == "ThemeChanged" && !string.IsNullOrEmpty(e.Theme))
                {
                    await JS.InvokeVoidAsync("threaTheme.apply", e.Theme);
                    // Update local table state
                    table = await tablePortal.FetchAsync(table.Id);
                    // Ensure active tab is valid for the new theme (e.g., Magic not available in sci-fi)
                    EnsureValidActiveTab();
                }
                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing table update: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private async Task UnsubscribeFromTimeEvents()
    {
        if (!timeEventSubscribed)
        {
            return;
        }

        TimeEventSubscriber.TimeEventReceived -= OnTimeEventReceived;
        TimeEventSubscriber.TimeSkipReceived -= OnTimeSkipReceived;
        TimeEventSubscriber.CombatStateReceived -= OnCombatStateReceived;
        TimeEventSubscriber.CharacterUpdateReceived -= OnCharacterUpdateReceived;
        TimeEventSubscriber.TableUpdateReceived -= OnTableUpdateReceived;
        TimeEventSubscriber.CharactersUpdatedReceived -= OnCharactersUpdatedReceived;

        // Unsubscribe from targeting messages
        TimeEventSubscriber.TargetingRequestReceived -= OnTargetingRequestReceived;
        TimeEventSubscriber.TargetingResponseReceived -= OnTargetingResponseReceived;
        TimeEventSubscriber.TargetingUpdateReceived -= OnTargetingUpdateReceived;
        TimeEventSubscriber.TargetingResultReceived -= OnTargetingResultReceived;
        TimeEventSubscriber.TargetingCancelledReceived -= OnTargetingCancelledReceived;

        await TimeEventSubscriber.UnsubscribeAsync();
        timeEventSubscribed = false;
    }

    public async void Dispose()
    {
        if (_disposed)
        {
            return;
        }
        _disposed = true;

        activityLogSubscription?.Dispose();
        await UnsubscribeFromTimeEvents();
        _timeSkipSemaphore?.Dispose();
    }

    private string GetActivityClass(ActivityCategory category) =>
        category switch
        {
            ActivityCategory.Combat => "text-danger",
            ActivityCategory.Announcement => "text-primary fw-bold",
            ActivityCategory.Health => "text-success",
            ActivityCategory.Effect => "text-warning",
            ActivityCategory.Time => "text-info",
            ActivityCategory.Session => "text-secondary fst-italic",
            ActivityCategory.Player => "text-muted",
            _ => ""
        };

    private async Task SaveCharacterAsync()
    {
        if (character == null) return;
        try
        {
            await characterPortal.UpdateAsync(character);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to save character: {ex.Message}";
        }
    }

    // UI Helper methods
    private int GetWoundCount() => character?.Effects.Count(e => e.EffectType == Threa.Dal.Dto.EffectType.Wound) ?? 0;

    private string GetEffectTooltip(GameMechanics.EffectRecord effect)
    {
        string duration = "";
        if (effect.ExpiresAtEpochSeconds.HasValue)
        {
            var remainingSeconds = effect.ExpiresAtEpochSeconds.Value - (character?.CurrentGameTimeSeconds ?? 0);
            if (remainingSeconds > 0)
            {
                var remainingRounds = (int)(remainingSeconds / 3);
                duration = $" ({remainingRounds} rounds left)";
            }
            else
            {
                duration = " (Expired)";
            }
        }
        var source = string.IsNullOrEmpty(effect.Source) ? "" : $" (Source: {effect.Source})";
        var description = string.IsNullOrEmpty(effect.Description) ? "" : $": {effect.Description}";

        return $"{effect.Name}{description}{duration}{source}";
    }

    private string GetEffectColor(GameMechanics.EffectRecord effect) => effect.EffectType switch
    {
        Threa.Dal.Dto.EffectType.Buff => "var(--color-accent-green)",
        Threa.Dal.Dto.EffectType.Debuff or Threa.Dal.Dto.EffectType.Poison => "var(--color-accent-red)",
        Threa.Dal.Dto.EffectType.Wound => "var(--color-accent-red)",
        Threa.Dal.Dto.EffectType.Disease => "var(--color-accent-secondary)",
        Threa.Dal.Dto.EffectType.Condition => "var(--color-accent-gold)",
        Threa.Dal.Dto.EffectType.SpellEffect => "var(--color-accent-blue)",
        Threa.Dal.Dto.EffectType.ItemEffect => "var(--color-accent-primary)",
        _ => "var(--color-text-primary)"
    };

    // ================================
    // Concentration Result Processing
    // ================================

    /// <summary>
    /// Processes the LastConcentrationResult from a character after concentration ends.
    /// Handles magazine reload completion and sustained effect cleanup.
    /// </summary>
    private async Task ProcessConcentrationResult(GameMechanics.CharacterEdit targetCharacter)
    {
        var result = targetCharacter.LastConcentrationResult;
        if (result == null) return;

        try
        {
            switch (result.ActionType)
            {
                case "MagazineReload":
                    if (result.Success)
                    {
                        await ExecuteMagazineReload(targetCharacter, result.Payload);
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        // Reload was interrupted
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "SustainedBreak":
                    await ProcessSustainedBreak(result.Payload);
                    AddLogEntry(result.Message, ActivityCategory.Effect);
                    break;

                case "SpellCast":
                    // TODO: Implement when spell system is ready
                    if (result.Success)
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "AmmoContainerReload":
                    if (result.Success)
                    {
                        await ExecuteAmmoContainerReload(targetCharacter, result.Payload);
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "AmmoContainerUnload":
                    if (result.Success)
                    {
                        await ExecuteAmmoContainerUnload(targetCharacter, result.Payload);
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "WeaponUnload":
                    if (result.Success)
                    {
                        await ExecuteWeaponUnload(targetCharacter, result.Payload);
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;
            }
        }
        finally
        {
            // Always clear the result after processing
            targetCharacter.ClearConcentrationResult();
        }
    }

    /// <summary>
    /// Executes the magazine reload by updating the weapon's LoadedAmmo via WeaponAmmoState.
    /// </summary>
    private async Task ExecuteMagazineReload(GameMechanics.CharacterEdit targetCharacter, string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        var payload = GameMechanics.Effects.Behaviors.MagazineReloadPayload.FromJson(payloadJson);
        if (payload == null) return;

        try
        {
            // Fetch the weapon item from DAL
            var weapon = await CharacterItemDal.GetItemAsync(payload.WeaponItemId);
            if (weapon != null)
            {
                // Update LoadedAmmo via WeaponAmmoState pattern
                var ammoState = GameMechanics.Combat.WeaponAmmoState.FromJson(weapon.CustomProperties);
                ammoState.LoadedAmmo = payload.RoundsToLoad;

                // Merge ammo state back into CustomProperties
                weapon.CustomProperties = GameMechanics.Combat.WeaponAmmoState.MergeIntoCustomProperties(
                    weapon.CustomProperties, ammoState);

                await CharacterItemDal.UpdateItemAsync(weapon);

                // Reload equipped items to reflect the change
                await LoadEquippedItemsAsync();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to complete magazine reload: {ex.Message}";
        }
    }

    /// <summary>
    /// Executes the ammo container reload by updating the container's ammo state and reducing the loose ammo stack.
    /// </summary>
    private async Task ExecuteAmmoContainerReload(GameMechanics.CharacterEdit targetCharacter, string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        var payload = GameMechanics.Effects.Behaviors.AmmoContainerReloadPayload.FromJson(payloadJson);
        if (payload == null) return;

        try
        {
            // Update container ammo state
            var container = await CharacterItemDal.GetItemAsync(payload.ContainerId);
            if (container != null)
            {
                var containerState = GameMechanics.Combat.AmmoContainerState.FromJson(container.CustomProperties);
                containerState.LoadedAmmo += payload.RoundsToLoad;
                if (payload.AmmoType != null)
                    containerState.AmmoType = payload.AmmoType;
                container.CustomProperties = GameMechanics.Combat.AmmoContainerState.MergeIntoCustomProperties(
                    container.CustomProperties, containerState);
                await CharacterItemDal.UpdateItemAsync(container);
            }

            // Reduce source ammo stack
            var source = await CharacterItemDal.GetItemAsync(payload.SourceItemId);
            if (source != null)
            {
                source.StackSize -= payload.RoundsToLoad;
                if (source.StackSize <= 0)
                    await CharacterItemDal.DeleteItemAsync(payload.SourceItemId);
                else
                    await CharacterItemDal.UpdateItemAsync(source);
            }

            // Reload equipped items to reflect the change
            await LoadEquippedItemsAsync();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to complete ammo container reload: {ex.Message}";
        }
    }

    /// <summary>
    /// Executes the ammo container unload by returning rounds to loose ammo inventory.
    /// </summary>
    private async Task ExecuteAmmoContainerUnload(GameMechanics.CharacterEdit targetCharacter, string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        var payload = GameMechanics.Effects.Behaviors.AmmoContainerUnloadPayload.FromJson(payloadJson);
        if (payload == null) return;

        try
        {
            // Update container - remove ammo
            var container = await CharacterItemDal.GetItemAsync(payload.ContainerId);
            if (container != null)
            {
                var containerState = GameMechanics.Combat.AmmoContainerState.FromJson(container.CustomProperties);
                containerState.LoadedAmmo = Math.Max(0, containerState.LoadedAmmo - payload.RoundsToUnload);
                container.CustomProperties = GameMechanics.Combat.AmmoContainerState.MergeIntoCustomProperties(
                    container.CustomProperties, containerState);
                await CharacterItemDal.UpdateItemAsync(container);
            }

            // Add loose ammo to inventory (find existing stack or create new)
            await AddLooseAmmoToInventory(payload.CharacterId, payload.RoundsToUnload, payload.AmmoType);

            // Reload equipped items to reflect the change
            await LoadEquippedItemsAsync();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to complete ammo container unload: {ex.Message}";
        }
    }

    /// <summary>
    /// Executes the weapon unload by returning rounds to loose ammo inventory.
    /// </summary>
    private async Task ExecuteWeaponUnload(GameMechanics.CharacterEdit targetCharacter, string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        var payload = GameMechanics.Effects.Behaviors.WeaponUnloadPayload.FromJson(payloadJson);
        if (payload == null) return;

        try
        {
            // Update weapon - remove ammo
            var weapon = await CharacterItemDal.GetItemAsync(payload.WeaponItemId);
            if (weapon != null)
            {
                var ammoState = GameMechanics.Combat.WeaponAmmoState.FromJson(weapon.CustomProperties);

                // Remove rounds (from chamber first, then magazine)
                int toRemove = payload.RoundsToUnload;
                if (ammoState.ChamberLoaded && toRemove > 0)
                {
                    ammoState.ChamberLoaded = false;
                    toRemove--;
                }
                ammoState.LoadedAmmo = Math.Max(0, ammoState.LoadedAmmo - toRemove);

                weapon.CustomProperties = GameMechanics.Combat.WeaponAmmoState.MergeIntoCustomProperties(
                    weapon.CustomProperties, ammoState);
                await CharacterItemDal.UpdateItemAsync(weapon);
            }

            // Add loose ammo to inventory (find existing stack or create new)
            await AddLooseAmmoToInventory(payload.CharacterId, payload.RoundsToUnload, payload.AmmoType);

            // Reload equipped items to reflect the change
            await LoadEquippedItemsAsync();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to complete weapon unload: {ex.Message}";
        }
    }

    /// <summary>
    /// Adds loose ammo to inventory. Finds existing stack of same type or creates new item.
    /// </summary>
    private async Task AddLooseAmmoToInventory(int characterId, int roundCount, string? ammoType)
    {
        if (roundCount <= 0) return;

        // Try to find existing loose ammo stack of the same type
        var items = await CharacterItemDal.GetCharacterItemsAsync(characterId);
        Threa.Dal.Dto.CharacterItem? existingStack = null;

        foreach (var item in items)
        {
            // Skip items in containers
            if (item.ContainerItemId != null) continue;

            var template = await ItemTemplateDal.GetTemplateAsync(item.ItemTemplateId);
            if (template?.ItemType != Threa.Dal.Dto.ItemType.Ammunition) continue;

            var ammoProps = GameMechanics.Combat.AmmunitionProperties.FromJson(template.CustomProperties);
            if (ammoProps?.IsContainer == true) continue; // Skip magazines

            // Check ammo type match
            if (string.IsNullOrEmpty(ammoType) ||
                string.IsNullOrEmpty(ammoProps?.AmmoType) ||
                ammoType.Equals(ammoProps.AmmoType, StringComparison.OrdinalIgnoreCase))
            {
                existingStack = item;
                break;
            }
        }

        if (existingStack != null)
        {
            // Add to existing stack
            existingStack.StackSize += roundCount;
            await CharacterItemDal.UpdateItemAsync(existingStack);
        }
        else
        {
            // Need to create a new ammo item - find a template for loose ammo of this type
            var templates = await ItemTemplateDal.GetAllTemplatesAsync();
            Threa.Dal.Dto.ItemTemplate? ammoTemplate = null;

            foreach (var t in templates)
            {
                if (t.ItemType != Threa.Dal.Dto.ItemType.Ammunition) continue;
                var props = GameMechanics.Combat.AmmunitionProperties.FromJson(t.CustomProperties);
                if (props?.IsContainer == true) continue;

                if (string.IsNullOrEmpty(ammoType) ||
                    string.IsNullOrEmpty(props?.AmmoType) ||
                    ammoType.Equals(props.AmmoType, StringComparison.OrdinalIgnoreCase))
                {
                    ammoTemplate = t;
                    break;
                }
            }

            if (ammoTemplate != null)
            {
                var newItem = new Threa.Dal.Dto.CharacterItem
                {
                    Id = Guid.NewGuid(),
                    OwnerCharacterId = characterId,
                    ItemTemplateId = ammoTemplate.Id,
                    StackSize = roundCount,
                    IsEquipped = false
                };
                await CharacterItemDal.AddItemAsync(newItem);
            }
            else
            {
                // Couldn't find a template - log warning but don't fail
                Console.WriteLine($"Warning: Could not find ammo template for type '{ammoType}' - rounds lost");
            }
        }
    }

    /// <summary>
    /// Processes sustained concentration break by removing all linked effects from table characters.
    /// </summary>
    private async Task ProcessSustainedBreak(string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        // Parse the payload to get LinkedEffectIds
        try
        {
            var payload = System.Text.Json.JsonSerializer.Deserialize<SustainedBreakPayload>(payloadJson);
            if (payload?.LinkedEffectIds == null || payload.LinkedEffectIds.Count == 0) return;

            var linkedIds = new HashSet<Guid>(payload.LinkedEffectIds);

            // For the current character, remove matching effects
            if (character != null)
            {
                var effectsToRemove = character.Effects
                    .Where(e => linkedIds.Contains(e.Id))
                    .ToList();

                foreach (var effect in effectsToRemove)
                {
                    character.Effects.RemoveEffect(effect.Id);
                }

                // Also remove effects that have matching SourceEffectId
                var linkedBySource = character.Effects
                    .Where(e => e.SourceEffectId.HasValue && linkedIds.Contains(e.SourceEffectId.Value))
                    .ToList();

                foreach (var effect in linkedBySource)
                {
                    character.Effects.RemoveEffect(effect.Id);
                }

                // Save if any effects were removed
                if (effectsToRemove.Count > 0 || linkedBySource.Count > 0)
                {
                    await characterPortal.UpdateAsync(character);
                }
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error processing sustained break: {ex.Message}";
        }
    }

    /// <summary>
    /// Payload structure for sustained break result.
    /// </summary>
    private class SustainedBreakPayload
    {
        public List<Guid>? LinkedEffectIds { get; set; }
        public string? SpellName { get; set; }
    }

    // ================================
    // Targeting Event Handlers
    // ================================

    private void OnTargetingRequestReceived(object? sender, TargetingRequestMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;
        if (character == null) return;

        // Check if we are the defender
        if (e.DefenderId == character.Id)
        {
            _ = InvokeAsync(() =>
            {
                pendingTargetingRequests.Add(e);
                StateHasChanged();
            });
        }
        // Check if we are the attacker and opened targeting
        else if (e.AttackerId == character.Id)
        {
            _ = InvokeAsync(() =>
            {
                currentTargetingInteraction = TargetingManager.GetInteraction(e.InteractionId);
                if (currentTargetingInteraction != null)
                {
                    showTargetingModal = true;
                    isTargetingAttacker = true;
                    StateHasChanged();
                }
            });
        }
    }

    private void OnTargetingResponseReceived(object? sender, TargetingResponseMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;
        if (currentTargetingInteraction == null || e.InteractionId != currentTargetingInteraction.InteractionId) return;

        _ = InvokeAsync(() =>
        {
            // Update local interaction state if needed
            var interaction = TargetingManager.GetInteraction(e.InteractionId);
            if (interaction != null)
            {
                currentTargetingInteraction = interaction;
            }
            StateHasChanged();
        });
    }

    private void OnTargetingUpdateReceived(object? sender, TargetingUpdateMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;
        if (currentTargetingInteraction == null || e.InteractionId != currentTargetingInteraction.InteractionId) return;

        _ = InvokeAsync(() =>
        {
            // Refresh interaction from manager
            var interaction = TargetingManager.GetInteraction(e.InteractionId);
            if (interaction != null)
            {
                currentTargetingInteraction = interaction;
            }
            StateHasChanged();
        });
    }

    private void OnTargetingResultReceived(object? sender, TargetingResultMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;

        _ = InvokeAsync(() =>
        {
            // If we have this interaction open, update it
            if (currentTargetingInteraction != null && e.InteractionId == currentTargetingInteraction.InteractionId)
            {
                var interaction = TargetingManager.GetInteraction(e.InteractionId);
                if (interaction != null)
                {
                    currentTargetingInteraction = interaction;
                }
            }

            // Remove from pending requests if we're the defender
            pendingTargetingRequests.RemoveAll(r => r.InteractionId == e.InteractionId);

            StateHasChanged();
        });
    }

    private void OnTargetingCancelledReceived(object? sender, TargetingCancelledMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;

        _ = InvokeAsync(() =>
        {
            // Close modal if we have this interaction open
            if (currentTargetingInteraction != null && e.InteractionId == currentTargetingInteraction.InteractionId)
            {
                var interaction = TargetingManager.GetInteraction(e.InteractionId);
                if (interaction != null)
                {
                    currentTargetingInteraction = interaction;
                }
            }

            // Remove from pending requests
            pendingTargetingRequests.RemoveAll(r => r.InteractionId == e.InteractionId);

            StateHasChanged();
        });
    }

    // ================================
    // Targeting UI Methods
    // ================================

    private void OpenTargetingModal()
    {
        if (character == null) return;

        // Open the first pending request
        var request = pendingTargetingRequests.FirstOrDefault();
        if (request != null)
        {
            ViewTargetingRequest(request);
        }
    }

    private void ViewTargetingRequest(TargetingRequestMessage request)
    {
        var interaction = TargetingManager.GetInteraction(request.InteractionId);
        if (interaction != null)
        {
            currentTargetingInteraction = interaction;
            showTargetingModal = true;
            isTargetingAttacker = false;
            StateHasChanged();
        }
    }

    private async Task UpdateTargetingAttackerData(TargetingAttackerData data)
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.UpdateAttackerDataAsync(currentTargetingInteraction.InteractionId, data);
    }

    private async Task UpdateTargetingDefenderData(TargetingDefenderData data)
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.UpdateDefenderDataAsync(currentTargetingInteraction.InteractionId, data);
    }

    private async Task ToggleTargetingAttackerConfirm(bool confirmed)
    {
        if (currentTargetingInteraction == null) return;
        if (confirmed)
        {
            await TargetingManager.ConfirmAttackerAsync(currentTargetingInteraction.InteractionId);
        }
        else
        {
            await TargetingManager.UpdateAttackerDataAsync(currentTargetingInteraction.InteractionId, currentTargetingInteraction.AttackerData, false);
        }
    }

    private async Task ToggleTargetingDefenderConfirm(bool confirmed)
    {
        if (currentTargetingInteraction == null || currentTargetingInteraction.DefenderData == null) return;
        if (confirmed)
        {
            await TargetingManager.ConfirmDefenderAsync(currentTargetingInteraction.InteractionId);
        }
        else
        {
            await TargetingManager.UpdateDefenderDataAsync(currentTargetingInteraction.InteractionId, currentTargetingInteraction.DefenderData, false);
        }
    }

    private async Task CancelTargeting()
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.CancelAsync(currentTargetingInteraction.InteractionId, "Cancelled by attacker");
        showTargetingModal = false;
        currentTargetingInteraction = null;
    }

    private void CloseTargetingModal()
    {
        showTargetingModal = false;
        currentTargetingInteraction = null;
        // Remove from pending if it's resolved
        if (currentTargetingInteraction != null)
        {
            pendingTargetingRequests.RemoveAll(r => r.InteractionId == currentTargetingInteraction.InteractionId);
        }
    }

    private async Task AcceptTargetingDamage()
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.AcceptDamageAsync(currentTargetingInteraction.InteractionId);

        // Apply damage to character if we're the defender
        if (!isTargetingAttacker && character != null && currentTargetingInteraction.Resolution != null)
        {
            var resolution = currentTargetingInteraction.Resolution;
            if (resolution.IsHit)
            {
                character.Fatigue.Value -= resolution.FATDamage;
                character.Vitality.Value -= resolution.VITDamage;

                // Save character
                if (character is Csla.Core.ISavable savable)
                {
                    await savable.SaveAsync();
                }

                AddLogEntry($"Took {resolution.FATDamage} FAT and {resolution.VITDamage} VIT damage from {currentTargetingInteraction.AttackerName}", ActivityCategory.Combat);
            }
        }

        StateHasChanged();
    }

    // ================================
    // Targeting Helper Methods
    // ================================

    private int GetTargetingMaxAPBoost()
    {
        if (character == null) return 0;
        // Reserve 1 AP for the action cost
        return Math.Max(0, character.ActionPoints.Available - 1);
    }

    private int GetTargetingMaxFATBoost()
    {
        if (character == null) return 0;
        // Reserve 1 FAT for the action cost
        return Math.Max(0, character.Fatigue.Value - 1);
    }

    private int GetDefenderDodgeAS()
    {
        if (character == null) return 0;
        var dodgeSkill = character.Skills.FirstOrDefault(s =>
            s.Name.Equals("Dodge", StringComparison.OrdinalIgnoreCase));
        return dodgeSkill?.AbilityScore ?? 0;
    }

    private int GetDefenderParryAS()
    {
        if (character == null) return 0;
        // Find weapon skill AS for parry
        var equippedItems = character.GetEquippedItems();
        var mainHand = equippedItems?.FirstOrDefault(i => i.Item.EquippedSlot == Threa.Dal.Dto.EquipmentSlot.MainHand);
        if (mainHand?.Template?.RelatedSkill != null)
        {
            var skill = character.Skills.FirstOrDefault(s =>
                s.Id.Equals(mainHand.Template.RelatedSkill, StringComparison.OrdinalIgnoreCase));
            return skill?.AbilityScore ?? 0;
        }
        return 0;
    }

    private bool GetDefenderIsInParryMode()
    {
        if (character == null) return false;
        return GameMechanics.Effects.Behaviors.CombatStanceBehavior.IsInParryMode(character);
    }

    private bool GetDefenderCanActiveDefense()
    {
        if (character == null) return false;
        return !character.IsPassedOut &&
               ((character.ActionPoints.Available >= 1 && character.Fatigue.Value >= 1) ||
                character.ActionPoints.Available >= 2);
    }

    private bool GetDefenderCanParry()
    {
        if (character == null) return false;
        return GetDefenderCanActiveDefense() || GetDefenderIsInParryMode();
    }

    /// <summary>
    /// Handles the targeting initiation callback from TabCombat.
    /// </summary>
    private async Task HandleInitiateTargeting((TargetingActionType ActionType, int TargetId, string TargetName, TargetingAttackerData AttackerData) args)
    {
        await InitiateTargeting(args.ActionType, args.TargetId, args.TargetName, args.AttackerData);
    }

    /// <summary>
    /// Initiates targeting from TabCombat. Called when player selects a target for attack.
    /// </summary>
    public async Task InitiateTargeting(TargetingActionType actionType, int targetCharacterId, string targetCharacterName, TargetingAttackerData attackerData)
    {
        if (character == null || table == null) return;

        var (interaction, queuePosition) = await TargetingManager.StartInteractionAsync(
            table.Id,
            character.Id,
            character.Name,
            targetCharacterId,
            targetCharacterName,
            attackerData);

        currentTargetingInteraction = interaction;
        showTargetingModal = true;
        isTargetingAttacker = true;

        if (queuePosition > 0)
        {
            AddLogEntry($"Attack queued. {targetCharacterName} has {queuePosition} other incoming attacks.", ActivityCategory.Combat);
        }

        StateHasChanged();
    }

    /// <summary>
    /// Gets available targets at the current table (excluding self).
    /// Filters out hidden NPCs (only visible NPCs appear as targets).
    /// </summary>
    public List<TargetSelectionModal.TargetInfo> GetAvailableTargets()
    {
        if (table == null || character == null)
            return new List<TargetSelectionModal.TargetInfo>();

        return tableCharacters
            .Where(c => c.CharacterId != character.Id)
            .Where(c => !c.IsNpc || c.VisibleToPlayers) // PCs always visible, NPCs only if revealed
            .Select(c => new TargetSelectionModal.TargetInfo
            {
                CharacterId = c.CharacterId,
                CharacterName = c.CharacterName,
                PlayerName = c.IsNpc ? null : "Player",
                IsNPC = c.IsNpc,
                Disposition = c.Disposition
            })
            .ToList();
    }

    /// <summary>
    /// Opens modal to change character image.
    /// </summary>
    private async Task OpenChangeImageModal()
    {
        if (character == null) return;

        var result = await DialogService.OpenAsync<ChangeImageModal>(
            "Change Character Image",
            new Dictionary<string, object>
            {
                { "CurrentImageUrl", character.ImageUrl }
            },
            new DialogOptions
            {
                Width = "500px",
                Resizable = true,
                Draggable = true
            }
        );

        if (result is string newImageUrl && !string.IsNullOrEmpty(newImageUrl))
        {
            character.ImageUrl = newImageUrl;
            try
            {
                character = await characterPortal.UpdateAsync(character);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to save character image: {ex.Message}";
            }
        }
    }
}
