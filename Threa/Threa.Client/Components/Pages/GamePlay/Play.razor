@page "/play/{CharacterId:int}"
@page "/play/{CharacterId:int}/{TableId:guid}"

@rendermode InteractiveServer

@attribute [Authorize]

@implements IDisposable

@using GameMechanics.Messaging
@using GameMechanics.Combat
@using GameMechanics.Combat.Effects
@using Threa.Services
@using Threa.Client.Services
@using Threa.Client.Components.Shared
@using Threa.Client.Components.Pages.GamePlay.Targeting
@using Radzen

@inject Csla.Blazor.State.StateManager StateManager
@inject ITargetingInteractionManager TargetingManager
@inject RenderModeProvider RenderModeProvider
@inject NavigationManager NavigationManager
@inject IDataPortal<GameMechanics.CharacterEdit> characterPortal
@inject IDataPortal<GameMechanics.GamePlay.TableEdit> tablePortal
@inject IActivityLogService ActivityLog
@inject ITimeEventSubscriber TimeEventSubscriber
@inject ITimeEventPublisher TimeEventPublisher
@inject IChildDataPortal<GameMechanics.EffectRecord> effectPortal
@inject IJSRuntime JS
@inject ICharacterItemDal CharacterItemDal
@inject IItemTemplateDal ItemTemplateDal
@inject IGameTimeFormatService TimeFormat
@inject GameMechanics.Combat.Effects.AttackEffectService AttackEffectService

@using GameMechanics.Time
@using Threa.Dal
@using Threa.Dal.Dto

@inject ITableDal TableDal
@inject IDataPortal<GameMechanics.GamePlay.TableCharacterList> characterListPortal
@inject DialogService DialogService
@inject PlayerConnectionTracker ConnectionTracker
@inject CircuitIdProvider CircuitIdProvider

<PageTitle>Threa - Play</PageTitle>

@if (errorMessage != null)
{
    <div class="alert alert-danger alert-dismissible fade show" role="alert">
        <i class="bi bi-exclamation-triangle-fill me-2"></i>
        <strong>Error:</strong> @errorMessage
        @if (errorMessage.Contains("not attached to this table"))
        {
            <div class="mt-2">
                <a href="/player/browse-campaigns" class="btn btn-sm btn-outline-primary">
                    <i class="bi bi-search me-1"></i>Browse Campaigns
                </a>
                <a href="/play" class="btn btn-sm btn-outline-secondary ms-2">
                    <i class="bi bi-arrow-left me-1"></i>Select Character
                </a>
            </div>
        }
        <button type="button" class="btn-close" @onclick="() => errorMessage = null" aria-label="Close"></button>
    </div>
}

@if (isLoading)
{
    <div>Loading character...</div>
}
else if (character == null)
{
    <div class="alert alert-warning">
        <p>Character not found or you don't have access to play this character.</p>
        <p><a href="/play">Select a different character</a></p>
    </div>
}
else
{
    <!-- Character Status Header (themed) -->
    <div class="character-header p-3 rounded mb-3">
        <div class="d-flex flex-column gap-3">
            <!-- Top row: Character identity + Resource pools + Table info -->
            <div class="d-flex flex-wrap justify-content-between align-items-start gap-3">
                <!-- Character Identity -->
                <div class="d-flex align-items-center gap-3">
                    @if (!string.IsNullOrEmpty(character.ImageUrl))
                    {
                        <img src="@character.ImageUrl" alt="@character.Name"
                             class="rounded" style="width: 48px; height: 48px; object-fit: cover; cursor: pointer;"
                             @onclick="OpenChangeImageModal"
                             title="Click to change image" />
                    }
                    else
                    {
                        <div class="rounded d-flex align-items-center justify-content-center"
                             style="width: 48px; height: 48px; background: var(--color-bg-tertiary); font-size: 1.5rem; cursor: pointer;"
                             @onclick="OpenChangeImageModal"
                             title="Click to add image">
                            @(character.Name.FirstOrDefault())
                        </div>
                    }
                    <div>
                        <h4 class="mb-0" style="font-family: var(--font-display);">@character.Name</h4>
                        <small style="color: var(--color-text-muted);">@character.Species</small>
                    </div>
                </div>

                <!-- Resource Pools -->
                <div class="d-flex gap-3 flex-wrap justify-content-center">
                    <!-- FAT Pool -->
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 100px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">FAT</small>
                        <div class="fw-bold fs-5" style="color: var(--color-fatigue);">
                            @character.Fatigue.Value<span style="color: var(--color-text-muted);">/@character.Fatigue.BaseValue</span>
                        </div>
                        <PendingPoolBar CurrentValue="@character.Fatigue.Value"
                                        MaxValue="@character.Fatigue.BaseValue"
                                        PendingDamage="@character.Fatigue.PendingDamage"
                                        PendingHealing="@character.Fatigue.PendingHealing"
                                        Height="8px" />
                        @if (character.Fatigue.PendingDamage > 0 || character.Fatigue.PendingHealing > 0)
                        {
                            <small class="d-block mt-1" style="font-size: 0.7rem;">
                                @if (character.Fatigue.PendingDamage > 0)
                                {
                                    <span style="color: var(--color-accent-red);">-@character.Fatigue.PendingDamage</span>
                                }
                                @if (character.Fatigue.PendingHealing > 0)
                                {
                                    <span style="color: var(--color-accent-green);" class="@(character.Fatigue.PendingDamage > 0 ? "ms-1" : "")">+@character.Fatigue.PendingHealing</span>
                                }
                            </small>
                        }
                    </div>

                    <!-- VIT Pool -->
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 100px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">VIT</small>
                        <div class="fw-bold fs-5" style="color: var(--color-vitality);">
                            @character.Vitality.Value<span style="color: var(--color-text-muted);">/@character.Vitality.BaseValue</span>
                        </div>
                        <PendingPoolBar CurrentValue="@character.Vitality.Value"
                                        MaxValue="@character.Vitality.BaseValue"
                                        PendingDamage="@character.Vitality.PendingDamage"
                                        PendingHealing="@character.Vitality.PendingHealing"
                                        Height="8px" />
                        @if (character.Vitality.PendingDamage > 0 || character.Vitality.PendingHealing > 0)
                        {
                            <small class="d-block mt-1" style="font-size: 0.7rem;">
                                @if (character.Vitality.PendingDamage > 0)
                                {
                                    <span style="color: var(--color-accent-red);">-@character.Vitality.PendingDamage</span>
                                }
                                @if (character.Vitality.PendingHealing > 0)
                                {
                                    <span style="color: var(--color-accent-green);" class="@(character.Vitality.PendingDamage > 0 ? "ms-1" : "")">+@character.Vitality.PendingHealing</span>
                                }
                            </small>
                        }
                    </div>

                    <!-- AP Pips -->
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 90px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">AP</small>
                        <div class="d-flex justify-content-center gap-1 my-1">
                            @for (int i = 0; i < character.ActionPoints.Max; i++)
                            {
                                var isAvailable = i < character.ActionPoints.Available;
                                <div class="ap-pip @(isAvailable ? "available" : "spent")">
                                    @if (isAvailable)
                                    {
                                        <i class="bi bi-lightning-fill" style="font-size: 0.6rem;"></i>
                                    }
                                </div>
                            }
                        </div>
                        <small style="color: var(--color-text-muted);">@character.ActionPoints.Available / @character.ActionPoints.Max</small>
                    </div>

                    <!-- Wounds Summary -->
                    @{
                        var woundCount = GetWoundCount();
                    }
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 80px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">WOUNDS</small>
                        <div class="fw-bold fs-5" style="color: @(woundCount > 0 ? "var(--color-accent-red)" : "var(--color-text-muted)");">
                            <i class="bi bi-bandaid"></i> @woundCount
                        </div>
                        @if (woundCount > 0)
                        {
                            <small style="color: var(--color-accent-red);">@(woundCount * -2) AS</small>
                        }
                    </div>
                </div>

                <!-- Table Info -->
                @if (table != null)
                {
                    <div class="text-end p-2 rounded" style="background: var(--color-bg-tertiary);">
                        <div style="font-family: var(--font-display); font-size: 0.85rem;">@table.Name</div>
                        <small style="color: var(--color-text-muted);">
                            <GameTimeDisplay EpochSeconds="table.CurrentTimeSeconds"
                                             Theme="@table.Theme"
                                             DefaultCalendarId="@table.DefaultCalendarId" />
                        </small>
                        <div class="mt-1">
                            @if (table.IsInCombat)
                            {
                                <span class="badge bg-danger">In Rounds</span>
                                <span class="badge bg-info ms-1">Round @table.CurrentRound</span>
                            }
                        </div>
                    </div>
                }
                else
                {
                    <!-- Local Time Management (no table) -->
                    <div class="text-end p-2 rounded" style="background: var(--color-bg-tertiary);">
                        <div style="font-family: var(--font-display); font-size: 0.85rem;">Solo Play</div>
                        <small style="color: var(--color-text-muted);">
                            <GameTimeDisplay EpochSeconds="localTimeSeconds"
                                             Theme="@(character.Setting ?? "fantasy")" />
                        </small>
                        <div class="mt-1">
                            @if (localIsInCombat)
                            {
                                <span class="badge bg-danger">In Rounds</span>
                                <span class="badge bg-info ms-1">Round @localCurrentRound</span>
                            }
                        </div>
                    </div>
                }
            </div>

            <!-- Active Effects Row -->
            @if (character.Effects.Any())
            {
                <div class="d-flex flex-wrap gap-2 align-items-center pt-2" style="border-top: 1px solid var(--color-card-border);">
                    <small class="me-2" style="font-family: var(--font-display); letter-spacing: 0.05em;">EFFECTS:</small>
                    @foreach (var effect in character.Effects)
                    {
                        <EffectIcon EffectType="@effect.EffectType.ToString()"
                                    EffectName="@effect.Name"
                                    Tooltip="@GetEffectTooltip(effect)"
                                    Stacks="@effect.CurrentStacks"
                                    Color="@GetEffectColor(effect)" />
                    }
                </div>
            }
        </div>
    </div>

    <!-- Local Time Management Panel (only visible when no table) -->
    @if (table == null)
    {
        <div class="card mb-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <strong><i class="bi bi-clock-history me-2"></i>Time Management</strong>
                <a href="/player/browse-campaigns" class="btn btn-sm btn-primary">
                    <i class="bi bi-door-open me-1"></i>Join a Table
                </a>
            </div>
            <div class="card-body">
                <div class="row g-2">
                    <!-- Combat Mode Toggle -->
                    <div class="col-12 mb-2">
                        @if (!localIsInCombat)
                        {
                            <button class="btn btn-danger w-100" @onclick="LocalEnterCombat">
                                <i class="bi bi-exclamation-triangle-fill me-1"></i>Enter Combat / Rounds
                            </button>
                        }
                        else
                        {
                            <button class="btn btn-success w-100" @onclick="LocalExitCombat">
                                <i class="bi bi-check-circle-fill me-1"></i>Exit Combat / Rounds
                            </button>
                        }
                    </div>

                    <!-- Round Advancement (only in combat) -->
                    @if (localIsInCombat)
                    {
                        <div class="col-12 mb-2">
                            <div class="btn-group w-100" role="group">
                                <button class="btn btn-outline-primary" @onclick="() => LocalAdvanceRounds(1)">
                                    <i class="bi bi-skip-forward-fill"></i> +1 Round
                                </button>
                                <button class="btn btn-outline-primary" @onclick="() => LocalAdvanceRounds(10)">
                                    +10 Rounds
                                </button>
                                <button class="btn btn-outline-primary" @onclick="() => LocalAdvanceRounds(20)">
                                    +1 Minute
                                </button>
                            </div>
                        </div>
                    }

                    <!-- Time Advancement (narrative time) -->
                    @if (!localIsInCombat)
                    {
                        <div class="col-12">
                            <label class="form-label small mb-1">Advance Time</label>
                            <div class="btn-group w-100 mb-2" role="group">
                                <button class="btn btn-sm btn-outline-primary" @onclick="() => LocalAdvanceTime(60)">+1 Min</button>
                                <button class="btn btn-sm btn-outline-primary" @onclick="() => LocalAdvanceTime(600)">+10 Min</button>
                                <button class="btn btn-sm btn-outline-primary" @onclick="() => LocalAdvanceTime(3600)">+1 Hour</button>
                            </div>
                            <div class="btn-group w-100" role="group">
                                <button class="btn btn-sm btn-outline-primary" @onclick="() => LocalAdvanceTime(86400)">+1 Day</button>
                                <button class="btn btn-sm btn-outline-primary" @onclick="() => LocalAdvanceTime(604800)">+1 Week</button>
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    }

    <!-- Targeting Notification Badge -->
    @if (pendingTargetingRequests.Any())
    {
        <div class="mb-3">
            <TargetingNotificationBadge PendingRequests="@pendingTargetingRequests"
                                        OnOpenTargeting="OpenTargetingModal"
                                        OnViewRequest="ViewTargetingRequest" />
        </div>
    }

    <!-- Tab Navigation -->
    <div class="tab-buttons">
        @foreach (var tabName in tabNames)
        {
            <button class="tab-link @(activeTab == tabName ? "active" : "")"
                    @onclick="() => SelectTab(tabName)">
                @tabName
            </button>
        }
    </div>

    <!-- Tab Content -->
    <div class="tab-content">
        @if (activeTab == "Status")
        {
            <TabStatus Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
        else if (activeTab == "Combat")
        {
            <TabCombat @ref="tabCombatRef"
                        Character="character"
                        Table="table"
                        OnCharacterChanged="SaveCharacterAsync"
                        AvailableTargets="@GetAvailableTargets()"
                        OnInitiateTargeting="HandleInitiateTargeting"
                        ActivityEntries="@activityLog"
                        GetActivityCssClass="GetActivityClass" />
        }
        else if (activeTab == "Skills")
        {
            <TabPlaySkills Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
        else if (activeTab == "Magic")
        {
            <TabPlayMagic Character="character" Table="table" />
        }
        else if (activeTab == "Inventory")
        {
            <TabPlayInventory Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
        else if (activeTab == "Narrative")
        {
            <TabPlayNarrative Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
    </div>

    @* RadzenDialog must be in the interactive context for DialogService to work *@
    <RadzenDialog />

    <!-- Targeting Modal -->
    @if (showTargetingModal && currentTargetingInteraction != null)
    {
        <div class="modal d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
            <div class="modal-dialog modal-xl modal-dialog-centered">
                <div class="modal-content">
                    <TargetingModal Interaction="@currentTargetingInteraction"
                                    IsAttacker="@isTargetingAttacker"
                                    maxAPBoost="@GetTargetingMaxAPBoost()"
                                    maxFATBoost="@GetTargetingMaxFATBoost()"
                                    defenderDodgeAS="@GetDefenderDodgeAS()"
                                    defenderParryAS="@GetDefenderParryAS()"
                                    defenderIsInParryMode="@GetDefenderIsInParryMode()"
                                    defenderCanActiveDefense="@GetDefenderCanActiveDefense()"
                                    defenderCanParry="@GetDefenderCanParry()"
                                    AttackerAvailableWeapons="@(isTargetingAttacker ? targetingAttackerWeapons : null)"
                                    OnAttackerDataUpdated="UpdateTargetingAttackerData"
                                    OnDefenderDataUpdated="UpdateTargetingDefenderData"
                                    OnAttackerConfirmChanged="ToggleTargetingAttackerConfirm"
                                    OnDefenderConfirmChanged="ToggleTargetingDefenderConfirm"
                                    OnCancel="CancelTargeting"
                                    OnClose="CloseTargetingModal"
                                    OnAcceptDamage="AcceptTargetingDamage" />
                </div>
            </div>
        </div>
    }

    <!-- Activity Log (hidden when Combat tab is active to avoid duplication) -->
    @if (activeTab != "Combat")
    {
        <div class="activity-log mt-3 activity-log-container">
            <h6>Activity Log</h6>
            @if (activityLog.Count == 0)
            {
                <p class="text-muted">No recent activity.</p>
            }
            else
            {
                @foreach (var entry in activityLog.TakeLast(10).Reverse())
                {
                    <div class="small @GetActivityClass(entry.Category)">
                        <span class="text-muted">[@entry.Timestamp.ToString("HH:mm:ss")]</span>
                        <strong>@entry.Source:</strong> @entry.Message
                    </div>
                }
            }
        </div>
    }
}

@code {
#pragma warning disable CS0618 // Using legacy round-based properties for UI display

[Parameter]
public int CharacterId { get; set; }

[Parameter]
public Guid TableId { get; set; }

private bool isLoading = true;
private static readonly string[] AllTabNames = new[] { "Status", "Combat", "Skills", "Magic", "Inventory", "Narrative" };
private string[] tabNames => GetTabNamesForTheme();
private string activeTab = "Status";

private string[] GetTabNamesForTheme()
{
    // Use table theme as authoritative setting during gameplay (character.Setting may be stale)
    var setting = table?.Theme ?? character?.Setting ?? "fantasy";
    if (setting == GameMechanics.GameSettings.SciFi)
    {
        return AllTabNames.Where(t => t != "Magic").ToArray();
    }
    return AllTabNames;
}

private void EnsureValidActiveTab()
{
    // If current tab is not in the available tabs (e.g., Magic in sci-fi), switch to Status
    if (!tabNames.Contains(activeTab))
    {
        activeTab = "Status";
    }
}

private GameMechanics.CharacterEdit? character;
private GameMechanics.GamePlay.TableEdit? table;
private string? errorMessage;
private List<ActivityLogEntry> activityLog = new();
private IDisposable? activityLogSubscription;
private bool timeEventSubscribed;
private bool _disposed;

// Local time management (for no-table characters)
private long localTimeSeconds = 0;
private int localCurrentRound = 0;
private bool localIsInCombat = false;

// Targeting state
private List<TargetingRequestMessage> pendingTargetingRequests = new();
private TargetingInteraction? currentTargetingInteraction;
private bool showTargetingModal;
private bool isTargetingAttacker;
private List<MeleeWeaponInfo>? targetingAttackerWeapons;
private List<GameMechanics.GamePlay.TableCharacterInfo> tableCharacters = new();

// Semaphore to prevent concurrent processing of time skip messages
private readonly SemaphoreSlim _timeSkipSemaphore = new(1, 1);

// Back button interception: track open Radzen dialogs so the back button dismisses them
// instead of navigating away from the play page.
private IDisposable? _locationChangingRegistration;
private int _openDialogCount = 0;
private TabCombat? tabCombatRef;

public record ActivityLogEntry(DateTime Timestamp, string Message, string Source, ActivityCategory Category);

protected override async Task OnInitializedAsync()
{
    await StateManager.InitializeAsync();

    if (RenderModeProvider.GetRenderMode(this).IsInteractive())
    {
        // Intercept navigation so the browser back button dismisses open dialogs
        // rather than leaving the play page.
        DialogService.OnOpen += OnDialogOpened;
        DialogService.OnClose += OnDialogClosed;
        _locationChangingRegistration = NavigationManager.RegisterLocationChangingHandler(OnLocationChanging);
        try
        {
            isLoading = true;

            // Load character directly from URL parameter
            character = await characterPortal.FetchAsync(CharacterId);
            await LoadEquippedItemsAsync();

            // If TableId is provided, load the table and verify character attachment
            if (TableId != Guid.Empty)
            {
                try
                {
                    // First verify the character is actually attached to this table
                    var attachedTable = await TableDal.GetTableForCharacterAsync(CharacterId);
                    if (attachedTable == null || attachedTable.Id != TableId)
                    {
                        errorMessage = "This character is not attached to this table. You must request to join the table and be approved by the Game Master before you can play.";
                        isLoading = false;
                        return;
                    }

                    table = await tablePortal.FetchAsync(TableId);
                    await LoadTableCharactersAsync();
                    SubscribeToActivityLog(TableId);
                    await SubscribeToTimeEvents(TableId);

                    // Register this connection with the tracker
                    if (!string.IsNullOrEmpty(CircuitIdProvider.CircuitId))
                    {
                        await ConnectionTracker.RegisterConnectionAsync(CircuitIdProvider.CircuitId, CharacterId, TableId);
                    }

                    // Apply the table's theme
                    if (table != null)
                    {
                        await JS.InvokeVoidAsync("threaTheme.apply", table.Theme ?? "fantasy");

                        // Sync character setting with table theme (rebuilds wallet if needed)
                        if (character != null && !string.IsNullOrEmpty(table.Theme) && character.Setting != table.Theme)
                        {
                            character.Setting = table.Theme;
                            character = await character.SaveAsync();
                        }
                    }
                }
                catch (Exception ex)
                {
                    errorMessage = $"Failed to load table: {ex.Message}";
                }
            }

            AddLogEntry($"Playing as {character.Name}", ActivityCategory.Player);

            // If joining an in-progress table, announce the current game time
            if (table != null && table.Status == Threa.Dal.Dto.TableStatus.Active)
            {
                var timeDisplay = TimeFormat.FormatFull(table.CurrentTimeSeconds);
                AddLogEntry($"The in-game time is: {timeDisplay}", ActivityCategory.Time);
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load character: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }
}

protected override async Task OnAfterRenderAsync(bool firstRender)
{
    // Ensure theme is applied after render, especially important when rejoining tables
    if (firstRender && table != null)
    {
        try
        {
            await JS.InvokeVoidAsync("threaTheme.apply", table.Theme ?? "fantasy");
        }
        catch
        {
            // JS might not be ready yet, ignore
        }
    }
}

private async Task LoadEquippedItemsAsync()
{
    if (character == null) return;
    var equippedItems = await CharacterItemDal.GetEquippedItemsWithTemplatesAsync(character.Id);
    character.SetEquippedItems(equippedItems);

    // Also load chip items (needs all items to find chips inside equipped Skillwires)
    var allItems = await CharacterItemDal.GetCharacterItemsAsync(character.Id);
    character.SetChipItems(allItems);
}

private async Task LoadTableCharactersAsync()
{
    if (table == null) return;
    var charList = await characterListPortal.FetchAsync(table.Id);
    tableCharacters = charList.ToList();
}

    private void SelectTab(string tabName)
    {
        activeTab = tabName;
    }

    private void AddLogEntry(string message, ActivityCategory category = ActivityCategory.General)
    {
        // Only publish if we have a table context
        if (table != null)
        {
            ActivityLog.Publish(table.Id, message, character?.Name ?? "Player", category);
        }
        else
        {
            // Local-only for when there's no table
            activityLog.Add(new ActivityLogEntry(DateTime.Now, message, character?.Name ?? "Player", category));
            if (activityLog.Count > 100)
                activityLog.RemoveAt(0);
        }
    }

    private void SubscribeToActivityLog(Guid tableId)
    {
        // Unsubscribe from any previous subscription
        activityLogSubscription?.Dispose();

        activityLogSubscription = ActivityLog.Subscribe(tableId, msg =>
        {
            InvokeAsync(() =>
            {
                activityLog.Add(new ActivityLogEntry(msg.Timestamp, msg.Message, msg.Source, msg.Category));
                if (activityLog.Count > 100) activityLog.RemoveAt(0);
                StateHasChanged();
            });
        });
    }

    private async Task SubscribeToTimeEvents(Guid tableId)
    {
        if (timeEventSubscribed)
        {
            return;
        }

        // Connect and subscribe to time events
        await TimeEventSubscriber.ConnectAsync();
        await TimeEventSubscriber.SubscribeAsync();

        // Connect publisher to send character update notifications
        await TimeEventPublisher.ConnectAsync();

        TimeEventSubscriber.TimeEventReceived += OnTimeEventReceived;
        TimeEventSubscriber.TimeSkipReceived += OnTimeSkipReceived;
        TimeEventSubscriber.CombatStateReceived += OnCombatStateReceived;
        TimeEventSubscriber.CharacterUpdateReceived += OnCharacterUpdateReceived;
        TimeEventSubscriber.TableUpdateReceived += OnTableUpdateReceived;
        TimeEventSubscriber.CharactersUpdatedReceived += OnCharactersUpdatedReceived;

        // Targeting message subscriptions
        TimeEventSubscriber.TargetingRequestReceived += OnTargetingRequestReceived;
        TimeEventSubscriber.TargetingResponseReceived += OnTargetingResponseReceived;
        TimeEventSubscriber.TargetingUpdateReceived += OnTargetingUpdateReceived;
        TimeEventSubscriber.TargetingResultReceived += OnTargetingResultReceived;
        TimeEventSubscriber.TargetingCancelledReceived += OnTargetingCancelledReceived;

        timeEventSubscribed = true;
    }

    /// <summary>
    /// Handles the authoritative notification that characters have been updated server-side.
    /// Time processing is now done by TimeAdvancementService on the server.
    /// Player clients just need to refresh their character state from the database.
    /// </summary>
    private void OnCharactersUpdatedReceived(object? sender, CharactersUpdatedMessage e)
    {
        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.TableId != table.Id) return;

        // Check if our character is in the updated list
        if (character == null || !e.CharacterIds.Contains(character.Id)) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Reload character from database to get the updated state
                int characterId = character.Id;
                character = await characterPortal.FetchAsync(characterId);
                await LoadEquippedItemsAsync();

                // Also refresh table state
                table = await tablePortal.FetchAsync(table.Id);

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error refreshing character: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnTimeEventReceived(object? sender, TimeEventMessage e)
    {
        // NOTE: Time processing is now done server-side by TimeAdvancementService.
        // This handler is kept for backward compatibility but the main updates
        // come through CharactersUpdatedReceived.

        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.CampaignId != table.Id.ToString()) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Just refresh the table state to show updated time/rounds
                if (table != null)
                {
                    table = await tablePortal.FetchAsync(table.Id);
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing time event: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnTimeSkipReceived(object? sender, TimeSkipMessage e)
    {
        // NOTE: Time processing is now done server-side by TimeAdvancementService.
        // This handler is kept for backward compatibility but the main updates
        // come through CharactersUpdatedReceived.

        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.CampaignId != table.Id.ToString())
        {
            return;
        }

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Just refresh table state to show updated time
                if (table != null)
                {
                    table = await tablePortal.FetchAsync(table.Id);
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing time skip: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnCombatStateReceived(object? sender, CombatStateMessage e)
    {
        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.CampaignId != table.Id.ToString()) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Refresh the table to get the updated combat state
                table = await tablePortal.FetchAsync(table.Id);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing combat state: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnCharacterUpdateReceived(object? sender, CharacterUpdateMessage e)
    {
        // Ignore events if component is disposed
        if (_disposed || table == null) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // If this is our character, refresh it
                if (character != null && e.CharacterId == character.Id)
                {
                    character = await characterPortal.FetchAsync(character.Id);
                    await LoadEquippedItemsAsync();
                }

                // Always refresh table characters to catch NPC visibility changes
                await LoadTableCharactersAsync();

                // Check if we're in targeting and our target is no longer valid
                if (currentTargetingInteraction != null && showTargetingModal)
                {
                    var targetId = currentTargetingInteraction.DefenderId;
                    var target = tableCharacters.FirstOrDefault(c => c.CharacterId == targetId);

                    // Target invalid if: not found, or is NPC that's now hidden
                    bool targetInvalid = target == null ||
                        (target.IsNpc && !target.VisibleToPlayers);

                    if (targetInvalid)
                    {
                        // Cancel the targeting interaction
                        await TargetingManager.CancelAsync(
                            currentTargetingInteraction.InteractionId,
                            "Target is no longer available");

                        // Close the modal
                        showTargetingModal = false;
                        currentTargetingInteraction = null;

                        // Log the invalidation for the player
                        AddLogEntry("Target hidden - select a new target", ActivityCategory.Combat);
                    }
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing character update: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnTableUpdateReceived(object? sender, TableUpdateMessage e)
    {
        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.TableId != table.Id) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Handle theme changes
                if (e.UpdateType == "ThemeChanged" && !string.IsNullOrEmpty(e.Theme))
                {
                    await JS.InvokeVoidAsync("threaTheme.apply", e.Theme);
                    // Update local table state
                    table = await tablePortal.FetchAsync(table.Id);
                    // Ensure active tab is valid for the new theme (e.g., Magic not available in sci-fi)
                    EnsureValidActiveTab();
                }
                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing table update: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private async Task UnsubscribeFromTimeEvents()
    {
        if (!timeEventSubscribed)
        {
            return;
        }

        TimeEventSubscriber.TimeEventReceived -= OnTimeEventReceived;
        TimeEventSubscriber.TimeSkipReceived -= OnTimeSkipReceived;
        TimeEventSubscriber.CombatStateReceived -= OnCombatStateReceived;
        TimeEventSubscriber.CharacterUpdateReceived -= OnCharacterUpdateReceived;
        TimeEventSubscriber.TableUpdateReceived -= OnTableUpdateReceived;
        TimeEventSubscriber.CharactersUpdatedReceived -= OnCharactersUpdatedReceived;

        // Unsubscribe from targeting messages
        TimeEventSubscriber.TargetingRequestReceived -= OnTargetingRequestReceived;
        TimeEventSubscriber.TargetingResponseReceived -= OnTargetingResponseReceived;
        TimeEventSubscriber.TargetingUpdateReceived -= OnTargetingUpdateReceived;
        TimeEventSubscriber.TargetingResultReceived -= OnTargetingResultReceived;
        TimeEventSubscriber.TargetingCancelledReceived -= OnTargetingCancelledReceived;

        await TimeEventSubscriber.UnsubscribeAsync();
        timeEventSubscribed = false;
    }

    public async void Dispose()
    {
        if (_disposed)
        {
            return;
        }
        _disposed = true;

        _locationChangingRegistration?.Dispose();
        DialogService.OnOpen -= OnDialogOpened;
        DialogService.OnClose -= OnDialogClosed;

        activityLogSubscription?.Dispose();
        await UnsubscribeFromTimeEvents();
        _timeSkipSemaphore?.Dispose();
    }

    /// <summary>
    /// Intercepts navigation (e.g. browser back button). When dialogs, the targeting modal,
    /// or a non-default combat mode are active, closes/resets them and prevents leaving the
    /// play page.
    /// </summary>
    private ValueTask OnLocationChanging(LocationChangingContext context)
    {
        if (_openDialogCount > 0 || showTargetingModal || (tabCombatRef?.IsInNonDefaultMode ?? false))
        {
            // Snapshot the count before closing to avoid any risk of an infinite loop
            // if Close() were ever queued rather than synchronously firing OnClose.
            var count = _openDialogCount;
            for (int i = 0; i < count; i++)
            {
                DialogService.Close(null);
            }
            // Close the targeting modal if visible
            showTargetingModal = false;
            // Reset any active combat mode (attack, defend, etc.)
            tabCombatRef?.ResetCombatMode();
            context.PreventNavigation();
            _ = InvokeAsync(StateHasChanged);
        }
        return ValueTask.CompletedTask;
    }

    private void OnDialogOpened(string? title, Type type, Dictionary<string, object?> parameters, DialogOptions options)
    {
        _openDialogCount++;
    }

    // 'dynamic' is required to match Radzen's Action<dynamic> OnClose event signature.
    private void OnDialogClosed(dynamic result)
    {
        if (_openDialogCount > 0)
            _openDialogCount--;
    }

    private string GetActivityClass(ActivityCategory category) =>
        category switch
        {
            ActivityCategory.Combat => "text-danger",
            ActivityCategory.Announcement => "text-primary fw-bold",
            ActivityCategory.Health => "text-success",
            ActivityCategory.Effect => "text-warning",
            ActivityCategory.Time => "text-info",
            ActivityCategory.Session => "text-secondary fst-italic",
            ActivityCategory.Player => "text-muted",
            _ => ""
        };

    private async Task SaveCharacterAsync()
    {
        if (character == null) return;
        try
        {
            await characterPortal.UpdateAsync(character);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to save character: {ex.Message}";
        }
    }

    // UI Helper methods
    private int GetWoundCount() => character?.Effects.Count(e => e.EffectType == Threa.Dal.Dto.EffectType.Wound) ?? 0;

    private string GetEffectTooltip(GameMechanics.EffectRecord effect)
    {
        string duration = "";
        if (effect.ExpiresAtEpochSeconds.HasValue)
        {
            var remainingSeconds = effect.ExpiresAtEpochSeconds.Value - (character?.CurrentGameTimeSeconds ?? 0);
            if (remainingSeconds > 0)
            {
                var remainingRounds = (int)(remainingSeconds / 3);
                duration = $" ({remainingRounds} rounds left)";
            }
            else
            {
                duration = " (Expired)";
            }
        }
        var source = string.IsNullOrEmpty(effect.Source) ? "" : $" (Source: {effect.Source})";
        var description = string.IsNullOrEmpty(effect.Description) ? "" : $": {effect.Description}";

        return $"{effect.Name}{description}{duration}{source}";
    }

    private string GetEffectColor(GameMechanics.EffectRecord effect) => effect.EffectType switch
    {
        Threa.Dal.Dto.EffectType.Buff => "var(--color-accent-green)",
        Threa.Dal.Dto.EffectType.Debuff or Threa.Dal.Dto.EffectType.Poison => "var(--color-accent-red)",
        Threa.Dal.Dto.EffectType.Wound => "var(--color-accent-red)",
        Threa.Dal.Dto.EffectType.Disease => "var(--color-accent-secondary)",
        Threa.Dal.Dto.EffectType.Condition => "var(--color-accent-gold)",
        Threa.Dal.Dto.EffectType.SpellEffect => "var(--color-accent-blue)",
        Threa.Dal.Dto.EffectType.ItemEffect => "var(--color-accent-primary)",
        _ => "var(--color-text-primary)"
    };

    // ================================
    // Concentration Result Processing
    // ================================

    /// <summary>
    /// Processes the LastConcentrationResult from a character after concentration ends.
    /// Handles magazine reload completion and sustained effect cleanup.
    /// </summary>
    private async Task ProcessConcentrationResult(GameMechanics.CharacterEdit targetCharacter)
    {
        var result = targetCharacter.LastConcentrationResult;
        if (result == null) return;

        try
        {
            switch (result.ActionType)
            {
                case "MagazineReload":
                    if (result.Success)
                    {
                        await ExecuteMagazineReload(targetCharacter, result.Payload);
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        // Reload was interrupted
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "SustainedBreak":
                    await ProcessSustainedBreak(result.Payload);
                    AddLogEntry(result.Message, ActivityCategory.Effect);
                    break;

                case "SpellCast":
                    // TODO: Implement when spell system is ready
                    if (result.Success)
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "AmmoContainerReload":
                    if (result.Success)
                    {
                        await ExecuteAmmoContainerReload(targetCharacter, result.Payload);
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "AmmoContainerUnload":
                    if (result.Success)
                    {
                        await ExecuteAmmoContainerUnload(targetCharacter, result.Payload);
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "WeaponUnload":
                    if (result.Success)
                    {
                        await ExecuteWeaponUnload(targetCharacter, result.Payload);
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "SkillUse":
                    // Pre-use skill concentration completed - skill is now ready to use
                    if (result.Success)
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        // Pre-use concentration was interrupted - skill did not execute
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "PostUseSkillEnded":
                    // Post-use concentration completed normally - linked effects will be removed
                    AddLogEntry(result.Message, ActivityCategory.Effect);
                    break;

                case "PostUseSkillInterrupted":
                    // Post-use concentration was interrupted - linked effects removed and penalty applied
                    AddLogEntry(result.Message, ActivityCategory.Effect);
                    break;
            }
        }
        finally
        {
            // Always clear the result after processing
            targetCharacter.ClearConcentrationResult();
        }
    }

    /// <summary>
    /// Executes the magazine reload by updating the weapon's LoadedAmmo via WeaponAmmoState.
    /// </summary>
    private async Task ExecuteMagazineReload(GameMechanics.CharacterEdit targetCharacter, string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        var payload = GameMechanics.Effects.Behaviors.MagazineReloadPayload.FromJson(payloadJson);
        if (payload == null) return;

        try
        {
            var weapon = await CharacterItemDal.GetItemAsync(payload.WeaponItemId);
            if (weapon != null)
            {
                var ammoState = GameMechanics.Combat.WeaponAmmoState.FromJson(weapon.CustomProperties);

                if (payload.IsLooseAmmo)
                {
                    // Loose ammo: rounds were transferred directly into weapon
                    ammoState.LoadedAmmo = payload.RoundsToLoad;
                }
                else
                {
                    // Magazine: link the magazine to the weapon; magazine stays in inventory
                    var magazine = await CharacterItemDal.GetItemAsync(payload.MagazineItemId);
                    if (magazine != null)
                    {
                        var magazineState = GameMechanics.Combat.AmmoContainerState.FromJson(magazine.CustomProperties);
                        ammoState.LoadedMagazineId = payload.MagazineItemId;
                        ammoState.LoadedAmmo = magazineState.LoadedAmmo;
                        ammoState.LoadedAmmoType = payload.AmmoType;
                    }
                }

                weapon.CustomProperties = GameMechanics.Combat.WeaponAmmoState.MergeIntoCustomProperties(
                    weapon.CustomProperties, ammoState);
                await CharacterItemDal.UpdateItemAsync(weapon);
                await LoadEquippedItemsAsync();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to complete magazine reload: {ex.Message}";
        }
    }

    /// <summary>
    /// Executes the ammo container reload by updating the container's ammo state and reducing the loose ammo stack.
    /// </summary>
    private async Task ExecuteAmmoContainerReload(GameMechanics.CharacterEdit targetCharacter, string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        var payload = GameMechanics.Effects.Behaviors.AmmoContainerReloadPayload.FromJson(payloadJson);
        if (payload == null) return;

        try
        {
            // Update container ammo state
            var container = await CharacterItemDal.GetItemAsync(payload.ContainerId);
            if (container != null)
            {
                var containerState = GameMechanics.Combat.AmmoContainerState.FromJson(container.CustomProperties);
                containerState.LoadedAmmo += payload.RoundsToLoad;
                if (payload.AmmoType != null)
                    containerState.AmmoType = payload.AmmoType;
                container.CustomProperties = GameMechanics.Combat.AmmoContainerState.MergeIntoCustomProperties(
                    container.CustomProperties, containerState);
                await CharacterItemDal.UpdateItemAsync(container);
            }

            // Reduce source ammo stack
            var source = await CharacterItemDal.GetItemAsync(payload.SourceItemId);
            if (source != null)
            {
                source.StackSize -= payload.RoundsToLoad;
                if (source.StackSize <= 0)
                    await CharacterItemDal.DeleteItemAsync(payload.SourceItemId);
                else
                    await CharacterItemDal.UpdateItemAsync(source);
            }

            // Reload equipped items to reflect the change
            await LoadEquippedItemsAsync();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to complete ammo container reload: {ex.Message}";
        }
    }

    /// <summary>
    /// Executes the ammo container unload by returning rounds to loose ammo inventory.
    /// </summary>
    private async Task ExecuteAmmoContainerUnload(GameMechanics.CharacterEdit targetCharacter, string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        var payload = GameMechanics.Effects.Behaviors.AmmoContainerUnloadPayload.FromJson(payloadJson);
        if (payload == null) return;

        try
        {
            // Update container - remove ammo
            var container = await CharacterItemDal.GetItemAsync(payload.ContainerId);
            if (container != null)
            {
                var containerState = GameMechanics.Combat.AmmoContainerState.FromJson(container.CustomProperties);
                containerState.LoadedAmmo = Math.Max(0, containerState.LoadedAmmo - payload.RoundsToUnload);
                container.CustomProperties = GameMechanics.Combat.AmmoContainerState.MergeIntoCustomProperties(
                    container.CustomProperties, containerState);
                await CharacterItemDal.UpdateItemAsync(container);
            }

            // Add loose ammo to inventory (find existing stack or create new)
            await AddLooseAmmoToInventory(payload.CharacterId, payload.RoundsToUnload, payload.AmmoType);

            // Reload equipped items to reflect the change
            await LoadEquippedItemsAsync();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to complete ammo container unload: {ex.Message}";
        }
    }

    /// <summary>
    /// Executes the weapon unload by returning rounds to loose ammo inventory.
    /// </summary>
    private async Task ExecuteWeaponUnload(GameMechanics.CharacterEdit targetCharacter, string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        var payload = GameMechanics.Effects.Behaviors.WeaponUnloadPayload.FromJson(payloadJson);
        if (payload == null) return;

        try
        {
            // Update weapon - remove ammo
            var weapon = await CharacterItemDal.GetItemAsync(payload.WeaponItemId);
            if (weapon != null)
            {
                var ammoState = GameMechanics.Combat.WeaponAmmoState.FromJson(weapon.CustomProperties);

                // Remove rounds (from chamber first, then magazine)
                int toRemove = payload.RoundsToUnload;
                if (ammoState.ChamberLoaded && toRemove > 0)
                {
                    ammoState.ChamberLoaded = false;
                    toRemove--;
                }
                ammoState.LoadedAmmo = Math.Max(0, ammoState.LoadedAmmo - toRemove);

                weapon.CustomProperties = GameMechanics.Combat.WeaponAmmoState.MergeIntoCustomProperties(
                    weapon.CustomProperties, ammoState);
                await CharacterItemDal.UpdateItemAsync(weapon);
            }

            // Add loose ammo to inventory (find existing stack or create new)
            await AddLooseAmmoToInventory(payload.CharacterId, payload.RoundsToUnload, payload.AmmoType);

            // Reload equipped items to reflect the change
            await LoadEquippedItemsAsync();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to complete weapon unload: {ex.Message}";
        }
    }

    /// <summary>
    /// Adds loose ammo to inventory. Finds existing stack of same type or creates new item.
    /// </summary>
    private async Task AddLooseAmmoToInventory(int characterId, int roundCount, string? ammoType)
    {
        if (roundCount <= 0) return;

        // Try to find existing loose ammo stack of the same type
        var items = await CharacterItemDal.GetCharacterItemsAsync(characterId);
        Threa.Dal.Dto.CharacterItem? existingStack = null;

        foreach (var item in items)
        {
            // Skip items in containers
            if (item.ContainerItemId != null) continue;

            var template = await ItemTemplateDal.GetTemplateAsync(item.ItemTemplateId);
            if (template?.ItemType != Threa.Dal.Dto.ItemType.Ammunition) continue;

            var ammoProps = GameMechanics.Combat.AmmunitionProperties.FromJson(template.CustomProperties);
            if (ammoProps?.IsContainer == true) continue; // Skip magazines

            // Check ammo type match
            if (string.IsNullOrEmpty(ammoType) ||
                string.IsNullOrEmpty(ammoProps?.AmmoType) ||
                ammoType.Equals(ammoProps.AmmoType, StringComparison.OrdinalIgnoreCase))
            {
                existingStack = item;
                break;
            }
        }

        if (existingStack != null)
        {
            // Add to existing stack
            existingStack.StackSize += roundCount;
            await CharacterItemDal.UpdateItemAsync(existingStack);
        }
        else
        {
            // Need to create a new ammo item - find a template for loose ammo of this type
            var templates = await ItemTemplateDal.GetAllTemplatesAsync();
            Threa.Dal.Dto.ItemTemplate? ammoTemplate = null;

            foreach (var t in templates)
            {
                if (t.ItemType != Threa.Dal.Dto.ItemType.Ammunition) continue;
                var props = GameMechanics.Combat.AmmunitionProperties.FromJson(t.CustomProperties);
                if (props?.IsContainer == true) continue;

                if (string.IsNullOrEmpty(ammoType) ||
                    string.IsNullOrEmpty(props?.AmmoType) ||
                    ammoType.Equals(props.AmmoType, StringComparison.OrdinalIgnoreCase))
                {
                    ammoTemplate = t;
                    break;
                }
            }

            if (ammoTemplate != null)
            {
                var newItem = new Threa.Dal.Dto.CharacterItem
                {
                    Id = Guid.NewGuid(),
                    OwnerCharacterId = characterId,
                    ItemTemplateId = ammoTemplate.Id,
                    StackSize = roundCount,
                    IsEquipped = false
                };
                await CharacterItemDal.AddItemAsync(newItem);
            }
            else
            {
                // Couldn't find a template - log warning but don't fail
                Console.WriteLine($"Warning: Could not find ammo template for type '{ammoType}' - rounds lost");
            }
        }
    }

    /// <summary>
    /// Processes sustained concentration break by removing all linked effects from table characters.
    /// </summary>
    private async Task ProcessSustainedBreak(string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        // Parse the payload to get LinkedEffectIds
        try
        {
            var payload = System.Text.Json.JsonSerializer.Deserialize<SustainedBreakPayload>(payloadJson);
            if (payload?.LinkedEffectIds == null || payload.LinkedEffectIds.Count == 0) return;

            var linkedIds = new HashSet<Guid>(payload.LinkedEffectIds);

            // For the current character, remove matching effects
            if (character != null)
            {
                var effectsToRemove = character.Effects
                    .Where(e => linkedIds.Contains(e.Id))
                    .ToList();

                foreach (var effect in effectsToRemove)
                {
                    character.Effects.RemoveEffect(effect.Id);
                }

                // Also remove effects that have matching SourceEffectId
                var linkedBySource = character.Effects
                    .Where(e => e.SourceEffectId.HasValue && linkedIds.Contains(e.SourceEffectId.Value))
                    .ToList();

                foreach (var effect in linkedBySource)
                {
                    character.Effects.RemoveEffect(effect.Id);
                }

                // Save if any effects were removed
                if (effectsToRemove.Count > 0 || linkedBySource.Count > 0)
                {
                    await characterPortal.UpdateAsync(character);
                }
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error processing sustained break: {ex.Message}";
        }
    }

    /// <summary>
    /// Payload structure for sustained break result.
    /// </summary>
    private class SustainedBreakPayload
    {
        public List<Guid>? LinkedEffectIds { get; set; }
        public string? SpellName { get; set; }
    }

    // ================================
    // Targeting Event Handlers
    // ================================

    private void OnTargetingRequestReceived(object? sender, TargetingRequestMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;
        if (character == null) return;

        // Check if we are the defender
        if (e.DefenderId == character.Id)
        {
            _ = InvokeAsync(() =>
            {
                pendingTargetingRequests.Add(e);
                StateHasChanged();
            });
        }
        // Check if we are the attacker and opened targeting
        else if (e.AttackerId == character.Id)
        {
            _ = InvokeAsync(() =>
            {
                currentTargetingInteraction = TargetingManager.GetInteraction(e.InteractionId);
                if (currentTargetingInteraction != null)
                {
                    showTargetingModal = true;
                    isTargetingAttacker = true;
                    StateHasChanged();
                }
            });
        }
    }

    private void OnTargetingResponseReceived(object? sender, TargetingResponseMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;
        if (currentTargetingInteraction == null || e.InteractionId != currentTargetingInteraction.InteractionId) return;

        _ = InvokeAsync(() =>
        {
            // Update local interaction state if needed
            var interaction = TargetingManager.GetInteraction(e.InteractionId);
            if (interaction != null)
            {
                currentTargetingInteraction = interaction;
            }
            StateHasChanged();
        });
    }

    private void OnTargetingUpdateReceived(object? sender, TargetingUpdateMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;
        if (currentTargetingInteraction == null || e.InteractionId != currentTargetingInteraction.InteractionId) return;

        _ = InvokeAsync(() =>
        {
            // Refresh interaction from manager
            var interaction = TargetingManager.GetInteraction(e.InteractionId);
            if (interaction != null)
            {
                currentTargetingInteraction = interaction;
            }
            StateHasChanged();
        });
    }

    private void OnTargetingResultReceived(object? sender, TargetingResultMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;

        _ = InvokeAsync(async () =>
        {
            // If we have this interaction open, update it
            if (currentTargetingInteraction != null && e.InteractionId == currentTargetingInteraction.InteractionId)
            {
                var interaction = TargetingManager.GetInteraction(e.InteractionId);
                if (interaction != null)
                {
                    currentTargetingInteraction = interaction;
                }

                // Deduct ammo when we're the attacker in a ranged targeting interaction
                if (isTargetingAttacker &&
                    currentTargetingInteraction?.AttackerData.ActionType == TargetingActionType.RangedAttack &&
                    currentTargetingInteraction?.Resolution != null &&
                    tabCombatRef != null)
                {
                    var res = currentTargetingInteraction.Resolution;
                    await tabCombatRef.HandleTargetedRangedAmmoUpdateAsync(res.WeaponItemId, res.AmmoRemaining);
                }
            }

            // Remove from pending requests if we're the defender
            pendingTargetingRequests.RemoveAll(r => r.InteractionId == e.InteractionId);

            StateHasChanged();
        });
    }

    private void OnTargetingCancelledReceived(object? sender, TargetingCancelledMessage e)
    {
        // Ignore if not our table or disposed
        if (_disposed || table == null || e.TableId != table.Id) return;

        _ = InvokeAsync(() =>
        {
            // Close modal if we have this interaction open
            if (currentTargetingInteraction != null && e.InteractionId == currentTargetingInteraction.InteractionId)
            {
                var interaction = TargetingManager.GetInteraction(e.InteractionId);
                if (interaction != null)
                {
                    currentTargetingInteraction = interaction;
                }
            }

            // Remove from pending requests
            pendingTargetingRequests.RemoveAll(r => r.InteractionId == e.InteractionId);

            StateHasChanged();
        });
    }

    // ================================
    // Targeting UI Methods
    // ================================

    private void OpenTargetingModal()
    {
        if (character == null) return;

        // Open the first pending request
        var request = pendingTargetingRequests.FirstOrDefault();
        if (request != null)
        {
            ViewTargetingRequest(request);
        }
    }

    private void ViewTargetingRequest(TargetingRequestMessage request)
    {
        var interaction = TargetingManager.GetInteraction(request.InteractionId);
        if (interaction != null)
        {
            currentTargetingInteraction = interaction;
            showTargetingModal = true;
            isTargetingAttacker = false;
            StateHasChanged();
        }
    }

    private async Task UpdateTargetingAttackerData(TargetingAttackerData data)
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.UpdateAttackerDataAsync(currentTargetingInteraction.InteractionId, data);
    }

    private async Task UpdateTargetingDefenderData(TargetingDefenderData data)
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.UpdateDefenderDataAsync(currentTargetingInteraction.InteractionId, data);
    }

    private async Task ToggleTargetingAttackerConfirm(bool confirmed)
    {
        if (currentTargetingInteraction == null) return;
        if (confirmed)
        {
            // Deduct attack action costs when attacker locks in
            if (character != null)
            {
                var data = currentTargetingInteraction.AttackerData;
                int baseAPCost = data.ActionCostType == ActionCostType.TwoAP ? 2 : 1;
                int baseFATCost = data.ActionCostType == ActionCostType.OneAPOneFat ? 1 : 0;

                character.ActionPoints.Available -= baseAPCost + data.APBoost;
                character.ActionPoints.ActionsTakenThisRound += 1;
                character.Fatigue.Value -= baseFATCost + data.FATBoost;

                if (character is Csla.Core.ISavable savable)
                    await savable.SaveAsync();
            }
            await TargetingManager.ConfirmAttackerAsync(currentTargetingInteraction.InteractionId);
        }
        else
        {
            await TargetingManager.UpdateAttackerDataAsync(currentTargetingInteraction.InteractionId, currentTargetingInteraction.AttackerData, false);
        }
    }

    private async Task ToggleTargetingDefenderConfirm(bool confirmed)
    {
        if (currentTargetingInteraction == null || currentTargetingInteraction.DefenderData == null) return;
        if (confirmed)
        {
            // Deduct defense costs for active defense when defender locks in
            if (character != null)
            {
                var data = currentTargetingInteraction.DefenderData;
                bool isActiveDefense = data.DefenseType == DefenseType.Dodge ||
                                       data.DefenseType == DefenseType.ShieldBlock ||
                                       (data.DefenseType == DefenseType.Parry && !data.IsInParryMode);

                if (isActiveDefense)
                {
                    int baseAPCost = data.DefenseCostType == ActionCostType.TwoAP ? 2 : 1;
                    int baseFATCost = data.DefenseCostType == ActionCostType.OneAPOneFat ? 1 : 0;

                    character.ActionPoints.Available -= baseAPCost + data.APBoost;
                    character.ActionPoints.ActionsTakenThisRound += 1;
                    character.Fatigue.Value -= baseFATCost + data.FATBoost;

                    if (character is Csla.Core.ISavable savable)
                        await savable.SaveAsync();
                }
            }
            await TargetingManager.ConfirmDefenderAsync(currentTargetingInteraction.InteractionId);
        }
        else
        {
            await TargetingManager.UpdateDefenderDataAsync(currentTargetingInteraction.InteractionId, currentTargetingInteraction.DefenderData, false);
        }
    }

    private async Task CancelTargeting()
    {
        if (currentTargetingInteraction == null) return;

        // Refund AP/FAT if attacker already confirmed (costs were charged on confirm)
        if (isTargetingAttacker && currentTargetingInteraction.AttackerConfirmed && character != null)
        {
            var data = currentTargetingInteraction.AttackerData;
            int baseAPCost = data.ActionCostType == ActionCostType.TwoAP ? 2 : 1;
            int baseFATCost = data.ActionCostType == ActionCostType.OneAPOneFat ? 1 : 0;

            character.ActionPoints.Available += baseAPCost + data.APBoost;
            character.ActionPoints.ActionsTakenThisRound -= 1;
            character.Fatigue.Value += baseFATCost + data.FATBoost;

            if (character is Csla.Core.ISavable savable)
                await savable.SaveAsync();
        }

        // Refund AP/FAT if defender already confirmed an active defense (costs were charged on confirm)
        if (!isTargetingAttacker && currentTargetingInteraction.DefenderConfirmed &&
            currentTargetingInteraction.DefenderData != null && character != null)
        {
            var data = currentTargetingInteraction.DefenderData;
            bool isActiveDefense = data.DefenseType == DefenseType.Dodge ||
                                   data.DefenseType == DefenseType.ShieldBlock ||
                                   (data.DefenseType == DefenseType.Parry && !data.IsInParryMode);
            if (isActiveDefense)
            {
                int baseAPCost = data.DefenseCostType == ActionCostType.TwoAP ? 2 : 1;
                int baseFATCost = data.DefenseCostType == ActionCostType.OneAPOneFat ? 1 : 0;

                character.ActionPoints.Available += baseAPCost + data.APBoost;
                character.ActionPoints.ActionsTakenThisRound -= 1;
                character.Fatigue.Value += baseFATCost + data.FATBoost;

                if (character is Csla.Core.ISavable savable)
                    await savable.SaveAsync();
            }
        }

        await TargetingManager.CancelAsync(currentTargetingInteraction.InteractionId, "Cancelled by attacker");
        showTargetingModal = false;
        currentTargetingInteraction = null;
    }

    private void CloseTargetingModal()
    {
        showTargetingModal = false;
        currentTargetingInteraction = null;
        // Remove from pending if it's resolved
        if (currentTargetingInteraction != null)
        {
            pendingTargetingRequests.RemoveAll(r => r.InteractionId == currentTargetingInteraction.InteractionId);
        }
    }

    private async Task AcceptTargetingDamage()
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.AcceptDamageAsync(currentTargetingInteraction.InteractionId);

        // Apply damage to character if we're the defender
        if (!isTargetingAttacker && character != null && currentTargetingInteraction.Resolution != null)
        {
            var resolution = currentTargetingInteraction.Resolution;
            if (resolution.IsHit)
            {
                character.Fatigue.Value -= resolution.FATDamage;
                character.Vitality.Value -= resolution.VITDamage;

                // Apply weapon on-hit effects if the weapon template is known
                var attackerData = currentTargetingInteraction.AttackerData;
                if (attackerData.WeaponTemplateId > 0)
                {
                    await ApplyWeaponOnHitEffectsAsync(attackerData, resolution, character);
                }

                // Save character
                if (character is Csla.Core.ISavable savable)
                {
                    await savable.SaveAsync();
                }

                AddLogEntry($"Took {resolution.FATDamage} FAT and {resolution.VITDamage} VIT damage from {currentTargetingInteraction.AttackerName}", ActivityCategory.Combat);
            }
        }

        StateHasChanged();
    }

    private async Task ApplyWeaponOnHitEffectsAsync(
        GameMechanics.Messaging.TargetingAttackerData attackerData,
        GameMechanics.Messaging.TargetingResolutionData resolution,
        GameMechanics.CharacterEdit target)
    {
        try
        {
            // Armor was penetrated if any damage got through
            bool armorPenetrated = resolution.FATDamage > 0 || resolution.VITDamage > 0;

            AttackEffectContext context;

            if (!string.IsNullOrEmpty(attackerData.AmmoSpecialEffect))
            {
                // Ranged attack with special ammo  use RangedAttackEffectContext so ammo effects are collected
                var weaponTemplate = attackerData.WeaponTemplateId > 0
                    ? await ItemTemplateDal.GetTemplateAsync(attackerData.WeaponTemplateId)
                    : null;

                var ammoProperties = new GameMechanics.Combat.AmmunitionProperties
                {
                    SpecialEffect = attackerData.AmmoSpecialEffect,
                    DamageModifier = attackerData.AmmoDamageModifier
                };

                context = new GameMechanics.Combat.Effects.RangedAttackEffectContext
                {
                    Attacker = null,
                    Target = target,
                    WeaponTemplate = weaponTemplate,
                    AmmoProperties = ammoProperties,
                    AttackSV = resolution.SuccessValue,
                    HitLocation = resolution.HitLocation,
                    IsCriticalHit = AttackEffectContext.IsCritical(resolution.SuccessValue),
                    BaseDamageType = attackerData.DamageType,
                    ArmorWasPenetrated = armorPenetrated,
                    ArmorDamageClass = null,
                    ShieldDamageClass = null,
                    TargetDamageClass = 0
                };
            }
            else
            {
                // Melee or ranged with no special ammo  weapon template effects only
                if (attackerData.WeaponTemplateId <= 0) return;

                var weaponTemplate = await ItemTemplateDal.GetTemplateAsync(attackerData.WeaponTemplateId);
                if (weaponTemplate?.Effects == null || !weaponTemplate.Effects.Any(e => e.IsActive))
                    return;

                context = new AttackEffectContext
                {
                    Attacker = null,
                    Target = target,
                    WeaponTemplate = weaponTemplate,
                    AttackSV = resolution.SuccessValue,
                    HitLocation = resolution.HitLocation,
                    IsCriticalHit = AttackEffectContext.IsCritical(resolution.SuccessValue),
                    BaseDamageType = attackerData.DamageType,
                    ArmorWasPenetrated = armorPenetrated,
                    ArmorDamageClass = null,
                    ShieldDamageClass = null,
                    TargetDamageClass = 0
                };
            }

            var effects = await AttackEffectService.CollectAttackEffectsAsync(context);
            if (effects.HasEffects)
            {
                await AttackEffectService.ApplyEffectsAsync(effects, target, attacker: null!);

                if (effects.TargetEffects.Any())
                {
                    var names = string.Join(", ", effects.TargetEffects.Select(e => e.Grant.EffectName));
                    AddLogEntry($"On-hit effects applied: {names}", ActivityCategory.Combat);
                }
            }
        }
        catch (Exception ex)
        {
            // Non-fatal  log but don't block damage application
            AddLogEntry($"Warning: could not apply weapon on-hit effects: {ex.Message}", ActivityCategory.Combat);
        }
    }

    // ================================
    // Targeting Helper Methods
    // ================================

    private int GetTargetingMaxAPBoost()
    {
        if (character == null) return 0;
        // Reserve 1 AP for the action cost
        return Math.Max(0, character.ActionPoints.Available - 1);
    }

    private int GetTargetingMaxFATBoost()
    {
        if (character == null) return 0;
        // Reserve 1 FAT for the action cost
        return Math.Max(0, character.Fatigue.Value - 1);
    }

    private int GetDefenderDodgeAS()
    {
        if (character == null) return 0;
        var dodgeSkill = character.Skills.FirstOrDefault(s =>
            s.Name.Equals("Dodge", StringComparison.OrdinalIgnoreCase));
        return dodgeSkill?.AbilityScore ?? 0;
    }

    private int GetDefenderParryAS()
    {
        if (character == null) return 0;
        // Find weapon skill AS for parry
        var equippedItems = character.GetEquippedItems();
        var mainHand = equippedItems?.FirstOrDefault(i => i.Item.EquippedSlot == Threa.Dal.Dto.EquipmentSlot.MainHand);
        if (mainHand?.Template?.RelatedSkill != null)
        {
            var skill = character.Skills.FirstOrDefault(s =>
                s.Id.Equals(mainHand.Template.RelatedSkill, StringComparison.OrdinalIgnoreCase));
            return skill?.AbilityScore ?? 0;
        }
        return 0;
    }

    private bool GetDefenderIsInParryMode()
    {
        if (character == null) return false;
        return GameMechanics.Effects.Behaviors.CombatStanceBehavior.IsInParryMode(character);
    }

    private bool GetDefenderCanActiveDefense()
    {
        if (character == null) return false;
        return !character.IsPassedOut &&
               ((character.ActionPoints.Available >= 1 && character.Fatigue.Value >= 1) ||
                character.ActionPoints.Available >= 2);
    }

    private bool GetDefenderCanParry()
    {
        if (character == null) return false;
        return GetDefenderCanActiveDefense() || GetDefenderIsInParryMode();
    }

    /// <summary>
    /// Handles the targeting initiation callback from TabCombat.
    /// </summary>
    private async Task HandleInitiateTargeting((TargetingActionType ActionType, int TargetId, string TargetName, TargetingAttackerData AttackerData, List<MeleeWeaponInfo>? AvailableWeapons) args)
    {
        targetingAttackerWeapons = args.AvailableWeapons;
        await InitiateTargeting(args.ActionType, args.TargetId, args.TargetName, args.AttackerData);
    }

    /// <summary>
    /// Initiates targeting from TabCombat. Called when player selects a target for attack.
    /// </summary>
    public async Task InitiateTargeting(TargetingActionType actionType, int targetCharacterId, string targetCharacterName, TargetingAttackerData attackerData)
    {
        if (character == null || table == null) return;

        var (interaction, queuePosition) = await TargetingManager.StartInteractionAsync(
            table.Id,
            character.Id,
            character.Name,
            targetCharacterId,
            targetCharacterName,
            attackerData);

        currentTargetingInteraction = interaction;
        showTargetingModal = true;
        isTargetingAttacker = true;

        if (queuePosition > 0)
        {
            AddLogEntry($"Attack queued. {targetCharacterName} has {queuePosition} other incoming attacks.", ActivityCategory.Combat);
        }

        StateHasChanged();
    }

    /// <summary>
    /// Gets available targets at the current table (excluding self).
    /// Filters out hidden NPCs (only visible NPCs appear as targets).
    /// </summary>
    public List<TargetSelectionModal.TargetInfo> GetAvailableTargets()
    {
        if (table == null || character == null)
            return new List<TargetSelectionModal.TargetInfo>();

        return tableCharacters
            .Where(c => c.CharacterId != character.Id)
            .Where(c => !c.IsNpc || c.VisibleToPlayers) // PCs always visible, NPCs only if revealed
            .Select(c => new TargetSelectionModal.TargetInfo
            {
                CharacterId = c.CharacterId,
                CharacterName = c.CharacterName,
                PlayerName = c.IsNpc ? null : "Player",
                IsNPC = c.IsNpc,
                Disposition = c.Disposition
            })
            .ToList();
    }

    /// <summary>
    /// Opens modal to change character image.
    /// </summary>
    private async Task OpenChangeImageModal()
    {
        if (character == null) return;

        var result = await DialogService.OpenAsync<ChangeImageModal>(
            "Change Character Image",
            new Dictionary<string, object>
            {
                { "CurrentImageUrl", character.ImageUrl }
            },
            new DialogOptions
            {
                Width = "500px",
                Resizable = true,
                Draggable = true
            }
        );

        if (result is string newImageUrl && !string.IsNullOrEmpty(newImageUrl))
        {
            character.ImageUrl = newImageUrl;
            try
            {
                character = await characterPortal.UpdateAsync(character);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to save character image: {ex.Message}";
            }
        }
    }

    // ================================
    // Local Time Management (No Table)
    // ================================

    /// <summary>
    /// Enters combat mode for local (no-table) play.
    /// </summary>
    private void LocalEnterCombat()
    {
        if (table != null) return; // Only for no-table scenarios

        localIsInCombat = true;
        localCurrentRound = 1;
        AddLogEntry("Entered combat mode", ActivityCategory.Combat);
        StateHasChanged();
    }

    /// <summary>
    /// Exits combat mode for local (no-table) play.
    /// </summary>
    private void LocalExitCombat()
    {
        if (table != null) return; // Only for no-table scenarios

        localIsInCombat = false;
        AddLogEntry("Exited combat mode", ActivityCategory.Combat);
        StateHasChanged();
    }

    /// <summary>
    /// Advances rounds for local (no-table) play.
    /// Per TIME_SYSTEM.md: Each round is 3 seconds of game time.
    /// Processes AP recovery, pending damage/healing, effects, and saves the character.
    /// </summary>
    private async Task LocalAdvanceRounds(int count)
    {
        if (table != null || !localIsInCombat || count <= 0 || character == null) return;

        localCurrentRound += count;
        localTimeSeconds += count * 3; // 3 seconds per round per design spec

        // Process game mechanics for each round (AP recovery, pending pools, effects)
        for (int i = 0; i < count; i++)
        {
            character.EndOfRound(effectPortal);
        }

        AddLogEntry($"Advanced {count} round(s) (Round {localCurrentRound})", ActivityCategory.Time);
        await SaveCharacterAsync();
        StateHasChanged();
    }

    /// <summary>
    /// Advances narrative time for local (no-table) play.
    /// Processes AP recovery, healing/damage pools, effect expiration, and saves the character.
    /// </summary>
    private async Task LocalAdvanceTime(int seconds)
    {
        if (table != null || localIsInCombat || seconds <= 0 || character == null) return;

        localTimeSeconds += seconds;

        // Map seconds to TimeEventType + count for ProcessTimeSkip
        var (skipUnit, skipCount) = seconds switch
        {
            60 => (GameMechanics.Time.TimeEventType.EndOfMinute, 1),
            600 => (GameMechanics.Time.TimeEventType.EndOfTurn, 1),
            3600 => (GameMechanics.Time.TimeEventType.EndOfHour, 1),
            86400 => (GameMechanics.Time.TimeEventType.EndOfDay, 1),
            604800 => (GameMechanics.Time.TimeEventType.EndOfWeek, 1),
            _ => (GameMechanics.Time.TimeEventType.EndOfMinute, Math.Max(1, seconds / 60))
        };

        // Process game mechanics (AP recovery, VIT/FAT recovery, effect expiration)
        character.ProcessTimeSkip(skipUnit, skipCount, effectPortal);

        string timeDesc = seconds switch
        {
            60 => "1 minute",
            600 => "10 minutes",
            3600 => "1 hour",
            86400 => "1 day",
            604800 => "1 week",
            _ => $"{seconds} seconds"
        };

        AddLogEntry($"Advanced time by {timeDesc}", ActivityCategory.Time);
        await SaveCharacterAsync();
        StateHasChanged();
    }
}
