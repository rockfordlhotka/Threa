@page "/play"
@page "/play/{TableId:guid}"

@rendermode InteractiveServer

@attribute [Authorize]

@implements IDisposable

@using GameMechanics.Messaging
@using Threa.Services
@using Threa.Client.Components.Shared

@* Suppress warnings for using legacy round-based properties for UI display *@
#pragma warning disable CS0618

@inject Csla.Blazor.State.StateManager StateManager
@inject RenderModeProvider RenderModeProvider
@inject NavigationManager NavigationManager
@inject ApplicationContext applicationContext
@inject IDataPortal<GameMechanics.CharacterEdit> characterPortal
@inject IDataPortal<GameMechanics.GamePlay.TableEdit> tablePortal
@inject IDataPortal<GameMechanics.Player.CharacterList> characterListPortal
@inject IDataPortal<GameMechanics.GamePlay.TableCharacterDetacher> detacherPortal
@inject IDataPortal<GameMechanics.GamePlay.TableCharacterAttacher> attacherPortal
@inject IDataPortal<GameMechanics.GamePlay.TableList> tableListPortal
@inject IActivityLogService ActivityLog
@inject ITimeEventSubscriber TimeEventSubscriber
@inject ITimeEventPublisher TimeEventPublisher
@inject IChildDataPortal<GameMechanics.EffectRecord> effectPortal
@inject IJSRuntime JS
@inject ICharacterItemDal CharacterItemDal

@using GameMechanics.Time
@using Threa.Dal

<PageTitle>Threa - Play</PageTitle>

@if (errorMessage != null)
{
    <div class="alert alert-danger alert-dismissible fade show" role="alert">
        <i class="bi bi-exclamation-triangle-fill me-2"></i>
        <strong>Error:</strong> @errorMessage
        <button type="button" class="btn-close" @onclick="() => errorMessage = null" aria-label="Close"></button>
    </div>
}

@if (table == null && TableId != Guid.Empty)
{
    <div>Loading table...</div>
}
else if (character == null)
{
    <h3>Select a Character to Play</h3>

    @if (availableCharacters == null)
    {
        <p>Loading characters...</p>
    }
    else if (!availableCharacters.Any())
    {
        <div class="alert alert-info">
            <p>You don't have any activated characters to play.</p>
            <p><a href="/player/characters">Create and activate a character</a> to start playing.</p>
        </div>
    }
    else
    {
        <div class="list-group" style="max-width: 500px;">
            @foreach (var charInfo in availableCharacters)
            {
                <div class="list-group-item d-flex justify-content-between align-items-center">
                    <div class="d-flex align-items-center gap-2 flex-grow-1" 
                         style="cursor: pointer;" 
                         @onclick="() => SelectCharacterAsync(charInfo.Id)">
                        <div>
                            <strong>@charInfo.Name</strong>
                            <br />
                            <small class="text-muted">@charInfo.Species</small>
                            @if (charInfo.IsAttachedToTable)
                            {
                                <br />
                                <small class="text-info"><i class="bi bi-table"></i> Table: @charInfo.TableName</small>
                            }
                        </div>
                    </div>
                    <div class="d-flex gap-2">
                        @if (charInfo.IsAttachedToTable)
                        {
                            <button class="btn btn-sm btn-outline-warning" 
                                    title="Detach from table"
                                    @onclick="() => ShowDetachConfirmation(charInfo)"
                                    @onclick:stopPropagation="true">
                                <i class="bi bi-box-arrow-right"></i>
                            </button>
                        }
                        <button class="btn btn-sm btn-success" 
                                @onclick="() => SelectCharacterAsync(charInfo.Id)"
                                @onclick:stopPropagation="true">
                            Play
                        </button>
                    </div>
                </div>
            }
        </div>
    }
}

@* Detach Confirmation Dialog *@
@if (showDetachConfirmation && characterToDetach != null)
{
    <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-warning">
                    <h5 class="modal-title">Confirm Detach from Table</h5>
                    <button type="button" class="btn-close" @onclick="CancelDetach"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to detach <strong>@characterToDetach.Name</strong> from table <strong>@characterToDetach.TableName</strong>?</p>
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i>
                        <strong>Warning:</strong> This will remove your character from the active game session. 
                        You will need to rejoin the table to continue playing in that session.
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CancelDetach">Cancel</button>
                    <button type="button" class="btn btn-warning" @onclick="ConfirmDetach" disabled="@isDetaching">
                        @if (isDetaching)
                        {
                            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                            <span>Detaching...</span>
                        }
                        else
                        {
                            <span>Detach Character</span>
                        }
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@* Table Selection Dialog *@
@if (showTableSelection && characterToAttach != null)
{
    <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-primary text-white">
                    <h5 class="modal-title">Join a Table</h5>
                    <button type="button" class="btn-close btn-close-white" @onclick="CancelTableSelection"></button>
                </div>
                <div class="modal-body">
                    <p>Select a table for <strong>@characterToAttach.Name</strong> to join:</p>
                    
                    @if (availableTables == null)
                    {
                        <p>Loading tables...</p>
                    }
                    else if (!availableTables.Any())
                    {
                        <div class="alert alert-info">
                            <p>No active tables available.</p>
                            <p>You can still play without joining a table, or ask a Game Master to create one.</p>
                        </div>
                    }
                    else
                    {
                        <div class="list-group mb-3">
                            @foreach (var tableInfo in availableTables)
                            {
                                <button type="button" 
                                        class="list-group-item list-group-item-action d-flex justify-content-between align-items-center @(selectedTableId == tableInfo.Id ? "active" : "")"
                                        @onclick="() => selectedTableId = tableInfo.Id">
                                    <div>
                                        <strong>@tableInfo.Name</strong>
                                        <br />
                                        <small>@tableInfo.StatusDisplay - Round @tableInfo.CurrentRound</small>
                                    </div>
                                    @if (selectedTableId == tableInfo.Id)
                                    {
                                        <i class="bi bi-check-circle-fill"></i>
                                    }
                                </button>
                            }
                        </div>
                    }
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CancelTableSelection">Cancel</button>
                    <button type="button" class="btn btn-outline-primary" @onclick="PlayWithoutTable">
                        Play Without Table
                    </button>
                    @if (availableTables != null && availableTables.Any())
                    {
                        <button type="button" class="btn btn-primary" 
                                @onclick="ConfirmTableSelection" 
                                disabled="@(selectedTableId == Guid.Empty || isAttaching)">
                            @if (isAttaching)
                            {
                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                <span>Joining...</span>
                            }
                            else
                            {
                                <span>Join Table</span>
                            }
                        </button>
                    }
                </div>
            </div>
        </div>
    </div>
}

@if (character != null)
{
    <!-- Character Status Header (themed) -->
    <div class="character-header p-3 rounded mb-3">
        <div class="d-flex flex-column gap-3">
            <!-- Top row: Character identity + Resource pools + Table info -->
            <div class="d-flex flex-wrap justify-content-between align-items-start gap-3">
                <!-- Character Identity -->
                <div class="d-flex align-items-center gap-3">
                    @if (!string.IsNullOrEmpty(character.ImageUrl))
                    {
                        <img src="@character.ImageUrl" alt="@character.Name"
                             class="rounded" style="width: 48px; height: 48px; object-fit: cover;" />
                    }
                    else
                    {
                        <div class="rounded d-flex align-items-center justify-content-center"
                             style="width: 48px; height: 48px; background: var(--color-bg-tertiary); font-size: 1.5rem;">
                            @(character.Name.FirstOrDefault())
                        </div>
                    }
                    <div>
                        <h4 class="mb-0" style="font-family: var(--font-display);">@character.Name</h4>
                        <small style="color: var(--color-text-muted);">@character.Species</small>
                    </div>
                </div>

                <!-- Resource Pools -->
                <div class="d-flex gap-3 flex-wrap justify-content-center">
                    <!-- FAT Pool -->
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 100px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">FAT</small>
                        <div class="fw-bold fs-5" style="color: var(--color-fatigue);">
                            @character.Fatigue.Value<span style="color: var(--color-text-muted);">/@character.Fatigue.BaseValue</span>
                        </div>
                        <PendingPoolBar CurrentValue="@character.Fatigue.Value"
                                        MaxValue="@character.Fatigue.BaseValue"
                                        PendingDamage="@character.Fatigue.PendingDamage"
                                        PendingHealing="@character.Fatigue.PendingHealing"
                                        Height="8px" />
                        @if (character.Fatigue.PendingDamage > 0 || character.Fatigue.PendingHealing > 0)
                        {
                            <small class="d-block mt-1" style="font-size: 0.7rem;">
                                @if (character.Fatigue.PendingDamage > 0)
                                {
                                    <span style="color: var(--color-accent-red);">-@character.Fatigue.PendingDamage</span>
                                }
                                @if (character.Fatigue.PendingHealing > 0)
                                {
                                    <span style="color: var(--color-accent-green);" class="@(character.Fatigue.PendingDamage > 0 ? "ms-1" : "")">+@character.Fatigue.PendingHealing</span>
                                }
                            </small>
                        }
                    </div>

                    <!-- VIT Pool -->
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 100px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">VIT</small>
                        <div class="fw-bold fs-5" style="color: var(--color-vitality);">
                            @character.Vitality.Value<span style="color: var(--color-text-muted);">/@character.Vitality.BaseValue</span>
                        </div>
                        <PendingPoolBar CurrentValue="@character.Vitality.Value"
                                        MaxValue="@character.Vitality.BaseValue"
                                        PendingDamage="@character.Vitality.PendingDamage"
                                        PendingHealing="@character.Vitality.PendingHealing"
                                        Height="8px" />
                        @if (character.Vitality.PendingDamage > 0 || character.Vitality.PendingHealing > 0)
                        {
                            <small class="d-block mt-1" style="font-size: 0.7rem;">
                                @if (character.Vitality.PendingDamage > 0)
                                {
                                    <span style="color: var(--color-accent-red);">-@character.Vitality.PendingDamage</span>
                                }
                                @if (character.Vitality.PendingHealing > 0)
                                {
                                    <span style="color: var(--color-accent-green);" class="@(character.Vitality.PendingDamage > 0 ? "ms-1" : "")">+@character.Vitality.PendingHealing</span>
                                }
                            </small>
                        }
                    </div>

                    <!-- AP Pips -->
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 90px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">AP</small>
                        <div class="d-flex justify-content-center gap-1 my-1">
                            @for (int i = 0; i < character.ActionPoints.Max; i++)
                            {
                                var isAvailable = i < character.ActionPoints.Available;
                                <div class="ap-pip @(isAvailable ? "available" : "spent")">
                                    @if (isAvailable)
                                    {
                                        <i class="bi bi-lightning-fill" style="font-size: 0.6rem;"></i>
                                    }
                                </div>
                            }
                        </div>
                        <small style="color: var(--color-text-muted);">@character.ActionPoints.Available / @character.ActionPoints.Max</small>
                    </div>

                    <!-- Wounds Summary -->
                    @{
                        var woundCount = GetWoundCount();
                    }
                    <div class="resource-pool text-center p-2 rounded" style="min-width: 80px; background: var(--color-bg-tertiary);">
                        <small class="d-block" style="font-family: var(--font-display); letter-spacing: 0.1em;">WOUNDS</small>
                        <div class="fw-bold fs-5" style="color: @(woundCount > 0 ? "var(--color-accent-red)" : "var(--color-text-muted)");">
                            <i class="bi bi-bandaid"></i> @woundCount
                        </div>
                        @if (woundCount > 0)
                        {
                            <small style="color: var(--color-accent-red);">@(woundCount * -2) AS</small>
                        }
                    </div>
                </div>

                <!-- Table Info -->
                @if (table != null)
                {
                    <div class="text-end p-2 rounded" style="background: var(--color-bg-tertiary);">
                        <div style="font-family: var(--font-display); font-size: 0.85rem;">@table.Name</div>
                        <small style="color: var(--color-text-muted);">@GameTimeFormatter.FormatCompact(table.CurrentTimeSeconds)</small>
                        <div class="mt-1">
                            @if (table.IsInCombat)
                            {
                                <span class="badge bg-danger">In Rounds</span>
                            }
                            <span class="badge bg-info ms-1">Round @table.CurrentRound</span>
                        </div>
                    </div>
                }
            </div>

            <!-- Active Effects Row -->
            @if (character.Effects.Any())
            {
                <div class="d-flex flex-wrap gap-2 align-items-center pt-2" style="border-top: 1px solid var(--color-card-border);">
                    <small class="me-2" style="font-family: var(--font-display); letter-spacing: 0.05em;">EFFECTS:</small>
                    @foreach (var effect in character.Effects)
                    {
                        <EffectIcon EffectType="@effect.EffectType.ToString()"
                                    EffectName="@effect.Name"
                                    Tooltip="@GetEffectTooltip(effect)"
                                    Stacks="@effect.CurrentStacks"
                                    Color="@GetEffectColor(effect)" />
                    }
                </div>
            }
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-buttons">
        @foreach (var tabName in tabNames)
        {
            <button class="tab-link @(activeTab == tabName ? "active" : "")"
                    @onclick="() => SelectTab(tabName)">
                @tabName
            </button>
        }
    </div>

    <!-- Tab Content -->
    <div class="tab-content">
        @if (activeTab == "Status")
        {
            <TabStatus Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
        else if (activeTab == "Combat")
        {
            <TabCombat Character="character" Table="table" />
        }
        else if (activeTab == "Skills")
        {
            <TabPlaySkills Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
        else if (activeTab == "Magic")
        {
            <TabPlayMagic Character="character" Table="table" />
        }
        else if (activeTab == "Defense")
        {
            <TabDefense Character="character" Table="table" />
        }
        else if (activeTab == "Inventory")
        {
            <TabPlayInventory Character="character" Table="table" OnCharacterChanged="SaveCharacterAsync" />
        }
    </div>

    <!-- Activity Log -->
    <div class="activity-log mt-3" style="background-color: #f8f9fa; padding: 1rem; border-radius: 8px; max-height: 200px; overflow-y: auto;">
        <h6>Activity Log</h6>
        @if (activityLog.Count == 0)
        {
            <p class="text-muted">No recent activity.</p>
        }
        else
        {
            @foreach (var entry in activityLog.TakeLast(10).Reverse())
            {
                <div class="small @GetActivityClass(entry.Category)">
                    <span class="text-muted">[@entry.Timestamp.ToString("HH:mm:ss")]</span>
                    <strong>@entry.Source:</strong> @entry.Message
                </div>
            }
        }
    </div>
}

@code {
#pragma warning disable CS0618 // Using legacy round-based properties for UI display

[Parameter]
public Guid TableId { get; set; }

private static readonly string[] tabNames = new[] { "Status", "Combat", "Skills", "Magic", "Defense", "Inventory" };
private string activeTab = tabNames[0];

private GameMechanics.CharacterEdit? character;
private GameMechanics.GamePlay.TableEdit? table;
private IEnumerable<GameMechanics.Player.CharacterInfo>? availableCharacters;
private IEnumerable<GameMechanics.GamePlay.TableInfo>? availableTables;
private string? errorMessage;
private int currentPlayerId;
private List<ActivityLogEntry> activityLog = new();
private IDisposable? activityLogSubscription;
private bool timeEventSubscribed;
private bool _disposed;

// Semaphore to prevent concurrent processing of time skip messages
private readonly SemaphoreSlim _timeSkipSemaphore = new(1, 1);

// Detach confirmation state
private bool showDetachConfirmation;
private bool isDetaching;
private GameMechanics.Player.CharacterInfo? characterToDetach;

// Table selection state
private bool showTableSelection;
private bool isAttaching;
private GameMechanics.Player.CharacterInfo? characterToAttach;
private Guid selectedTableId;

private record ActivityLogEntry(DateTime Timestamp, string Message, string Source, ActivityCategory Category);

protected override async Task OnInitializedAsync()
{
    await StateManager.InitializeAsync();

    if (RenderModeProvider.GetRenderMode(this).IsInteractive())
    {
        // Get the current player ID from claims
        currentPlayerId = int.Parse(applicationContext.Principal.Claims
            .Where(_ => _.Type == System.Security.Claims.ClaimTypes.NameIdentifier).First().Value);

        await LoadCharactersAsync();

        // If TableId is provided, load the table
        if (TableId != Guid.Empty)
        {
            try
            {
                table = await tablePortal.FetchAsync(TableId);
                SubscribeToActivityLog(TableId);
                await SubscribeToTimeEvents(TableId);

                // Apply the table's theme
                if (table != null)
                {
                    await JS.InvokeVoidAsync("threaTheme.apply", table.Theme ?? "fantasy");
                }
            }
            catch (Exception ex)
            {
                errorMessage = $"Failed to load table: {ex.Message}";
            }
        }
    }
}

protected override async Task OnAfterRenderAsync(bool firstRender)
{
    // Ensure theme is applied after render, especially important when rejoining tables
    if (firstRender && table != null)
    {
        try
        {
            await JS.InvokeVoidAsync("threaTheme.apply", table.Theme ?? "fantasy");
        }
        catch
        {
            // JS might not be ready yet, ignore
        }
    }
}

private async Task LoadCharactersAsync()
{
    // Load available characters for selection
    var charList = await characterListPortal.FetchAsync(currentPlayerId);
    availableCharacters = charList.Where(c => c.IsPlayable);
}

private async Task LoadTablesAsync()
{
    try
    {
        var tableList = await tableListPortal.FetchAsync();
        // Show only active tables (not ended)
        availableTables = tableList.Where(t => t.Status != Threa.Dal.Dto.TableStatus.Ended);
    }
    catch (Exception ex)
    {
        errorMessage = $"Failed to load tables: {ex.Message}";
    }
}

private async Task LoadEquippedItemsAsync()
{
    if (character == null) return;
    var equippedItems = await CharacterItemDal.GetEquippedItemsWithTemplatesAsync(character.Id);
    character.SetEquippedItems(equippedItems);
}

private async Task SelectCharacterAsync(int characterId)
{
    try
    {
        errorMessage = null;
        
        // Find the character info to check if attached to table
        var charInfo = availableCharacters?.FirstOrDefault(c => c.Id == characterId);
        
        if (charInfo != null && !charInfo.IsAttachedToTable)
        {
            // Character not attached to a table - show table selection dialog
            characterToAttach = charInfo;
            selectedTableId = Guid.Empty;
            await LoadTablesAsync();
            showTableSelection = true;
        }
        else
        {
            // Character is attached to a table or we couldn't find info - just load and play
            character = await characterPortal.FetchAsync(characterId);
            await LoadEquippedItemsAsync();

            // If attached to a table, load the table too
            if (charInfo?.TableId != null)
            {
                try
                {
                    table = await tablePortal.FetchAsync(charInfo.TableId.Value);
                    SubscribeToActivityLog(charInfo.TableId.Value);
                    await SubscribeToTimeEvents(charInfo.TableId.Value);

                    // Apply the table's theme
                    if (table != null)
                    {
                        await JS.InvokeVoidAsync("threaTheme.apply", table.Theme ?? "fantasy");
                    }
                }
                catch
                {
                    // Table might not exist anymore - continue without it
                }
            }

            AddLogEntry($"Playing as {character.Name}", ActivityCategory.Player);

            // If joining an in-progress table, announce the current game time
            if (table != null && table.Status == Threa.Dal.Dto.TableStatus.Active)
            {
                var timeDisplay = GameTimeFormatter.FormatFull(table.CurrentTimeSeconds);
                AddLogEntry($"The in-game time is: {timeDisplay}", ActivityCategory.Time);
            }
        }
    }
    catch (Exception ex)
    {
        errorMessage = $"Failed to load character: {ex.Message}";
    }
}

    private void SelectTab(string tabName)
    {
        activeTab = tabName;
    }

    private void AddLogEntry(string message, ActivityCategory category = ActivityCategory.General)
    {
        // Only publish if we have a table context
        if (table != null)
        {
            ActivityLog.Publish(table.Id, message, character?.Name ?? "Player", category);
        }
        else
        {
            // Local-only for when there's no table
            activityLog.Add(new ActivityLogEntry(DateTime.Now, message, character?.Name ?? "Player", category));
            if (activityLog.Count > 100)
                activityLog.RemoveAt(0);
        }
    }

    private void SubscribeToActivityLog(Guid tableId)
    {
        // Unsubscribe from any previous subscription
        activityLogSubscription?.Dispose();

        activityLogSubscription = ActivityLog.Subscribe(tableId, msg =>
        {
            InvokeAsync(() =>
            {
                activityLog.Add(new ActivityLogEntry(msg.Timestamp, msg.Message, msg.Source, msg.Category));
                if (activityLog.Count > 100) activityLog.RemoveAt(0);
                StateHasChanged();
            });
        });
    }

    private async Task SubscribeToTimeEvents(Guid tableId)
    {
        if (timeEventSubscribed)
        {
            return;
        }

        // Connect and subscribe to time events
        await TimeEventSubscriber.ConnectAsync();
        await TimeEventSubscriber.SubscribeAsync();

        // Connect publisher to send character update notifications
        await TimeEventPublisher.ConnectAsync();

        TimeEventSubscriber.TimeEventReceived += OnTimeEventReceived;
        TimeEventSubscriber.TimeSkipReceived += OnTimeSkipReceived;
        TimeEventSubscriber.CombatStateReceived += OnCombatStateReceived;
        TimeEventSubscriber.CharacterUpdateReceived += OnCharacterUpdateReceived;
        TimeEventSubscriber.TableUpdateReceived += OnTableUpdateReceived;
        timeEventSubscribed = true;
    }

    private void OnTimeEventReceived(object? sender, TimeEventMessage e)
    {
        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.CampaignId != table.Id.ToString()) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // ALWAYS refresh table state first to show updated time/rounds
                if (table != null)
                {
                    table = await tablePortal.FetchAsync(table.Id);
                }

                // Process end-of-round effects on the character
                if (character != null && e.EventType == GameMechanics.Time.TimeEventType.EndOfRound)
                {
                    // Reload character from database to get clean state
                    // This prevents CSLA dirty state conflicts when character has unsaved changes
                    int characterId = character.Id;
                    character = await characterPortal.FetchAsync(characterId);
                    await LoadEquippedItemsAsync();

                    // Sync character's game time with table
                    if (table != null && (character.CurrentGameTimeSeconds == 0 || character.CurrentGameTimeSeconds < table.CurrentTimeSeconds))
                    {
                        character.CurrentGameTimeSeconds = table.CurrentTimeSeconds;
                    }

                    for (int i = 0; i < e.Count; i++)
                    {
                        character.EndOfRound(effectPortal);
                    }

                    // Save the updated character
                    await characterPortal.UpdateAsync(character);

                    // Notify other clients (GM page) that this character was updated
                    await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
                    {
                        CharacterId = character.Id,
                        CampaignId = table?.Id.ToString() ?? "",
                        UpdateType = CharacterUpdateType.Healing,
                        Description = "End of round effects processed"
                    });

                    // Process any concentration results after effects tick/expire
                    await ProcessConcentrationResult(character);
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing time event: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnTimeSkipReceived(object? sender, TimeSkipMessage e)
    {
        _ = InvokeAsync(async () =>
        {
            // Ignore events if component is disposed or not our table
            if (_disposed || table == null || e.CampaignId != table.Id.ToString())
            {
                return;
            }

            // Check if another time skip is currently being processed - skip to prevent race conditions
            if (_timeSkipSemaphore.CurrentCount == 0)
            {
                return;
            }

            // Wait for semaphore to ensure only one time skip is processed at a time
            await _timeSkipSemaphore.WaitAsync();
            try
            {
                // ALWAYS refresh table state first to show updated time
                if (table != null)
                {
                    table = await tablePortal.FetchAsync(table.Id);
                }

                // Process time skip effects on the character
                if (character != null)
                {
                    // Reload character from database to get clean state
                    // This prevents CSLA dirty state conflicts when character has unsaved changes
                    int characterId = character.Id;
                    character = await characterPortal.FetchAsync(characterId);
                    await LoadEquippedItemsAsync();

                    // Safety check: If pending values are corrupted (> 10000), reset them to prevent further corruption
                    // This can happen from race conditions when multiple time skips were processed concurrently
                    bool corrupted = false;
                    if (character.Fatigue.PendingDamage > 10000 || character.Fatigue.PendingHealing > 10000)
                    {
                        character.Fatigue.PendingDamage = 0;
                        character.Fatigue.PendingHealing = 0;
                        corrupted = true;
                    }
                    if (character.Vitality.PendingDamage > 10000 || character.Vitality.PendingHealing > 10000)
                    {
                        character.Vitality.PendingDamage = 0;
                        character.Vitality.PendingHealing = 0;
                        corrupted = true;
                    }

                    // If corruption was detected, save the reset state immediately and skip further processing
                    if (corrupted)
                    {
                        await characterPortal.UpdateAsync(character);
                        StateHasChanged();
                        return;
                    }

                    // Sync character's game time with table
                    if (table != null && (character.CurrentGameTimeSeconds == 0 || character.CurrentGameTimeSeconds < table.CurrentTimeSeconds))
                    {
                        character.CurrentGameTimeSeconds = table.CurrentTimeSeconds;
                    }

                    // Use the new ProcessTimeSkip method which handles:
                    // - Hourly VIT recovery (1 per hour if VIT > 0)
                    // - VIT-level-dependent FAT recovery
                    // - Epoch-based effect expiration (O(1) performance!)
                    // - Pending pool flow
                    character.ProcessTimeSkip(e.SkipUnit, e.Count, effectPortal);

                    // Save the updated character
                    await characterPortal.UpdateAsync(character);

                    // Notify other clients (GM page) that this character was updated
                    await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
                    {
                        CharacterId = character.Id,
                        CampaignId = table?.Id.ToString() ?? "",
                        UpdateType = CharacterUpdateType.Healing,
                        Description = "Time skip effects processed"
                    });

                    // Process any concentration results after effects expire
                    await ProcessConcentrationResult(character);
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing time skip: {ex.Message}";
                StateHasChanged();
            }
            finally
            {
                _timeSkipSemaphore.Release();
            }
        });
    }

    private void OnCombatStateReceived(object? sender, CombatStateMessage e)
    {
        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.CampaignId != table.Id.ToString()) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Refresh the table to get the updated combat state
                table = await tablePortal.FetchAsync(table.Id);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing combat state: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnCharacterUpdateReceived(object? sender, CharacterUpdateMessage e)
    {
        // Ignore events if component is disposed or not our character
        if (_disposed || character == null || e.CharacterId != character.Id)
        {
            return;
        }

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Refresh the character to get the updated state
                character = await characterPortal.FetchAsync(character.Id);
                await LoadEquippedItemsAsync();

                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing character update: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private void OnTableUpdateReceived(object? sender, TableUpdateMessage e)
    {
        // Ignore events if component is disposed or not our table
        if (_disposed || table == null || e.TableId != table.Id) return;

        _ = InvokeAsync(async () =>
        {
            try
            {
                // Handle theme changes
                if (e.UpdateType == "ThemeChanged" && !string.IsNullOrEmpty(e.Theme))
                {
                    await JS.InvokeVoidAsync("threaTheme.apply", e.Theme);
                    // Update local table state
                    table = await tablePortal.FetchAsync(table.Id);
                }
                StateHasChanged();
            }
            catch (Exception ex)
            {
                errorMessage = $"Error processing table update: {ex.Message}";
                StateHasChanged();
            }
        });
    }

    private async Task UnsubscribeFromTimeEvents()
    {
        if (!timeEventSubscribed)
        {
            return;
        }

        TimeEventSubscriber.TimeEventReceived -= OnTimeEventReceived;
        TimeEventSubscriber.TimeSkipReceived -= OnTimeSkipReceived;
        TimeEventSubscriber.CombatStateReceived -= OnCombatStateReceived;
        TimeEventSubscriber.CharacterUpdateReceived -= OnCharacterUpdateReceived;
        TimeEventSubscriber.TableUpdateReceived -= OnTableUpdateReceived;
        await TimeEventSubscriber.UnsubscribeAsync();
        timeEventSubscribed = false;
    }

    public async void Dispose()
    {
        if (_disposed)
        {
            return;
        }
        _disposed = true;

        activityLogSubscription?.Dispose();
        await UnsubscribeFromTimeEvents();
        _timeSkipSemaphore?.Dispose();
    }

    private string GetActivityClass(ActivityCategory category) =>
        category switch
        {
            ActivityCategory.Combat => "text-danger",
            ActivityCategory.Announcement => "text-primary fw-bold",
            ActivityCategory.Health => "text-success",
            ActivityCategory.Effect => "text-warning",
            ActivityCategory.Time => "text-info",
            ActivityCategory.Session => "text-secondary fst-italic",
            ActivityCategory.Player => "text-muted",
            _ => ""
        };

    private async Task SaveCharacterAsync()
    {
        if (character == null) return;
        try
        {
            await characterPortal.UpdateAsync(character);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to save character: {ex.Message}";
        }
    }

    // UI Helper methods
    private int GetWoundCount() => character?.Effects.Count(e => e.EffectType == Threa.Dal.Dto.EffectType.Wound) ?? 0;

    private string GetEffectTooltip(GameMechanics.EffectRecord effect)
    {
        var duration = effect.RemainingRounds.HasValue ? $" ({effect.RemainingRounds} rounds left)" : "";
        var source = string.IsNullOrEmpty(effect.Source) ? "" : $" (Source: {effect.Source})";
        var description = string.IsNullOrEmpty(effect.Description) ? "" : $": {effect.Description}";

        return $"{effect.Name}{description}{duration}{source}";
    }

    private string GetEffectColor(GameMechanics.EffectRecord effect) => effect.EffectType switch
    {
        Threa.Dal.Dto.EffectType.Buff => "var(--color-accent-green)",
        Threa.Dal.Dto.EffectType.Debuff or Threa.Dal.Dto.EffectType.Poison => "var(--color-accent-red)",
        Threa.Dal.Dto.EffectType.Wound => "var(--color-accent-red)",
        Threa.Dal.Dto.EffectType.Disease => "var(--color-accent-secondary)",
        Threa.Dal.Dto.EffectType.Condition => "var(--color-accent-gold)",
        Threa.Dal.Dto.EffectType.SpellEffect => "var(--color-accent-blue)",
        Threa.Dal.Dto.EffectType.ItemEffect => "var(--color-accent-primary)",
        _ => "var(--color-text-primary)"
    };

    // Detach confirmation methods
    private void ShowDetachConfirmation(GameMechanics.Player.CharacterInfo charInfo)
    {
        characterToDetach = charInfo;
        showDetachConfirmation = true;
    }

    private void CancelDetach()
    {
        showDetachConfirmation = false;
        characterToDetach = null;
    }

    private async Task ConfirmDetach()
    {
        if (characterToDetach == null) return;

        try
        {
            isDetaching = true;
            errorMessage = null;

            var result = await detacherPortal.ExecuteAsync(characterToDetach.Id);

            if (result.Success)
            {
                AddLogEntry($"Detached {characterToDetach.Name} from table {result.TableName}", ActivityCategory.Player);

                // Reload the character list to reflect the change
                await LoadCharactersAsync();
            }
            else
            {
                errorMessage = result.ErrorMessage ?? "Failed to detach character from table.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to detach character: {ex.Message}";
        }
        finally
        {
            isDetaching = false;
            showDetachConfirmation = false;
            characterToDetach = null;
        }
    }

    // Table selection methods
    private void CancelTableSelection()
    {
        showTableSelection = false;
        characterToAttach = null;
        selectedTableId = Guid.Empty;
    }

    private async Task PlayWithoutTable()
    {
        if (characterToAttach == null) return;

        try
        {
            errorMessage = null;
            character = await characterPortal.FetchAsync(characterToAttach.Id);
            await LoadEquippedItemsAsync();
            AddLogEntry($"Playing as {character.Name} (no table)", ActivityCategory.Player);
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load character: {ex.Message}";
        }
        finally
        {
            showTableSelection = false;
            characterToAttach = null;
            selectedTableId = Guid.Empty;
        }
    }

    private async Task ConfirmTableSelection()
    {
        if (characterToAttach == null || selectedTableId == Guid.Empty) return;

        try
        {
            isAttaching = true;
            errorMessage = null;

            var result = await attacherPortal.ExecuteAsync(characterToAttach.Id, selectedTableId, currentPlayerId);

            if (result.Success)
            {
                // Load the character and table
                character = await characterPortal.FetchAsync(characterToAttach.Id);
                await LoadEquippedItemsAsync();
                table = await tablePortal.FetchAsync(selectedTableId);
                SubscribeToActivityLog(selectedTableId);
                await SubscribeToTimeEvents(selectedTableId);

                // Apply the table's theme
                if (table != null)
                {
                    await JS.InvokeVoidAsync("threaTheme.apply", table.Theme ?? "fantasy");
                }

                // Reload the character list to reflect the change
                await LoadCharactersAsync();

                AddLogEntry($"Joined table {result.TableName}", ActivityCategory.Player);

                // If joining an in-progress table, announce the current game time
                if (table?.Status == Threa.Dal.Dto.TableStatus.Active)
                {
                    var timeDisplay = GameTimeFormatter.FormatFull(table.CurrentTimeSeconds);
                    AddLogEntry($"The in-game time is: {timeDisplay}", ActivityCategory.Time);
                }
            }
            else
            {
                errorMessage = result.ErrorMessage ?? "Failed to join table.";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to join table: {ex.Message}";
        }
        finally
        {
            isAttaching = false;
            showTableSelection = false;
            characterToAttach = null;
            selectedTableId = Guid.Empty;
        }
    }

    // ================================
    // Concentration Result Processing
    // ================================

    /// <summary>
    /// Processes the LastConcentrationResult from a character after concentration ends.
    /// Handles magazine reload completion and sustained effect cleanup.
    /// </summary>
    private async Task ProcessConcentrationResult(GameMechanics.CharacterEdit targetCharacter)
    {
        var result = targetCharacter.LastConcentrationResult;
        if (result == null) return;

        try
        {
            switch (result.ActionType)
            {
                case "MagazineReload":
                    if (result.Success)
                    {
                        await ExecuteMagazineReload(targetCharacter, result.Payload);
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    else
                    {
                        // Reload was interrupted
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;

                case "SustainedBreak":
                    await ProcessSustainedBreak(result.Payload);
                    AddLogEntry(result.Message, ActivityCategory.Effect);
                    break;

                case "SpellCast":
                    // TODO: Implement when spell system is ready
                    if (result.Success)
                    {
                        AddLogEntry(result.Message, ActivityCategory.Effect);
                    }
                    break;
            }
        }
        finally
        {
            // Always clear the result after processing
            targetCharacter.ClearConcentrationResult();
        }
    }

    /// <summary>
    /// Executes the magazine reload by updating the weapon's LoadedAmmo via WeaponAmmoState.
    /// </summary>
    private async Task ExecuteMagazineReload(GameMechanics.CharacterEdit targetCharacter, string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        var payload = GameMechanics.Effects.Behaviors.MagazineReloadPayload.FromJson(payloadJson);
        if (payload == null) return;

        try
        {
            // Fetch the weapon item from DAL
            var weapon = await CharacterItemDal.GetItemAsync(payload.WeaponItemId);
            if (weapon != null)
            {
                // Update LoadedAmmo via WeaponAmmoState pattern
                var ammoState = GameMechanics.Combat.WeaponAmmoState.FromJson(weapon.CustomProperties);
                ammoState.LoadedAmmo = payload.RoundsToLoad;

                // Merge ammo state back into CustomProperties
                weapon.CustomProperties = GameMechanics.Combat.WeaponAmmoState.MergeIntoCustomProperties(
                    weapon.CustomProperties, ammoState);

                await CharacterItemDal.UpdateItemAsync(weapon);

                // Reload equipped items to reflect the change
                await LoadEquippedItemsAsync();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to complete magazine reload: {ex.Message}";
        }
    }

    /// <summary>
    /// Processes sustained concentration break by removing all linked effects from table characters.
    /// </summary>
    private async Task ProcessSustainedBreak(string? payloadJson)
    {
        if (string.IsNullOrEmpty(payloadJson)) return;

        // Parse the payload to get LinkedEffectIds
        try
        {
            var payload = System.Text.Json.JsonSerializer.Deserialize<SustainedBreakPayload>(payloadJson);
            if (payload?.LinkedEffectIds == null || payload.LinkedEffectIds.Count == 0) return;

            var linkedIds = new HashSet<Guid>(payload.LinkedEffectIds);

            // For the current character, remove matching effects
            if (character != null)
            {
                var effectsToRemove = character.Effects
                    .Where(e => linkedIds.Contains(e.Id))
                    .ToList();

                foreach (var effect in effectsToRemove)
                {
                    character.Effects.RemoveEffect(effect.Id);
                }

                // Also remove effects that have matching SourceEffectId
                var linkedBySource = character.Effects
                    .Where(e => e.SourceEffectId.HasValue && linkedIds.Contains(e.SourceEffectId.Value))
                    .ToList();

                foreach (var effect in linkedBySource)
                {
                    character.Effects.RemoveEffect(effect.Id);
                }

                // Save if any effects were removed
                if (effectsToRemove.Count > 0 || linkedBySource.Count > 0)
                {
                    await characterPortal.UpdateAsync(character);
                }
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error processing sustained break: {ex.Message}";
        }
    }

    /// <summary>
    /// Payload structure for sustained break result.
    /// </summary>
    private class SustainedBreakPayload
    {
        public List<Guid>? LinkedEffectIds { get; set; }
        public string? SpellName { get; set; }
    }
}
