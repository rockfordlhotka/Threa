@* Inventory Tab for gameplay - Grid-based inventory and equipment slots *@
@using Threa.Dal
@using Threa.Dal.Dto
@using GameMechanics.Items
@using GameMechanics.Combat
@using GameMechanics.Effects.Behaviors
@using Threa.Client.Components.Shared
@using Radzen

@inject ICharacterItemDal itemDal
@inject IItemTemplateDal templateDal
@inject ItemManagementService itemService
@inject DialogService DialogService
@inject IChildDataPortal<GameMechanics.EffectRecord> EffectPortal

<style>
    .inventory-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 8px;
        max-height: 500px;
        overflow-y: auto;
        padding: 8px;
        background: var(--color-bg-secondary, #f8f9fa);
        border-radius: 4px;
    }

    .inventory-tile {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 8px;
        border: 1px solid var(--color-card-border, #dee2e6);
        border-radius: var(--border-radius, 4px);
        cursor: pointer;
        background: var(--color-card-bg, #fff);
        color: var(--color-text-primary, #212529);
        min-height: 80px;
        transition: all 0.15s ease-in-out;
    }

    .inventory-tile:hover {
        border-color: var(--color-accent-primary, #adb5bd);
        background: var(--color-bg-tertiary, #e9ecef);
    }

    .inventory-tile.equipped {
        border-color: var(--bs-success);
        border-width: 2px;
    }

    .inventory-tile.selected {
        border-color: var(--bs-primary);
        border-width: 2px;
        background: rgba(var(--bs-primary-rgb), 0.1);
    }

    .inventory-tile.selected.equipped {
        border-color: var(--bs-primary);
    }

    .equipped-badge {
        position: absolute;
        top: 2px;
        right: 2px;
        background: var(--bs-success);
        color: white;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .item-quantity {
        position: absolute;
        bottom: 2px;
        right: 2px;
        background: rgba(0,0,0,0.6);
        color: white;
        padding: 0 4px;
        border-radius: 2px;
        font-size: 11px;
    }

    .item-loaded-ammo {
        position: absolute;
        bottom: 2px;
        left: 2px;
        background: var(--bs-primary);
        color: white;
        padding: 0 4px;
        border-radius: 2px;
        font-size: 11px;
    }

    .item-loaded-ammo.empty {
        background: var(--bs-danger);
    }

    .item-loaded-ammo.low {
        background: var(--bs-warning);
        color: black;
    }

    .item-icon {
        font-size: 24px;
        margin-bottom: 4px;
        color: var(--color-text-primary, #212529);
    }

    .item-name {
        font-size: 11px;
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        white-space: nowrap;
        color: var(--color-text-primary, #212529);
    }

    .equipment-slots-container {
        max-height: 600px;
        overflow-y: auto;
    }

    .equipment-slot {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 10px;
        border-bottom: 1px solid var(--color-card-border, #eee);
        font-size: 0.9rem;
    }

    .equipment-slot:last-child {
        border-bottom: none;
    }

    .slot-name {
        color: var(--color-text-muted, #6c757d);
        min-width: 120px;
    }

    .slot-item-name {
        font-weight: 500;
        color: var(--color-text-primary, #212529);
    }

    .empty-slot {
        color: var(--color-text-muted, #adb5bd);
        font-style: italic;
    }

    .slot-category {
        margin-bottom: 1rem;
    }

    .slot-category h6 {
        margin-bottom: 0.5rem;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .equipment-slot.clickable {
        cursor: pointer;
    }

    .equipment-slot.clickable:hover {
        background: var(--color-bg-tertiary, #f0f0f0);
    }

    .equipment-slot.valid-target {
        background: rgba(var(--bs-success-rgb), 0.1);
        border-color: var(--bs-success);
    }

    .inventory-actions {
        background: var(--color-bg-tertiary, #f8f9fa);
        border-radius: 0 0 4px 4px;
    }

    .container-grid {
        display: flex;
        flex-direction: column;
        gap: 4px;
        max-height: 300px;
        overflow-y: auto;
    }

    .container-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border: 1px solid var(--color-card-border, #dee2e6);
        border-radius: var(--border-radius, 4px);
        cursor: pointer;
        background: var(--color-card-bg, #fff);
        color: var(--color-text-primary, #212529);
    }

    .container-item:hover {
        background: var(--color-bg-tertiary, #f0f0f0);
    }

    .container-item.selected {
        border-color: var(--bs-primary);
        background: rgba(var(--bs-primary-rgb), 0.1);
    }

    .container-item .item-icon {
        font-size: 16px;
        width: 20px;
        text-align: center;
        color: var(--color-text-primary, #212529);
    }

    .container-item .item-name {
        flex: 1;
        font-size: 0.9rem;
        color: var(--color-text-primary, #212529);
    }

    .container-item .item-qty {
        color: var(--color-text-muted, #6c757d);
        font-size: 0.8rem;
    }

    .inventory-tile.is-container {
        border-style: dashed;
    }

    .inventory-tile.is-container::before {
        content: "";
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: var(--color-text-muted, #6c757d);
    }

    .inventory-tile.container-empty::before {
        background: var(--color-text-muted, #6c757d);
    }

    .inventory-tile.container-partial {
        border-color: var(--bs-success);
    }

    .inventory-tile.container-partial::before {
        background: var(--bs-success);
    }

    .inventory-tile.container-warning {
        border-color: var(--bs-warning);
    }

    .inventory-tile.container-warning::before {
        background: var(--bs-warning);
    }

    .inventory-tile.container-full {
        border-color: var(--bs-danger);
    }

    .inventory-tile.container-full::before {
        background: var(--bs-danger);
    }
</style>

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger alert-dismissible fade show" role="alert">
        @errorMessage
        <button type="button" class="btn-close" @onclick="() => errorMessage = null"></button>
    </div>
}
@if (!string.IsNullOrEmpty(successMessage))
{
    <div class="alert alert-success alert-dismissible fade show" role="alert">
        @successMessage
        <button type="button" class="btn-close" @onclick="() => successMessage = null"></button>
    </div>
}
@if (!string.IsNullOrEmpty(warningMessage))
{
    <div class="alert alert-warning alert-dismissible fade show" role="alert">
        @warningMessage
        <button type="button" class="btn-close" @onclick="() => warningMessage = null"></button>
    </div>
}

<div class="row">
    <!-- Inventory Grid -->
    <div class="col-md-7">
        <div class="card mb-3">
            <div class="card-header bg-primary text-white">
                <strong>Inventory</strong>
            </div>
            <div class="card-body">
                @if (isLoading)
                {
                    <div class="text-center py-4">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                }
                else if (inventoryItems == null || !inventoryItems.Any())
                {
                    <p class="text-muted text-center py-3">No items in inventory.</p>
                }
                else
                {
                    <div class="inventory-grid">
                        @foreach (var item in inventoryItems.Where(i => i.ContainerItemId == null))
                        {
                            <div class="inventory-tile @(item.IsEquipped ? "equipped" : "") @(selectedItemId == item.Id ? "selected" : "") @(IsContainerItem(item) ? "is-container" : "") @GetContainerFillClass(item)"
                                 title="@GetItemTooltip(item)"
                                 @onclick="async () => await SelectItem(item)">
                                @if (item.IsEquipped)
                                {
                                    <div class="equipped-badge" title="Equipped">E</div>
                                }
                                <div class="item-icon">@GetItemIcon(item)</div>
                                <div class="item-name">@GetItemDisplayName(item)</div>
                                @{
                                    var loadedAmmoInfo = GetLoadedAmmoInfo(item);
                                }
                                @if (loadedAmmoInfo.HasAmmo)
                                {
                                    <div class="item-loaded-ammo @loadedAmmoInfo.StatusClass" title="@loadedAmmoInfo.Tooltip">
                                        @loadedAmmoInfo.Display
                                    </div>
                                }
                                @if (item.Template?.IsStackable == true && item.StackSize > 1)
                                {
                                    <div class="item-quantity">@($"x{item.StackSize}")</div>
                                }
                            </div>
                        }
                    </div>
                }
            </div>
        </div>

        <!-- Inventory Actions -->
        <div class="inventory-actions mt-3 p-2 border-top">
            <button class="btn btn-outline-danger"
                    disabled="@(selectedItem == null)"
                    @onclick="ConfirmDropItem">
                <i class="bi bi-trash"></i> Drop
            </button>
            @if (IsReloadableAmmoContainer(selectedItem) && GetCompatibleLooseAmmo(selectedItem!).Any())
            {
                <button class="btn btn-outline-primary ms-2"
                        @onclick="OpenReloadAmmoContainerModal">
                    <i class="bi bi-box-arrow-in-down"></i> Reload
                </button>
            }
            @if (IsUnloadableAmmoContainer(selectedItem))
            {
                <button class="btn btn-outline-warning ms-2"
                        @onclick="OpenUnloadAmmoContainerModal">
                    <i class="bi bi-box-arrow-up"></i> Unload
                </button>
            }
            @if (IsReloadableWeapon(selectedItem) && GetCompatibleAmmoForWeapon(selectedItem!).Any())
            {
                <button class="btn btn-outline-primary ms-2"
                        @onclick="OpenReloadWeaponModal">
                    <i class="bi bi-box-arrow-in-down"></i> Reload
                </button>
            }
            @if (IsUnloadableWeapon(selectedItem))
            {
                <button class="btn btn-outline-warning ms-2"
                        @onclick="OpenUnloadWeaponModal">
                    <i class="bi bi-box-arrow-up"></i> Unload
                </button>
            }
            @if (selectedItem != null)
            {
                <span class="ms-3 text-muted">
                    Selected: <strong>@GetItemName(selectedItem)</strong>
                    @if (selectedItem.IsEquipped)
                    {
                        <span class="badge bg-success ms-1">Equipped</span>
                    }
                </span>
            }
        </div>

        <!-- Currency -->
        <div class="card mt-3">
            <div class="card-header">
                <strong>Currency</strong>
            </div>
            <div class="card-body">
                <table class="table table-sm mb-0">
                    <tbody>
                        <tr>
                            <td>Platinum</td>
                            <td class="text-end"><strong>@Character?.PlatinumCoins</strong> pp</td>
                        </tr>
                        <tr>
                            <td>Gold</td>
                            <td class="text-end"><strong>@Character?.GoldCoins</strong> gp</td>
                        </tr>
                        <tr>
                            <td>Silver</td>
                            <td class="text-end"><strong>@Character?.SilverCoins</strong> sp</td>
                        </tr>
                        <tr>
                            <td>Copper</td>
                            <td class="text-end"><strong>@Character?.CopperCoins</strong> cp</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Equipment Slots / Container Panel -->
    <div class="col-md-5">
        @if (selectedContainer != null)
        {
            <div class="card">
                <div class="card-header bg-info text-white">
                    <div class="d-flex justify-content-between align-items-center">
                        <strong>@GetItemName(selectedContainer)</strong>
                        <button type="button" class="btn-close btn-close-white" @onclick="CloseContainerPanel"></button>
                    </div>
                    @{ var capacity = GetContainerCapacity(selectedContainer); }
                    <div class="small mt-1">
                        @if (capacity.MaxWeight < decimal.MaxValue)
                        {
                            <span class="@(capacity.WeightPercent >= 100 ? "text-warning" : "")">
                                Weight: @capacity.CurrentWeight.ToString("0.#")/@capacity.MaxWeight.ToString("0.#") lbs
                            </span>
                        }
                        @if (capacity.MaxVolume < decimal.MaxValue)
                        {
                            <span class="ms-2 @(capacity.VolumePercent >= 100 ? "text-warning" : "")">
                                Volume: @capacity.CurrentVolume.ToString("0.#")/@capacity.MaxVolume.ToString("0.#")
                            </span>
                        }
                        @if (capacity.IsOverCapacity)
                        {
                            <span class="badge bg-warning text-dark ms-2">Over Capacity</span>
                        }
                    </div>
                </div>
                <div class="card-body">
                    @if (!containerContents.Any())
                    {
                        <p class="text-muted text-center">Container is empty.</p>
                    }
                    else
                    {
                        <div class="container-grid">
                            @foreach (var item in containerContents)
                            {
                                <div class="container-item @(selectedContainerItemId == item.Id ? "selected" : "")"
                                     title="@GetItemTooltip(item)"
                                     @onclick="() => SelectContainerItem(item)">
                                    <span class="item-icon">@GetItemIcon(item)</span>
                                    <span class="item-name">@GetItemDisplayName(item)</span>
                                    @if (item.Template?.IsStackable == true && item.StackSize > 1)
                                    {
                                        <span class="item-qty">@($"x{item.StackSize}")</span>
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
                <div class="card-footer">
                    <button class="btn btn-outline-primary btn-sm"
                            disabled="@(selectedContainerItem == null)"
                            @onclick="RemoveFromContainer">
                        Remove to Inventory
                    </button>
                </div>
            </div>
        }
        else
        {
            <div class="card">
                <div class="card-header bg-success text-white">
                    <strong>Equipment</strong>
                </div>
                <div class="card-body equipment-slots-container">
                    @foreach (var category in slotCategories)
                    {
                        <div class="slot-category">
                            <h6 class="text-muted">@category.Name</h6>
                            @foreach (var slot in category.Slots)
                            {
                                var equipped = GetEquippedItem(slot);
                                <div class="equipment-slot clickable @(IsValidTarget(slot) ? "valid-target" : "")"
                                     @onclick="() => OnEquipmentSlotClick(slot)">
                                    <span class="slot-name">@slot.GetDisplayName()</span>
                                    @if (equipped != null)
                                    {
                                        <span class="slot-item-name">@GetItemDisplayName(equipped)</span>
                                    }
                                    else
                                    {
                                        <span class="empty-slot">Empty</span>
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
            </div>
        }
    </div>
</div>

@if (showDropQuantityDialog && selectedItem != null)
{
    <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
        <div class="modal-dialog modal-sm">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Drop @GetItemName(selectedItem)</h5>
                    <button type="button" class="btn-close" @onclick="CancelDropQuantity"></button>
                </div>
                <div class="modal-body">
                    <p>How many do you want to drop?</p>
                    <div class="mb-3">
                        <label class="form-label">Quantity (max: @selectedItem.StackSize)</label>
                        <input type="number" class="form-control"
                               @bind="dropQuantity"
                               min="1"
                               max="@selectedItem.StackSize" />
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CancelDropQuantity">Cancel</button>
                    <button type="button" class="btn btn-danger" @onclick="ConfirmDropQuantity">
                        Drop @dropQuantity
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public GameMechanics.CharacterEdit? Character { get; set; }

    [Parameter]
    public GameMechanics.GamePlay.TableEdit? Table { get; set; }

    [Parameter]
    public EventCallback OnCharacterChanged { get; set; }

    private List<CharacterItem>? inventoryItems;
    private Dictionary<int, ItemTemplate>? templateCache;
    private bool isLoading = true;

    // Selection state
    private Guid? selectedItemId;
    private CharacterItem? selectedItem;
    private string? errorMessage;
    private string? successMessage;
    private string? warningMessage;

    // Container panel state
    private CharacterItem? selectedContainer;
    private List<CharacterItem> containerContents = new();
    private Guid? selectedContainerItemId;
    private CharacterItem? selectedContainerItem;

    // Drop quantity dialog state
    private int dropQuantity = 1;
    private bool showDropQuantityDialog = false;

    private static readonly SlotCategory[] slotCategories = new[]
    {
        new SlotCategory("Weapons", new[] {
            EquipmentSlot.MainHand,
            EquipmentSlot.OffHand,
            EquipmentSlot.TwoHand
        }),
        new SlotCategory("Head & Neck", new[] {
            EquipmentSlot.Head,
            EquipmentSlot.Face,
            EquipmentSlot.Ears,
            EquipmentSlot.Neck
        }),
        new SlotCategory("Body", new[] {
            EquipmentSlot.Shoulders,
            EquipmentSlot.Back,
            EquipmentSlot.Chest,
            EquipmentSlot.Waist
        }),
        new SlotCategory("Arms", new[] {
            EquipmentSlot.ArmLeft, EquipmentSlot.ArmRight,
            EquipmentSlot.WristLeft, EquipmentSlot.WristRight,
            EquipmentSlot.HandLeft, EquipmentSlot.HandRight
        }),
        new SlotCategory("Legs & Feet", new[] {
            EquipmentSlot.Legs,
            EquipmentSlot.AnkleLeft, EquipmentSlot.AnkleRight,
            EquipmentSlot.FootLeft, EquipmentSlot.FootRight
        }),
        new SlotCategory("Rings - Left", new[] {
            EquipmentSlot.FingerLeft1, EquipmentSlot.FingerLeft2,
            EquipmentSlot.FingerLeft3, EquipmentSlot.FingerLeft4,
            EquipmentSlot.FingerLeft5
        }),
        new SlotCategory("Rings - Right", new[] {
            EquipmentSlot.FingerRight1, EquipmentSlot.FingerRight2,
            EquipmentSlot.FingerRight3, EquipmentSlot.FingerRight4,
            EquipmentSlot.FingerRight5
        })
    };

    private record SlotCategory(string Name, EquipmentSlot[] Slots);

    private record ContainerCapacity
    {
        public decimal CurrentWeight { get; init; }
        public decimal MaxWeight { get; init; }
        public decimal CurrentVolume { get; init; }
        public decimal MaxVolume { get; init; }
        public decimal WeightPercent { get; init; }
        public decimal VolumePercent { get; init; }
        public decimal FillPercent => Math.Max(WeightPercent, VolumePercent);
        public bool IsOverCapacity { get; init; }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadItemsAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        // Reload items when character changes
        if (Character != null)
        {
            await LoadItemsAsync();
        }
    }

    private async Task LoadItemsAsync()
    {
        if (Character == null || Character.Id == 0)
        {
            inventoryItems = new List<CharacterItem>();
            isLoading = false;
            return;
        }

        try
        {
            isLoading = true;
            StateHasChanged();

            // Get all items for the character
            inventoryItems = await itemDal.GetCharacterItemsAsync(Character.Id);
            templateCache = new Dictionary<int, ItemTemplate>();

            // Load templates for all unique template IDs
            var uniqueTemplateIds = inventoryItems
                .Select(i => i.ItemTemplateId)
                .Distinct()
                .ToList();

            foreach (var templateId in uniqueTemplateIds)
            {
                if (!templateCache.ContainsKey(templateId))
                {
                    var template = await templateDal.GetTemplateAsync(templateId);
                    templateCache[templateId] = template;
                }
            }

            // Populate template references on items
            foreach (var item in inventoryItems)
            {
                if (templateCache.TryGetValue(item.ItemTemplateId, out var template))
                {
                    item.Template = template;
                }
            }
        }
        finally
        {
            isLoading = false;
        }
    }

    private string GetItemDisplayName(CharacterItem item)
    {
        return item.CustomName ?? item.Template?.Name ?? "Unknown Item";
    }

    private string GetItemIcon(CharacterItem item)
    {
        if (item.Template == null)
            return "?";

        return item.Template.ItemType switch
        {
            ItemType.Weapon => "W",
            ItemType.Armor => "A",
            ItemType.Shield => "S",
            ItemType.Ammunition => "*",
            ItemType.AmmoContainer => "M",
            ItemType.Consumable => "+",
            ItemType.Container => "[]",
            ItemType.Jewelry => "o",
            ItemType.Clothing => "C",
            ItemType.Food => "F",
            ItemType.Drink => "D",
            ItemType.Tool => "T",
            ItemType.Key => "K",
            ItemType.Magic => "~",
            ItemType.Treasure => "$",
            ItemType.RawMaterial => "R",
            ItemType.Miscellaneous => "?",
            _ => "?"
        };
    }

    private CharacterItem? GetEquippedItem(EquipmentSlot slot)
    {
        return inventoryItems?.FirstOrDefault(i => i.IsEquipped && i.EquippedSlot == slot);
    }

    // Loaded ammo display info
    private record LoadedAmmoInfo(bool HasAmmo, string Display, string StatusClass, string Tooltip);

    /// <summary>
    /// Gets loaded ammo information for display on inventory tiles.
    /// Shows ammo count for ammo containers and weapons with magazines.
    /// </summary>
    private LoadedAmmoInfo GetLoadedAmmoInfo(CharacterItem item)
    {
        var template = GetTemplate(item.ItemTemplateId);
        if (template == null)
            return new LoadedAmmoInfo(false, "", "", "");

        // Check for ammo containers (magazines, quivers, speedloaders)
        if (template.ItemType == ItemType.AmmoContainer)
        {
            var containerState = GameMechanics.Combat.AmmoContainerState.FromJson(item.CustomProperties);
            var containerProps = AmmoContainerProperties.FromJson(template.CustomProperties);

            int loaded = containerState.LoadedAmmo;
            int maxCapacity = containerState.MaxCapacity;
            if (maxCapacity == 0 && containerProps != null)
                maxCapacity = containerProps.Capacity;

            if (maxCapacity == 0)
                return new LoadedAmmoInfo(false, "", "", "");

            string statusClass = "";
            if (loaded == 0)
                statusClass = "empty";
            else if (loaded <= maxCapacity / 4)
                statusClass = "low";

            string ammoType = containerState.AmmoType ?? containerProps?.AmmoType ?? "";
            string tooltip = $"{loaded}/{maxCapacity} rounds";
            if (!string.IsNullOrEmpty(ammoType))
                tooltip += $" ({ammoType})";

            return new LoadedAmmoInfo(true, $"x{loaded}", statusClass, tooltip);
        }

        // Check for weapons with loaded ammo
        if (template.ItemType == ItemType.Weapon)
        {
            var weaponState = GameMechanics.Combat.WeaponAmmoState.FromJson(item.CustomProperties);
            int totalAmmo = weaponState.TotalAvailable; // Includes chamber

            // Only show if weapon has ammo capacity (ranged weapons)
            if (totalAmmo > 0 || weaponState.LoadedMagazineId.HasValue)
            {
                string statusClass = "";
                if (totalAmmo == 0)
                    statusClass = "empty";
                // Can't easily determine "low" without capacity info from template

                string tooltip = $"{totalAmmo} rounds loaded";
                if (weaponState.ChamberLoaded)
                    tooltip += " (+1 chambered)";
                if (!string.IsNullOrEmpty(weaponState.LoadedAmmoType))
                    tooltip += $" ({weaponState.LoadedAmmoType})";

                return new LoadedAmmoInfo(true, $"x{totalAmmo}", statusClass, tooltip);
            }
        }

        return new LoadedAmmoInfo(false, "", "", "");
    }

    // Selection methods
    private async Task SelectItem(CharacterItem item)
    {
        ClearMessages();

        // If user has an item selected and clicks a container, move item into container
        if (selectedItem != null && IsContainerItem(item) && selectedItem.Id != item.Id)
        {
            // Special handling for AmmoContainers: check if user is trying to load ammo
            var containerTemplate = GetTemplate(item.ItemTemplateId);
            if (containerTemplate?.ItemType == ItemType.AmmoContainer)
            {
                // Check if selected item is compatible loose ammo
                var selectedTemplate = GetTemplate(selectedItem.ItemTemplateId);
                if (selectedTemplate?.ItemType == ItemType.Ammunition)
                {
                    // Select the container and open reload dialog if ammo is compatible
                    var previousAmmo = selectedItem;
                    selectedItemId = item.Id;
                    selectedItem = item;

                    var compatibleAmmo = GetCompatibleLooseAmmo(item);
                    if (compatibleAmmo.Any(a => a.Id == previousAmmo.Id))
                    {
                        // Ammo is compatible - open reload modal directly
                        await OpenReloadAmmoContainerModal();
                    }
                    else
                    {
                        // Ammo is not compatible - show error but keep container selected
                        errorMessage = $"{GetItemName(previousAmmo)} is not compatible with this {containerTemplate.Name}. " +
                                       "Select the container and click Reload to see compatible ammo types.";
                    }
                    return;
                }
                else
                {
                    // Non-ammo item trying to go into ammo container
                    errorMessage = "Only ammunition can be loaded into ammo containers. " +
                                   "Select the magazine/quiver and click Reload.";
                    // Select the container so Reload button appears
                    selectedItemId = item.Id;
                    selectedItem = item;
                    return;
                }
            }

            await MoveToContainer(selectedItem.Id, item.Id);
            return;
        }

        // If clicking a container with no item selected, open container panel
        if (IsContainerItem(item) && selectedItem == null)
        {
            // For AmmoContainers, don't open container panel - just select for reload
            var template = GetTemplate(item.ItemTemplateId);
            if (template?.ItemType == ItemType.AmmoContainer)
            {
                selectedItemId = item.Id;
                selectedItem = item;
                // Don't open container panel for ammo containers
                return;
            }

            OpenContainerPanel(item);
            // Also select the container in inventory (for potential drop)
            selectedItemId = item.Id;
            selectedItem = item;
            return;
        }

        // Normal toggle selection
        if (selectedItemId == item.Id)
        {
            selectedItemId = null;
            selectedItem = null;
        }
        else
        {
            selectedItemId = item.Id;
            selectedItem = item;
            // Close container panel when selecting non-container
            if (!IsContainerItem(item))
            {
                CloseContainerPanel();
            }
        }
    }

    private void ClearMessages()
    {
        errorMessage = null;
        successMessage = null;
        warningMessage = null;
    }

    // Equip/Unequip methods
    private async Task OnEquipmentSlotClick(EquipmentSlot slot)
    {
        try
        {
            ClearMessages();

            // If no item selected, check if we should unequip
            if (selectedItem == null)
            {
                var equippedItem = GetEquippedItem(slot);
                if (equippedItem != null)
                {
                    await UnequipItem(equippedItem.Id);
                }
                return;
            }

            // Check slot compatibility (use template.EquipmentSlot)
            var template = GetTemplate(selectedItem.ItemTemplateId);
            if (template == null)
            {
                errorMessage = "Item template not found.";
                return;
            }

            // Check if item type can be equipped at all
            if (!IsEquippableType(template.ItemType))
            {
                errorMessage = $"{template.Name} cannot be equipped (type: {template.ItemType}).";
                return;
            }

            if (!IsSlotCompatible(template.EquipmentSlot, slot))
            {
                errorMessage = $"This item (slot: {template.EquipmentSlot}) cannot be equipped in the {slot.GetDisplayName()} slot.";
                return;
            }

            // Check if target slot has a cursed item (auto-swap would fail)
            var existingItem = GetEquippedItem(slot);
            if (existingItem != null && !itemService.CanUnequipItem(Character!, existingItem.Id))
            {
                errorMessage = $"Cannot swap: {GetItemName(existingItem)} is cursed and cannot be unequipped.";
                return;
            }

            // Equip the item (service handles auto-swap)
            var result = await itemService.EquipItemAsync(Character!, selectedItem.Id, slot);
            if (!result.Success)
            {
                errorMessage = result.ErrorMessage;
                return;
            }

            successMessage = $"Equipped {GetItemName(selectedItem)} to {slot.GetDisplayName()}.";
            selectedItem = null;
            selectedItemId = null;
            await LoadItemsAsync();
            await NotifyCharacterChanged();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error equipping item: {ex.Message}";
        }
    }

    private async Task UnequipItem(Guid itemId)
    {
        var result = await itemService.UnequipItemAsync(Character!, itemId);
        if (!result.Success)
        {
            errorMessage = result.ErrorMessage;  // Will show curse blocking message
            return;
        }

        var itemName = GetItemName(inventoryItems?.FirstOrDefault(i => i.Id == itemId));
        successMessage = $"Unequipped {itemName}.";
        await LoadItemsAsync();
        await NotifyCharacterChanged();
    }

    // Helper methods
    private ItemTemplate? GetTemplate(int templateId)
    {
        return templateCache?.GetValueOrDefault(templateId);
    }

    private string GetItemName(CharacterItem? item)
    {
        if (item == null) return "item";
        return item.CustomName ?? GetTemplate(item.ItemTemplateId)?.Name ?? "item";
    }

    // Container methods
    private bool IsContainerItem(CharacterItem item)
    {
        var template = GetTemplate(item.ItemTemplateId);
        if (template == null) return false;
        return template.IsContainer || template.ItemType == ItemType.Container || template.ItemType == ItemType.AmmoContainer;
    }

    private ContainerCapacity GetContainerCapacity(CharacterItem container)
    {
        var template = GetTemplate(container.ItemTemplateId);
        if (template == null || !IsContainerItem(container))
            return new ContainerCapacity();

        var contents = GetContainerContents(container.Id);

        decimal currentWeight = 0;
        decimal currentVolume = 0;

        foreach (var item in contents)
        {
            var itemTemplate = GetTemplate(item.ItemTemplateId);
            if (itemTemplate == null) continue;

            currentWeight += itemTemplate.Weight * item.StackSize;
            currentVolume += itemTemplate.Volume * item.StackSize;
        }

        // Apply magical weight reduction (e.g., Bag of Holding has < 1.0)
        currentWeight *= template.ContainerWeightReduction;

        var maxWeight = template.ContainerMaxWeight ?? decimal.MaxValue;
        var maxVolume = template.ContainerMaxVolume ?? decimal.MaxValue;

        var weightPercent = maxWeight < decimal.MaxValue && maxWeight > 0
            ? (currentWeight / maxWeight) * 100
            : 0;
        var volumePercent = maxVolume < decimal.MaxValue && maxVolume > 0
            ? (currentVolume / maxVolume) * 100
            : 0;

        return new ContainerCapacity
        {
            CurrentWeight = currentWeight,
            MaxWeight = maxWeight,
            CurrentVolume = currentVolume,
            MaxVolume = maxVolume,
            WeightPercent = weightPercent,
            VolumePercent = volumePercent,
            IsOverCapacity = (maxWeight < decimal.MaxValue && currentWeight > maxWeight) ||
                             (maxVolume < decimal.MaxValue && currentVolume > maxVolume)
        };
    }

    private string GetContainerFillClass(CharacterItem item)
    {
        if (!IsContainerItem(item)) return "";

        var capacity = GetContainerCapacity(item);

        if (capacity.FillPercent >= 100) return "container-full";
        if (capacity.FillPercent >= 75) return "container-warning";
        if (capacity.FillPercent > 0) return "container-partial";
        return "container-empty";
    }

    private string GetCapacityDisplay(CharacterItem container)
    {
        var capacity = GetContainerCapacity(container);
        var parts = new List<string>();

        if (capacity.MaxWeight < decimal.MaxValue)
            parts.Add($"{capacity.CurrentWeight:0.#}/{capacity.MaxWeight:0.#} lbs");
        if (capacity.MaxVolume < decimal.MaxValue)
            parts.Add($"{capacity.CurrentVolume:0.#}/{capacity.MaxVolume:0.#} vol");

        return string.Join(" | ", parts);
    }

    private List<CharacterItem> GetContainerContents(Guid containerId)
    {
        // Client-side filtering from already-loaded items (per RESEARCH.md performance recommendation)
        if (inventoryItems == null) return new List<CharacterItem>();
        return inventoryItems.Where(i => i.ContainerItemId == containerId).ToList();
    }

    private void OpenContainerPanel(CharacterItem container)
    {
        selectedContainer = container;
        containerContents = GetContainerContents(container.Id);
        // Clear container item selection
        selectedContainerItemId = null;
        selectedContainerItem = null;
    }

    private void CloseContainerPanel()
    {
        selectedContainer = null;
        containerContents.Clear();
        selectedContainerItemId = null;
        selectedContainerItem = null;
    }

    private void SelectContainerItem(CharacterItem item)
    {
        if (selectedContainerItemId == item.Id)
        {
            selectedContainerItemId = null;
            selectedContainerItem = null;
        }
        else
        {
            selectedContainerItemId = item.Id;
            selectedContainerItem = item;
        }
    }

    private string? ValidateContainerTypeRestriction(CharacterItem item, CharacterItem container)
    {
        var containerTemplate = GetTemplate(container.ItemTemplateId);
        if (string.IsNullOrEmpty(containerTemplate?.ContainerAllowedTypes))
            return null; // No restrictions

        var itemTemplate = GetTemplate(item.ItemTemplateId);
        if (itemTemplate == null) return null;

        var allowedTypes = containerTemplate.ContainerAllowedTypes
            .Split(',')
            .Select(t => t.Trim())
            .ToList();

        if (!allowedTypes.Contains(itemTemplate.ItemType.ToString()))
        {
            return $"This container is designed for {containerTemplate.ContainerAllowedTypes}. " +
                   $"Placing {itemTemplate.ItemType} items may not be ideal.";
        }

        return null;
    }

    private string? CheckCapacityWarning(CharacterItem item, CharacterItem container)
    {
        var containerTemplate = GetTemplate(container.ItemTemplateId);
        var itemTemplate = GetTemplate(item.ItemTemplateId);
        if (containerTemplate == null || itemTemplate == null) return null;

        var capacity = GetContainerCapacity(container);
        var itemWeight = itemTemplate.Weight * item.StackSize * containerTemplate.ContainerWeightReduction;
        var itemVolume = itemTemplate.Volume * item.StackSize;

        var newWeight = capacity.CurrentWeight + itemWeight;
        var newVolume = capacity.CurrentVolume + itemVolume;

        var warnings = new List<string>();

        if (capacity.MaxWeight < decimal.MaxValue && newWeight > capacity.MaxWeight)
            warnings.Add($"weight ({newWeight:0.#}/{capacity.MaxWeight:0.#} lbs)");

        if (capacity.MaxVolume < decimal.MaxValue && newVolume > capacity.MaxVolume)
            warnings.Add($"volume ({newVolume:0.#}/{capacity.MaxVolume:0.#})");

        if (warnings.Any())
            return $"This will exceed container {string.Join(" and ", warnings)}.";

        return null;
    }

    private string? ValidateNesting(CharacterItem item, CharacterItem container)
    {
        // Check if target container is itself inside another container (BLOCKS placement)
        if (container.ContainerItemId.HasValue)
        {
            return "Cannot place items in a container that is inside another container. " +
                   "Remove the container from its parent first.";
        }

        // If item being moved is a container with contents, block placement (BLOCKS)
        // Empty containers CAN be nested (one level) per CONTEXT.md
        if (IsContainerItem(item))
        {
            var nestedContents = GetContainerContents(item.Id);
            if (nestedContents.Any())
            {
                return "Cannot place a container with items inside another container. " +
                       "Empty the container first.";
            }
            // Empty container - allowed to nest (one level only)
        }

        return null; // Nesting is valid
    }

    private async Task MoveToContainer(Guid itemId, Guid containerId)
    {
        try
        {
            var item = inventoryItems?.FirstOrDefault(i => i.Id == itemId);
            var container = inventoryItems?.FirstOrDefault(i => i.Id == containerId);

            if (item == null || container == null)
            {
                errorMessage = "Item or container not found.";
                return;
            }

            // Check nesting (BLOCKING - returns error, does not proceed)
            var nestingError = ValidateNesting(item, container);
            if (nestingError != null)
            {
                errorMessage = nestingError;
                return;
            }

            // Check type restriction (warning only - does not block)
            var typeWarning = ValidateContainerTypeRestriction(item, container);

            // Check capacity (warning only - does not block)
            var capacityWarning = CheckCapacityWarning(item, container);

            var result = await itemService.MoveToContainerAsync(Character!, itemId, containerId);
            if (!result.Success)
            {
                errorMessage = result.ErrorMessage;
                return;
            }

            var itemName = GetItemName(item);
            var containerName = GetItemName(container);
            successMessage = $"Moved {itemName} into {containerName}.";

            // Show warnings if any (item was still moved successfully)
            var warnings = new List<string>();
            if (typeWarning != null) warnings.Add(typeWarning);
            if (capacityWarning != null) warnings.Add(capacityWarning);
            if (warnings.Any())
            {
                warningMessage = string.Join(" ", warnings);
            }

            // Clear selection and refresh
            selectedItem = null;
            selectedItemId = null;
            await LoadItemsAsync();

            // Re-open container panel to show updated contents
            var updatedContainer = inventoryItems?.FirstOrDefault(i => i.Id == containerId);
            if (updatedContainer != null)
            {
                OpenContainerPanel(updatedContainer);
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error moving item: {ex.Message}";
        }
    }

    private async Task RemoveFromContainer()
    {
        if (selectedContainerItem == null || selectedContainer == null) return;

        try
        {
            ClearMessages();

            // Move item out of container (containerItemId = null)
            var result = await itemService.MoveToContainerAsync(Character!, selectedContainerItem.Id, null);
            if (!result.Success)
            {
                errorMessage = result.ErrorMessage;
                return;
            }

            var itemName = GetItemName(selectedContainerItem);
            successMessage = $"Removed {itemName} from container.";

            // Clear container item selection
            selectedContainerItemId = null;
            selectedContainerItem = null;

            // Refresh and re-open container panel
            var containerId = selectedContainer.Id;
            await LoadItemsAsync();

            var container = inventoryItems?.FirstOrDefault(i => i.Id == containerId);
            if (container != null)
            {
                OpenContainerPanel(container);
            }
            else
            {
                CloseContainerPanel();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error removing item: {ex.Message}";
        }
    }

    private static bool IsEquippableType(ItemType itemType)
    {
        // Only certain types can be equipped
        return itemType == ItemType.Weapon ||
               itemType == ItemType.Armor ||
               itemType == ItemType.Shield ||
               itemType == ItemType.Jewelry ||
               itemType == ItemType.Clothing;
    }

    private static bool IsSlotCompatible(EquipmentSlot itemSlot, EquipmentSlot targetSlot)
    {
        // TwoHand weapons can ONLY go in TwoHand slot
        if (itemSlot == EquipmentSlot.TwoHand)
        {
            return targetSlot == EquipmentSlot.TwoHand;
        }

        // OneHand weapons (MainHand or OffHand) can go in MainHand, OffHand, or TwoHand
        if (itemSlot == EquipmentSlot.MainHand || itemSlot == EquipmentSlot.OffHand)
        {
            return targetSlot == EquipmentSlot.MainHand ||
                   targetSlot == EquipmentSlot.OffHand ||
                   targetSlot == EquipmentSlot.TwoHand;
        }

        // Rings can go in any finger slot
        if (itemSlot.IsFingerSlot())
        {
            return targetSlot.IsFingerSlot();
        }

        // EquipmentSlot.None should not be equippable (safety check)
        if (itemSlot == EquipmentSlot.None)
        {
            return false;
        }

        // Otherwise must match exactly
        return itemSlot == targetSlot;
    }

    private bool IsValidTarget(EquipmentSlot slot)
    {
        if (selectedItem == null) return false;
        var template = GetTemplate(selectedItem.ItemTemplateId);
        if (template == null) return false;
        if (!IsEquippableType(template.ItemType)) return false;
        return IsSlotCompatible(template.EquipmentSlot, slot);
    }

    private async Task NotifyCharacterChanged()
    {
        if (OnCharacterChanged.HasDelegate)
        {
            await OnCharacterChanged.InvokeAsync();
        }
    }

    // Drop methods
    private async Task ConfirmDropItem()
    {
        if (selectedItem == null) return;

        try
        {
            ClearMessages();

            var itemName = GetItemName(selectedItem);
            var template = GetTemplate(selectedItem.ItemTemplateId);

            // Check if item can be dropped (curse check)
            if (!itemService.CanDropItem(Character!, selectedItem.Id))
            {
                errorMessage = itemService.GetDropBlockReason(Character!, selectedItem.Id)
                    ?? "This item cannot be dropped.";
                return;
            }

            // Check if this is a container with contents
            if (IsContainerItem(selectedItem))
            {
                var contents = GetContainerContents(selectedItem.Id);
                if (contents.Any())
                {
                    await ConfirmDropContainerWithContents(selectedItem, contents);
                    return;
                }
            }

            // For stackable items with quantity > 1, show quantity dialog
            if (template?.IsStackable == true && selectedItem.StackSize > 1)
            {
                await ShowDropQuantityDialog();
                return;
            }

            // Single item or non-stackable - simple confirmation
            var confirmed = await DialogService.Confirm(
                $"Are you sure you want to drop {itemName}? This cannot be undone.",
                "Drop Item",
                new ConfirmOptions
                {
                    OkButtonText = "Drop",
                    CancelButtonText = "Cancel"
                });

            if (confirmed == true)
            {
                await DropItem(selectedItem.Id);
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error dropping item: {ex.Message}";
        }
    }

    private async Task ConfirmDropContainerWithContents(CharacterItem container, List<CharacterItem> contents)
    {
        var containerName = GetItemName(container);
        var itemCount = contents.Count;
        var totalItems = contents.Sum(c => c.StackSize);

        var message = $"'{containerName}' contains {itemCount} item(s) ({totalItems} total). " +
                      "What would you like to do?";

        // Use custom dialog with three options
        var result = await DialogService.OpenAsync("Drop Container?", ds =>
            @<div>
                <p>@message</p>
                <div class="d-flex gap-2 justify-content-end mt-3">
                    <button class="btn btn-secondary" @onclick="() => ds.Close(false)">Cancel</button>
                    <button class="btn btn-outline-primary" @onclick='() => ds.Close("empty")'>Empty First</button>
                    <button class="btn btn-danger" @onclick='() => ds.Close("drop")'>Drop All</button>
                </div>
            </div>
        );

        if (result is string action)
        {
            if (action == "drop")
            {
                // Drop container with all contents
                // First drop all contents
                foreach (var item in contents)
                {
                    await itemService.RemoveItemFromInventoryAsync(Character!, item.Id);
                }
                // Then drop the container
                await DropItem(container.Id);
            }
            else if (action == "empty")
            {
                // Move all contents out of container
                foreach (var item in contents)
                {
                    await itemService.MoveToContainerAsync(Character!, item.Id, null);
                }
                successMessage = $"Emptied {containerName}. Select it again to drop.";
                await LoadItemsAsync();
                // Keep container selected
                selectedItem = inventoryItems?.FirstOrDefault(i => i.Id == container.Id);
                selectedItemId = container.Id;
                CloseContainerPanel();
            }
        }
    }

    private Task ShowDropQuantityDialog()
    {
        dropQuantity = selectedItem!.StackSize;  // Default to all
        showDropQuantityDialog = true;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private async Task ConfirmDropQuantity()
    {
        if (selectedItem == null || dropQuantity <= 0) return;

        showDropQuantityDialog = false;

        if (dropQuantity >= selectedItem.StackSize)
        {
            // Drop entire stack
            await DropItem(selectedItem.Id);
        }
        else
        {
            // Reduce quantity (update item, don't delete)
            await DropPartialStack(selectedItem.Id, dropQuantity);
        }
    }

    private void CancelDropQuantity()
    {
        showDropQuantityDialog = false;
        dropQuantity = 1;
    }

    private async Task DropItem(Guid itemId)
    {
        var item = inventoryItems?.FirstOrDefault(i => i.Id == itemId);
        var itemName = GetItemName(item);

        var result = await itemService.RemoveItemFromInventoryAsync(Character!, itemId);
        if (!result.Success)
        {
            errorMessage = result.ErrorMessage;
            return;
        }

        successMessage = $"Dropped {itemName}.";
        selectedItem = null;
        selectedItemId = null;
        await LoadItemsAsync();
        await NotifyCharacterChanged();
    }

    private async Task DropPartialStack(Guid itemId, int quantity)
    {
        var item = inventoryItems?.FirstOrDefault(i => i.Id == itemId);
        if (item == null) return;

        var itemName = GetItemName(item);

        // Update the item's stack size
        item.StackSize -= quantity;
        await itemDal.UpdateItemAsync(item);

        successMessage = $"Dropped {quantity}x {itemName}.";
        selectedItem = null;
        selectedItemId = null;
        await LoadItemsAsync();
        await NotifyCharacterChanged();
    }

    // ==========================================
    // Ammo Container Reload Methods
    // ==========================================

    /// <summary>
    /// Checks if the selected item is an ammo container with space available.
    /// </summary>
    private bool IsReloadableAmmoContainer(CharacterItem? item)
    {
        if (item == null) return false;
        var template = GetTemplate(item.ItemTemplateId);
        if (template == null) return false;

        // Check if it's an ammo container type
        if (template.ItemType != ItemType.AmmoContainer)
            return false;

        // Get container properties - may be null for legacy items
        var containerProps = AmmoContainerProperties.FromJson(template.CustomProperties);

        // Check container state for space available
        var containerState = AmmoContainerState.FromJson(item.CustomProperties);

        // Determine capacity from state or template properties
        int maxCapacity = containerState.MaxCapacity;
        if (maxCapacity == 0 && containerProps != null)
            maxCapacity = containerProps.Capacity;

        // If we still don't have capacity, assume it's reloadable (show button, let modal handle details)
        if (maxCapacity == 0)
            return true;

        return containerState.LoadedAmmo < maxCapacity;
    }

    /// <summary>
    /// Checks if the selected item is an ammo container with ammo loaded that can be unloaded.
    /// </summary>
    private bool IsUnloadableAmmoContainer(CharacterItem? item)
    {
        if (item == null) return false;
        var template = GetTemplate(item.ItemTemplateId);
        if (template == null) return false;

        // Check if it's an ammo container type
        if (template.ItemType != ItemType.AmmoContainer)
            return false;

        // Check container state for loaded ammo
        var containerState = AmmoContainerState.FromJson(item.CustomProperties);
        return containerState.LoadedAmmo > 0;
    }

    /// <summary>
    /// Gets loose ammo items compatible with the selected ammo container.
    /// </summary>
    private List<CharacterItem> GetCompatibleLooseAmmo(CharacterItem container)
    {
        if (inventoryItems == null) return new List<CharacterItem>();

        var template = GetTemplate(container.ItemTemplateId);
        if (template == null) return new List<CharacterItem>();

        // Get container properties - may be null for legacy items
        var containerProps = AmmoContainerProperties.FromJson(template.CustomProperties);
        var allowedTypes = containerProps?.GetAllowedAmmoTypes().ToList() ?? new List<string>();

        return inventoryItems.Where(item =>
        {
            // Skip items in containers
            if (item.ContainerItemId != null) return false;

            var itemTemplate = GetTemplate(item.ItemTemplateId);
            if (itemTemplate == null) return false;

            // Must be ammunition type
            if (itemTemplate.ItemType != ItemType.Ammunition) return false;

            var ammoProps = AmmunitionProperties.FromJson(itemTemplate.CustomProperties);

            // If no ammo properties, check if it's a stackable item (likely ammo)
            if (ammoProps == null)
            {
                // Fall back to checking if item is stackable ammo without explicit properties
                return itemTemplate.IsStackable;
            }

            // Must be loose ammo, not a container
            if (ammoProps.IsContainer) return false;

            // If container has no allowed types specified, accept any ammunition
            if (!allowedTypes.Any())
                return true;

            // Must be compatible ammo type
            if (string.IsNullOrEmpty(ammoProps.AmmoType)) return true; // Accept untyped ammo
            return allowedTypes.Contains(ammoProps.AmmoType, StringComparer.OrdinalIgnoreCase);
        }).ToList();
    }

    /// <summary>
    /// Opens the reload ammo container modal.
    /// </summary>
    private async Task OpenReloadAmmoContainerModal()
    {
        if (selectedItem == null) return;

        var availableAmmo = GetCompatibleLooseAmmo(selectedItem);
        if (!availableAmmo.Any())
        {
            errorMessage = "No compatible loose ammo available.";
            return;
        }

        var containerName = GetItemName(selectedItem);

        var result = await DialogService.OpenAsync<ReloadAmmoContainerModal>(
            "Reload Ammo Container",
            new Dictionary<string, object>
            {
                { "Container", selectedItem },
                { "ContainerName", containerName },
                { "AvailableAmmo", availableAmmo },
                { "AvailableAp", Character?.ActionPoints?.Available ?? 0 },
                { "AvailableFat", Character?.Fatigue?.Value ?? 0 }
            },
            new DialogOptions
            {
                Width = "400px",
                CloseDialogOnOverlayClick = true,
                ShowClose = true
            });

        if (result is ReloadAmmoContainerResult reloadResult)
        {
            await OnReloadAmmoContainerConfirm(reloadResult);
        }
    }

    /// <summary>
    /// Handles the reload ammo container confirmation.
    /// Costs 1 AP + 1 FAT (standard) or 2 AP (speed reload).
    /// </summary>
    private async Task OnReloadAmmoContainerConfirm(ReloadAmmoContainerResult result)
    {
        if (Character == null) return;

        ClearMessages();

        try
        {
            // Check AP cost based on reload type
            var apCost = result.ApCost;
            var fatCost = result.FatCost;

            if (Character.ActionPoints.Available < apCost)
            {
                errorMessage = $"Not enough AP to start reloading. Requires {apCost} AP.";
                return;
            }

            // Check for existing concentration effect
            var concentrationEffect = Character.GetConcentrationEffect();
            if (concentrationEffect != null)
            {
                var state = ConcentrationState.FromJson(concentrationEffect.BehaviorState);
                if (state != null)
                {
                    var confirmed = await ConcentrationBreakDialog.ShowAsync(
                        DialogService, state, concentrationEffect.Name);
                    if (!confirmed)
                        return;
                    ConcentrationBehavior.BreakConcentration(Character, "Started ammo container reload");
                }
            }

            // Spend AP and FAT based on reload type
            Character.ActionPoints.Available -= apCost;
            if (fatCost > 0)
            {
                Character.Fatigue.PendingDamage += fatCost;
            }

            // Create concentration effect for the reload
            var behaviorState = ConcentrationBehavior.CreateAmmoContainerReloadState(
                result.ContainerId,
                result.SourceItemId,
                result.RoundsToLoad,
                result.ContainerName ?? "Ammo Container",
                result.AmmoType);

            // Create the effect using CSLA child portal pattern
            var effect = await EffectPortal.CreateChildAsync(
                Threa.Dal.Dto.EffectType.Concentration,
                $"Reloading {result.ContainerName}",
                (string?)null, // location
                (int?)null,    // duration (handled by concentration system)
                behaviorState);

            effect.Source = "Player";
            effect.Description = $"Loading {result.RoundsToLoad} rounds ({result.DurationRounds} rounds)";

            Character.Effects.AddEffect(effect);
            await NotifyCharacterChanged();

            // Build cost description
            var costDesc = fatCost > 0 ? $"{apCost} AP, {fatCost} FAT" : $"{apCost} AP";
            successMessage = $"Started reloading {result.ContainerName} ({result.RoundsToLoad} rounds, {result.DurationRounds} round(s)). Cost: {costDesc}";
        }
        catch (Exception ex)
        {
            errorMessage = $"Error starting reload: {ex.Message}";
        }
    }

    // ==========================================
    // Ammo Container Unload Methods
    // ==========================================

    /// <summary>
    /// Opens the unload ammo container modal.
    /// </summary>
    private async Task OpenUnloadAmmoContainerModal()
    {
        if (selectedItem == null) return;

        var containerName = GetItemName(selectedItem);

        var result = await DialogService.OpenAsync<UnloadAmmoContainerModal>(
            "Unload Ammo Container",
            new Dictionary<string, object>
            {
                { "Container", selectedItem },
                { "ContainerName", containerName },
                { "AvailableAp", Character?.ActionPoints?.Available ?? 0 },
                { "AvailableFat", Character?.Fatigue?.Value ?? 0 }
            },
            new DialogOptions
            {
                Width = "400px",
                CloseDialogOnOverlayClick = true,
                ShowClose = true
            });

        if (result is UnloadAmmoContainerResult unloadResult)
        {
            await OnUnloadAmmoContainerConfirm(unloadResult);
        }
    }

    /// <summary>
    /// Handles the unload ammo container confirmation.
    /// Costs 1 AP + 1 FAT (standard) or 2 AP (no fatigue).
    /// </summary>
    private async Task OnUnloadAmmoContainerConfirm(UnloadAmmoContainerResult result)
    {
        if (Character == null) return;

        ClearMessages();

        try
        {
            // Check AP cost based on unload type
            var apCost = result.ApCost;
            var fatCost = result.FatCost;

            if (Character.ActionPoints.Available < apCost)
            {
                errorMessage = $"Not enough AP to start unloading. Requires {apCost} AP.";
                return;
            }

            // Check for existing concentration effect
            var concentrationEffect = Character.GetConcentrationEffect();
            if (concentrationEffect != null)
            {
                var state = ConcentrationState.FromJson(concentrationEffect.BehaviorState);
                if (state != null)
                {
                    var confirmed = await ConcentrationBreakDialog.ShowAsync(
                        DialogService, state, concentrationEffect.Name);
                    if (!confirmed)
                        return;
                    ConcentrationBehavior.BreakConcentration(Character, "Started ammo container unload");
                }
            }

            // Spend AP and FAT based on unload type
            Character.ActionPoints.Available -= apCost;
            if (fatCost > 0)
            {
                Character.Fatigue.PendingDamage += fatCost;
            }

            // Create concentration effect for the unload
            var behaviorState = ConcentrationBehavior.CreateAmmoContainerUnloadState(
                result.ContainerId,
                Character.Id,
                result.RoundsToUnload,
                result.ContainerName ?? "Ammo Container",
                result.AmmoType);

            // Create the effect using CSLA child portal pattern
            var effect = await EffectPortal.CreateChildAsync(
                Threa.Dal.Dto.EffectType.Concentration,
                $"Unloading {result.ContainerName}",
                (string?)null, // location
                (int?)null,    // duration (handled by concentration system)
                behaviorState);

            effect.Source = "Player";
            effect.Description = $"Unloading {result.RoundsToUnload} rounds ({result.DurationRounds} rounds)";

            Character.Effects.AddEffect(effect);
            await NotifyCharacterChanged();

            // Build cost description
            var costDesc = fatCost > 0 ? $"{apCost} AP, {fatCost} FAT" : $"{apCost} AP";
            successMessage = $"Started unloading {result.ContainerName} ({result.RoundsToUnload} rounds, {result.DurationRounds} round(s)). Cost: {costDesc}";
        }
        catch (Exception ex)
        {
            errorMessage = $"Error starting unload: {ex.Message}";
        }
    }

    // ==========================================
    // Weapon Reload/Unload Methods
    // ==========================================

    /// <summary>
    /// Checks if the selected item is a ranged weapon with space for ammo.
    /// Weapon doesn't need to be equipped to reload from inventory.
    /// </summary>
    private bool IsReloadableWeapon(CharacterItem? item)
    {
        if (item == null) return false;
        var template = GetTemplate(item.ItemTemplateId);
        if (template == null) return false;

        // Check if it's a ranged weapon
        var weaponProps = RangedWeaponProperties.FromJson(template.CustomProperties);
        if (weaponProps == null || !weaponProps.IsRangedWeapon)
            return false;

        // Thrown weapons don't reload (they are consumed)
        if (weaponProps.IsThrown)
            return false;

        // Check if weapon has capacity
        if (weaponProps.TotalCapacity <= 0)
            return false;

        // Check current ammo state
        var ammoState = WeaponAmmoState.FromJson(item.CustomProperties);
        return ammoState.TotalAvailable < weaponProps.TotalCapacity;
    }

    /// <summary>
    /// Checks if the selected item is a ranged weapon with ammo that can be unloaded.
    /// Weapon doesn't need to be equipped to unload from inventory.
    /// </summary>
    private bool IsUnloadableWeapon(CharacterItem? item)
    {
        if (item == null) return false;
        var template = GetTemplate(item.ItemTemplateId);
        if (template == null) return false;

        // Check if it's a ranged weapon
        var weaponProps = RangedWeaponProperties.FromJson(template.CustomProperties);
        if (weaponProps == null || !weaponProps.IsRangedWeapon)
            return false;

        // Thrown weapons don't unload
        if (weaponProps.IsThrown)
            return false;

        // Check if weapon has ammo loaded
        var ammoState = WeaponAmmoState.FromJson(item.CustomProperties);
        return ammoState.TotalAvailable > 0;
    }

    /// <summary>
    /// Gets compatible ammo for a weapon from inventory.
    /// Includes both loose ammo and loaded magazines.
    /// </summary>
    private List<CharacterItem> GetCompatibleAmmoForWeapon(CharacterItem weapon)
    {
        if (inventoryItems == null) return new List<CharacterItem>();

        var template = GetTemplate(weapon.ItemTemplateId);
        if (template == null) return new List<CharacterItem>();

        var weaponProps = RangedWeaponProperties.FromJson(template.CustomProperties);
        if (weaponProps == null) return new List<CharacterItem>();

        var compatibleAmmo = new List<CharacterItem>();

        foreach (var item in inventoryItems)
        {
            // Skip items in containers
            if (item.ContainerItemId != null) continue;

            // Skip the weapon itself
            if (item.Id == weapon.Id) continue;

            var itemTemplate = GetTemplate(item.ItemTemplateId);
            if (itemTemplate == null) continue;

            // Check if it's loose ammo
            if (itemTemplate.ItemType == ItemType.Ammunition)
            {
                // Only if weapon accepts loose ammo
                if (!weaponProps.AcceptsLooseAmmo)
                    continue;

                var ammoProps = AmmunitionProperties.FromJson(itemTemplate.CustomProperties);
                if (ammoProps?.IsContainer == true)
                    continue; // Skip ammo containers

                // Check ammo type compatibility
                if (!string.IsNullOrEmpty(weaponProps.AmmoType) &&
                    !string.IsNullOrEmpty(ammoProps?.AmmoType) &&
                    !weaponProps.AmmoType.Equals(ammoProps.AmmoType, StringComparison.OrdinalIgnoreCase))
                    continue;

                compatibleAmmo.Add(item);
            }
            // Check if it's a loaded magazine
            else if (itemTemplate.ItemType == ItemType.AmmoContainer)
            {
                var containerState = AmmoContainerState.FromJson(item.CustomProperties);
                if (containerState.LoadedAmmo <= 0)
                    continue; // Empty magazine

                var containerProps = AmmoContainerProperties.FromJson(itemTemplate.CustomProperties);

                // Check ammo type compatibility
                var containerAmmoType = containerState.AmmoType ?? containerProps?.AllowedAmmoTypes;
                if (!string.IsNullOrEmpty(weaponProps.AmmoType) &&
                    !string.IsNullOrEmpty(containerAmmoType) &&
                    !weaponProps.AmmoType.Equals(containerAmmoType, StringComparison.OrdinalIgnoreCase))
                    continue;

                compatibleAmmo.Add(item);
            }
        }

        return compatibleAmmo;
    }

    /// <summary>
    /// Opens the reload weapon modal.
    /// </summary>
    private async Task OpenReloadWeaponModal()
    {
        if (selectedItem == null) return;

        var availableAmmo = GetCompatibleAmmoForWeapon(selectedItem);
        if (!availableAmmo.Any())
        {
            errorMessage = "No compatible ammo available.";
            return;
        }

        var weaponName = GetItemName(selectedItem);

        var result = await DialogService.OpenAsync<ReloadWeaponModal>(
            "Reload Weapon",
            new Dictionary<string, object>
            {
                { "Weapon", selectedItem },
                { "WeaponName", weaponName },
                { "AvailableAmmo", availableAmmo },
                { "AvailableAp", Character?.ActionPoints?.Available ?? 0 },
                { "AvailableFat", Character?.Fatigue?.Value ?? 0 }
            },
            new DialogOptions
            {
                Width = "400px",
                CloseDialogOnOverlayClick = true,
                ShowClose = true
            });

        if (result is ReloadWeaponResult reloadResult)
        {
            await OnReloadWeaponConfirm(reloadResult);
        }
    }

    /// <summary>
    /// Handles the reload weapon confirmation.
    /// Costs 1 AP + 1 FAT (standard) or 2 AP (speed reload).
    /// </summary>
    private async Task OnReloadWeaponConfirm(ReloadWeaponResult result)
    {
        if (Character == null) return;

        ClearMessages();

        try
        {
            // Check AP cost based on reload type
            var apCost = result.ApCost;
            var fatCost = result.FatCost;

            if (Character.ActionPoints.Available < apCost)
            {
                errorMessage = $"Not enough AP to start reloading. Requires {apCost} AP.";
                return;
            }

            // Check for existing concentration effect
            var concentrationEffect = Character.GetConcentrationEffect();
            if (concentrationEffect != null)
            {
                var state = ConcentrationState.FromJson(concentrationEffect.BehaviorState);
                if (state != null)
                {
                    var confirmed = await ConcentrationBreakDialog.ShowAsync(
                        DialogService, state, concentrationEffect.Name);
                    if (!confirmed)
                        return;
                    ConcentrationBehavior.BreakConcentration(Character, "Started weapon reload");
                }
            }

            // Spend AP and FAT based on reload type
            Character.ActionPoints.Available -= apCost;
            if (fatCost > 0)
            {
                Character.Fatigue.PendingDamage += fatCost;
            }

            // Create concentration effect for the reload
            var behaviorState = ConcentrationBehavior.CreateWeaponReloadState(
                result.WeaponItemId,
                result.SourceItemId,
                result.RoundsToLoad,
                result.IsLooseAmmo,
                result.AmmoType,
                result.WeaponName);

            // Create the effect using CSLA child portal pattern
            var effect = await EffectPortal.CreateChildAsync(
                Threa.Dal.Dto.EffectType.Concentration,
                $"Reloading {result.WeaponName}",
                (string?)null, // location
                (int?)null,    // duration (handled by concentration system)
                behaviorState);

            effect.Source = "Player";
            effect.Description = $"Loading {result.RoundsToLoad} rounds ({result.DurationRounds} rounds)";

            Character.Effects.AddEffect(effect);
            await NotifyCharacterChanged();

            // Build cost description
            var costDesc = fatCost > 0 ? $"{apCost} AP, {fatCost} FAT" : $"{apCost} AP";
            successMessage = $"Started reloading {result.WeaponName} ({result.RoundsToLoad} rounds, {result.DurationRounds} round(s)). Cost: {costDesc}";
        }
        catch (Exception ex)
        {
            errorMessage = $"Error starting reload: {ex.Message}";
        }
    }

    /// <summary>
    /// Opens the unload weapon modal.
    /// </summary>
    private async Task OpenUnloadWeaponModal()
    {
        if (selectedItem == null) return;

        var weaponName = GetItemName(selectedItem);

        var result = await DialogService.OpenAsync<UnloadWeaponModal>(
            "Unload Weapon",
            new Dictionary<string, object>
            {
                { "Weapon", selectedItem },
                { "WeaponName", weaponName },
                { "AvailableAp", Character?.ActionPoints?.Available ?? 0 },
                { "AvailableFat", Character?.Fatigue?.Value ?? 0 }
            },
            new DialogOptions
            {
                Width = "400px",
                CloseDialogOnOverlayClick = true,
                ShowClose = true
            });

        if (result is UnloadWeaponResult unloadResult)
        {
            await OnUnloadWeaponConfirm(unloadResult);
        }
    }

    /// <summary>
    /// Handles the unload weapon confirmation.
    /// Costs 1 AP + 1 FAT (standard) or 2 AP (no fatigue).
    /// Unload takes half the time of reload.
    /// </summary>
    private async Task OnUnloadWeaponConfirm(UnloadWeaponResult result)
    {
        if (Character == null) return;

        ClearMessages();

        try
        {
            // Check AP cost based on unload type
            var apCost = result.ApCost;
            var fatCost = result.FatCost;

            if (Character.ActionPoints.Available < apCost)
            {
                errorMessage = $"Not enough AP to start unloading. Requires {apCost} AP.";
                return;
            }

            // Check for existing concentration effect
            var concentrationEffect = Character.GetConcentrationEffect();
            if (concentrationEffect != null)
            {
                var state = ConcentrationState.FromJson(concentrationEffect.BehaviorState);
                if (state != null)
                {
                    var confirmed = await ConcentrationBreakDialog.ShowAsync(
                        DialogService, state, concentrationEffect.Name);
                    if (!confirmed)
                        return;
                    ConcentrationBehavior.BreakConcentration(Character, "Started weapon unload");
                }
            }

            // Spend AP and FAT based on unload type
            Character.ActionPoints.Available -= apCost;
            if (fatCost > 0)
            {
                Character.Fatigue.PendingDamage += fatCost;
            }

            // Create concentration effect for the unload
            var behaviorState = ConcentrationBehavior.CreateWeaponUnloadState(
                result.WeaponItemId,
                Character.Id,
                result.RoundsToUnload,
                result.WeaponName ?? "Weapon",
                result.AmmoType);

            // Create the effect using CSLA child portal pattern
            var effect = await EffectPortal.CreateChildAsync(
                Threa.Dal.Dto.EffectType.Concentration,
                $"Unloading {result.WeaponName}",
                (string?)null, // location
                (int?)null,    // duration (handled by concentration system)
                behaviorState);

            effect.Source = "Player";
            effect.Description = $"Unloading {result.RoundsToUnload} rounds ({result.DurationRounds} rounds)";

            Character.Effects.AddEffect(effect);
            await NotifyCharacterChanged();

            // Build cost description
            var costDesc = fatCost > 0 ? $"{apCost} AP, {fatCost} FAT" : $"{apCost} AP";
            successMessage = $"Started unloading {result.WeaponName} ({result.RoundsToUnload} rounds, {result.DurationRounds} round(s)). Cost: {costDesc}";
        }
        catch (Exception ex)
        {
            errorMessage = $"Error starting unload: {ex.Message}";
        }
    }

    private string GetItemTooltip(CharacterItem item)
    {
        var name = GetItemDisplayName(item);
        var template = GetTemplate(item.ItemTemplateId);
        
        if (template == null)
            return name;
        
        var parts = new List<string> { name };
        
        // Add weight
        var weight = template.Weight;
        if (item.StackSize > 1)
        {
            var totalWeight = weight * item.StackSize;
            parts.Add($"Weight: {totalWeight:0.#} lbs (x{item.StackSize})");
        }
        else
        {
            parts.Add($"Weight: {weight:0.#} lbs");
        }
        
        // Add value
        if (template.Value > 0)
        {
            parts.Add($"Value: {FormatCurrency(template.Value)}");
        }
        
        return string.Join(" | ", parts);
    }

    private string FormatCurrency(int copperValue)
    {
        if (copperValue >= 8000)
        {
            var pp = copperValue / 8000;
            var remainder = copperValue % 8000;
            if (remainder == 0)
                return $"{pp} pp";
            return $"{pp} pp, {FormatCurrency(remainder)}";
        }
        if (copperValue >= 400)
        {
            var gp = copperValue / 400;
            var remainder = copperValue % 400;
            if (remainder == 0)
                return $"{gp} gp";
            return $"{gp} gp, {FormatCurrency(remainder)}";
        }
        if (copperValue >= 20)
        {
            var sp = copperValue / 20;
            var remainder = copperValue % 20;
            if (remainder == 0)
                return $"{sp} sp";
            return $"{sp} sp, {FormatCurrency(remainder)}";
        }
        return $"{copperValue} cp";
    }
}
