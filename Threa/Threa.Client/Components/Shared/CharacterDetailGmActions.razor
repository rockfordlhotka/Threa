@* GM Actions tab - damage, healing, effects, and character management *@

@using GameMechanics
@using GameMechanics.Effects.Behaviors
@using GameMechanics.Messaging
@using GameMechanics.Time
@using Threa.Dal.Dto
@using Radzen

@inject IDataPortal<CharacterEdit> characterPortal
@inject ITimeEventPublisher TimeEventPublisher
@inject DialogService DialogService
@inject IGameTimeFormatService TimeFormat

<div class="row g-3">
    <!-- Health Management (unified damage/healing) -->
    <div class="col-md-6">
        <div class="card h-100">
            <div class="card-header text-white" style="transition: background-color 0.2s ease; background-color: @(healthMode == HealthMode.Damage ? "var(--bs-danger)" : "var(--bs-success)");">
                <strong>
                    <i class="bi @(healthMode == HealthMode.Damage ? "bi-heart-pulse" : "bi-bandaid") me-1"></i>
                    @(healthMode == HealthMode.Damage ? "Apply Damage" : "Apply Healing")
                </strong>
            </div>
            <div class="card-body">
                <div class="btn-group w-100 mb-3" role="group">
                    <button class="btn @(healthMode == HealthMode.Damage ? "btn-danger" : "btn-outline-danger")"
                            @onclick="() => SetMode(HealthMode.Damage)">
                        <i class="bi bi-dash-circle me-1"></i>Damage
                    </button>
                    <button class="btn @(healthMode == HealthMode.Healing ? "btn-success" : "btn-outline-success")"
                            @onclick="() => SetMode(HealthMode.Healing)">
                        <i class="bi bi-plus-circle me-1"></i>Healing
                    </button>
                </div>
                <div class="mb-3">
                    <label class="form-label">Amount</label>
                    <input type="number" class="form-control" @bind="healthAmount" min="1" />
                </div>
                <div class="d-flex gap-2">
                    <button class="btn @(healthMode == HealthMode.Damage ? "btn-danger" : "btn-success") flex-grow-1"
                            @onclick='() => ApplyToPool("FAT")' disabled="@isProcessing">
                        <i class="bi @(healthMode == HealthMode.Damage ? "bi-dash-circle" : "bi-plus-circle") me-1"></i>FAT
                    </button>
                    <button class="btn @(healthMode == HealthMode.Damage ? "btn-danger" : "btn-success") flex-grow-1"
                            @onclick='() => ApplyToPool("VIT")' disabled="@isProcessing">
                        <i class="bi @(healthMode == HealthMode.Damage ? "bi-dash-circle" : "bi-plus-circle") me-1"></i>VIT
                    </button>
                </div>

                @if (showOverflowWarning)
                {
                    <div class="alert @(healthMode == HealthMode.Damage ? "alert-warning" : "alert-info") mt-3 mb-0">
                        <i class="bi bi-exclamation-triangle me-1"></i>
                        @overflowWarningMessage
                        <div class="mt-2 d-flex gap-2 flex-wrap">
                            <button class="btn @(healthMode == HealthMode.Damage ? "btn-warning" : "btn-info") btn-sm"
                                    @onclick="ConfirmApply" disabled="@isProcessing">
                                Apply Anyway
                            </button>
                            @if (healthMode == HealthMode.Damage && pendingPool == "VIT" && woundDamageExcess > 0)
                            {
                                <button class="btn btn-danger btn-sm"
                                        @onclick="ApplyAndAddWound" disabled="@isProcessing">
                                    <i class="bi bi-bandaid me-1"></i>Apply + Add Wound
                                </button>
                            }
                            <button class="btn btn-secondary btn-sm" @onclick="CancelApply">
                                Cancel
                            </button>
                        </div>
                    </div>
                }
            </div>
        </div>
    </div>

    <!-- Right Column: Wounds and Effects -->
    <div class="col-md-6 d-flex flex-column gap-3">
        <!-- Wounds -->
        <div class="card">
            <div class="card-header bg-danger text-white d-flex justify-content-between align-items-center">
                <strong><i class="bi bi-bandaid me-1"></i>Wounds</strong>
                @if (TotalWoundCount > 0)
                {
                    <span class="badge bg-light text-danger">@TotalWoundCount</span>
                }
            </div>
            <div class="card-body">
                @if (TotalWoundCount == 0)
                {
                    <p class="text-muted small mb-2">No active wounds</p>
                }
                else
                {
                    <!-- AS Penalty Summary -->
                    <div class="alert alert-warning py-2 mb-2">
                        <div class="d-flex justify-content-between align-items-center">
                            <span><i class="bi bi-arrow-down-circle me-1"></i>Total AS Penalty</span>
                            <strong class="text-danger">@TotalWoundPenalty</strong>
                        </div>
                    </div>

                    <!-- Wound Summary by Location -->
                    <div class="mb-2" style="max-height: 150px; overflow-y: auto;">
                        @foreach (var wound in GetActiveWounds())
                        {
                            var woundState = WoundState.Deserialize(wound.BehaviorState);
                            var healingTime = GetWoundHealingTime(wound);
                            var currentSeverity = woundState.CurrentSeverity ?? woundState.Severity;
                            var originalSeverity = woundState.OriginalSeverity ?? woundState.Severity;
                            <div class="p-2 mb-1 rounded border" style="border-color: var(--color-card-border);">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div class="d-flex align-items-center gap-2">
                                        <i class="bi @GetLocationIcon(wound.Location) text-danger"></i>
                                        <div>
                                            <span class="small">@FormatLocation(wound.Location ?? "Unknown")</span>
                                            @if (!string.IsNullOrEmpty(currentSeverity))
                                            {
                                                <br />
                                                <span class="badge @GetSeverityBadgeClass(currentSeverity)" style="font-size: 0.65rem;">
                                                    @currentSeverity
                                                </span>
                                                @if (currentSeverity != originalSeverity)
                                                {
                                                    <small class="text-muted ms-1">(was @originalSeverity)</small>
                                                }
                                            }
                                        </div>
                                    </div>
                                    <div class="d-flex align-items-center gap-1">
                                        @if (woundState.SeriousWounds > 0)
                                        {
                                            <span class="badge bg-danger" title="Serious wounds">
                                                <i class="bi bi-x-circle"></i> @woundState.SeriousWounds
                                            </span>
                                        }
                                        @if (woundState.LightWounds > 0)
                                        {
                                            <span class="badge bg-warning text-dark" title="Light wounds">
                                                <i class="bi bi-dash-circle"></i> @woundState.LightWounds
                                            </span>
                                        }
                                        @if (woundState.IsCrippled)
                                        {
                                            <span class="badge bg-dark">CRIPPLED</span>
                                        }
                                        else if (woundState.IsDisabled)
                                        {
                                            <span class="badge bg-secondary">Disabled</span>
                                        }
                                    </div>
                                </div>
                                @if (healingTime.HasValue)
                                {
                                    <div class="d-flex justify-content-between align-items-center mt-1 small">
                                        <span class="text-muted"><i class="bi bi-bandaid me-1"></i>Heals in:</span>
                                        <span class="badge @GetHealingTimeBadgeClass(healingTime.Value)">
                                            @TimeFormat.FormatRemaining(healingTime.Value)
                                        </span>
                                    </div>
                                }
                                else
                                {
                                    <div class="mt-1 small text-muted">
                                        <i class="bi bi-infinity me-1"></i>Manual healing required
                                    </div>
                                }
                            </div>
                        }
                    </div>
                }
                <button class="btn btn-outline-danger btn-sm w-100" @onclick="OpenWoundManagement" disabled="@isProcessing">
                    <i class="bi bi-bandaid me-1"></i>Manage Wounds
                </button>
            </div>
        </div>

        <!-- Effects -->
        <div class="card">
            <div class="card-header bg-info text-white d-flex justify-content-between align-items-center">
                <strong><i class="bi bi-stars me-1"></i>Effects</strong>
                @{
                    var effectCount = Character?.Effects.Count(e => e.EffectType != EffectType.Wound) ?? 0;
                }
                @if (effectCount > 0)
                {
                    <span class="badge bg-light text-info">@effectCount</span>
                }
            </div>
            <div class="card-body">
                @if (effectCount == 0)
                {
                    <p class="text-muted small mb-2">No active effects</p>
                }
                else
                {
                    <!-- Effect Summary Cards -->
                    <div class="mb-2" style="max-height: 200px; overflow-y: auto;">
                        @foreach (var effect in GetActiveEffects())
                        {
                            <div class="d-flex justify-content-between align-items-center p-2 mb-1 rounded @GetEffectItemClass(effect)">
                                <div class="d-flex align-items-center gap-2">
                                    <EffectIcon EffectType="@effect.EffectType.ToString()"
                                                EffectName="@effect.Name"
                                                Stacks="@(effect.CurrentStacks > 1 ? effect.CurrentStacks : null)"
                                                Color="@GetEffectIconColor(effect)" />
                                    <div>
                                        <span class="small fw-bold">@effect.Name</span>
                                        @if (!string.IsNullOrEmpty(effect.Source))
                                        {
                                            <br /><small class="text-muted">@effect.Source</small>
                                        }
                                    </div>
                                </div>
                                <div class="text-end">
                                    @{
                                        var remainingSeconds = GetRemainingSeconds(effect);
                                    }
                                    @if (remainingSeconds.HasValue)
                                    {
                                        <span class="badge @GetDurationBadgeClass(remainingSeconds.Value)">
                                            @TimeFormat.FormatRemaining(remainingSeconds.Value)
                                        </span>
                                    }
                                    else
                                    {
                                        <span class="badge bg-secondary"><i class="bi bi-infinity"></i></span>
                                    }
                                </div>
                            </div>
                        }
                    </div>
                }
                <button class="btn btn-outline-info btn-sm w-100" @onclick="OpenEffectManagement" disabled="@isProcessing">
                    <i class="bi bi-stars me-1"></i>Manage Effects
                </button>
            </div>
        </div>
    </div>
</div>

@* Feedback messages *@
@if (!string.IsNullOrEmpty(feedbackMessage))
{
    <div class="alert @feedbackClass mt-3 alert-dismissible fade show" role="alert">
        <i class="bi @feedbackIcon me-1"></i>
        @feedbackMessage
        <button type="button" class="btn-close" @onclick="() => feedbackMessage = null"></button>
    </div>
}


@code {
    [Parameter]
    public CharacterEdit? Character { get; set; }

    [Parameter]
    public int CharacterId { get; set; }

    [Parameter]
    public Guid TableId { get; set; }

    [Parameter]
    public EventCallback OnCharacterUpdated { get; set; }

    // Health mode enum and state
    private enum HealthMode { Damage, Healing }
    private HealthMode healthMode = HealthMode.Damage;
    private int healthAmount = 1;
    private bool showOverflowWarning;
    private string overflowWarningMessage = "";
    private string pendingPool = "";
    private int woundDamageExcess;

    // General state
    private bool isProcessing;

    // Feedback
    private string? feedbackMessage;
    private string feedbackClass = "alert-info";
    private string feedbackIcon = "bi-info-circle";

    // Body locations with their icons
    private static readonly Dictionary<string, string> BodyLocations = new()
    {
        { "Head", "bi-emoji-neutral" },
        { "Torso", "bi-person" },
        { "LeftArm", "bi-hand-index" },
        { "RightArm", "bi-hand-index" },
        { "LeftLeg", "bi-arrow-down" },
        { "RightLeg", "bi-arrow-down" }
    };

    // Wound helpers
    private int TotalWoundCount => Character?.Effects.TotalWoundCount ?? 0;

    private int TotalWoundPenalty
    {
        get
        {
            if (Character?.Effects == null) return 0;

            var woundEffects = Character.Effects.GetEffectsByType(EffectType.Wound).ToList();
            if (!woundEffects.Any()) return 0;

            return woundEffects.Sum(wound =>
            {
                var modifiers = wound.GetAbilityScoreModifiers("AnySkill", "AnyAttr", 0);
                return modifiers.Sum(m => m.Value);
            });
        }
    }

    private WoundState? GetWoundStateForLocation(string location) =>
        Character?.Effects.GetWoundState(location);

    private IEnumerable<EffectRecord> GetActiveWounds()
    {
        if (Character?.Effects == null) return Enumerable.Empty<EffectRecord>();
        return Character.Effects
            .Where(e => e.EffectType == EffectType.Wound && e.IsActive)
            .OrderBy(e => e.Location);
    }

    private string GetLocationIcon(string? location) => location switch
    {
        "Head" => "bi-emoji-neutral",
        "Torso" => "bi-person",
        "LeftArm" or "RightArm" => "bi-hand-index",
        "LeftLeg" or "RightLeg" => "bi-arrow-down",
        _ => "bi-bandaid"
    };

    private long? GetWoundHealingTime(EffectRecord wound)
    {
        // Use EffectRecord's ExpiresAtEpochSeconds (preferred) or legacy WoundState.ExpiryTimeSeconds
        long? expiryTime = wound.ExpiresAtEpochSeconds;
        if (!expiryTime.HasValue && !string.IsNullOrEmpty(wound.BehaviorState))
        {
            var state = WoundState.Deserialize(wound.BehaviorState);
            expiryTime = state.ExpiryTimeSeconds;
        }

        if (!expiryTime.HasValue) return null;

        var currentGameTime = Character?.CurrentGameTimeSeconds ?? 0;
        var remaining = expiryTime.Value - currentGameTime;
        return remaining > 0 ? remaining : 0;
    }

    private string GetHealingTimeBadgeClass(long remainingSeconds)
    {
        // Use different colors based on how soon healing will occur
        if (remainingSeconds < 60) return "bg-success"; // Less than a minute - healing soon
        if (remainingSeconds < 600) return "bg-info"; // Less than 10 minutes
        if (remainingSeconds < 3600) return "bg-secondary"; // Less than an hour
        return "bg-secondary"; // Longer duration
    }

    private string GetSeverityBadgeClass(string? severity) => severity switch
    {
        "Critical" => "bg-danger",
        "Severe" => "bg-warning text-dark",
        "Moderate" => "bg-info",
        "Minor" => "bg-secondary",
        _ => "bg-secondary"
    };

    private string FormatLocation(string location) => location switch
    {
        "LeftArm" => "Left Arm",
        "RightArm" => "Right Arm",
        "LeftLeg" => "Left Leg",
        "RightLeg" => "Right Leg",
        _ => location
    };

    // Effect helpers
    private IEnumerable<EffectRecord> GetActiveEffects()
    {
        if (Character?.Effects == null) return Enumerable.Empty<EffectRecord>();
        return Character.Effects
            .Where(e => e.EffectType != EffectType.Wound && e.IsActive)
            .OrderBy(e => e.EffectType)
            .ThenBy(e => e.Name);
    }

    private string GetEffectItemClass(EffectRecord effect) => effect.EffectType switch
    {
        EffectType.Buff => "bg-success bg-opacity-10",
        EffectType.Debuff or EffectType.Poison or EffectType.Disease => "bg-danger bg-opacity-10",
        EffectType.Condition => "bg-purple bg-opacity-10",
        EffectType.SpellEffect => "bg-primary bg-opacity-10",
        EffectType.Concentration => "bg-info bg-opacity-10",
        _ => "bg-light text-dark"
    };

    private string GetEffectIconColor(EffectRecord effect) => effect.EffectType switch
    {
        EffectType.Buff => "#198754",
        EffectType.Debuff or EffectType.Poison => "#dc3545",
        EffectType.Disease => "#6f42c1",
        EffectType.Condition => "#ffc107",
        EffectType.SpellEffect => "#0d6efd",
        EffectType.ItemEffect => "#20c997",
        _ => "#6c757d"
    };

    private long? GetRemainingSeconds(EffectRecord effect)
    {
        // For concentration effects, calculate remaining from behavior state
        if (effect.EffectType == EffectType.Concentration && !string.IsNullOrEmpty(effect.BehaviorState))
        {
            var state = ConcentrationState.FromJson(effect.BehaviorState);
            if (state != null)
            {
                var remainingRounds = state.TotalRequired - state.CurrentProgress;
                return remainingRounds * 3; // 3 seconds per round
            }
        }

        if (!effect.ExpiresAtEpochSeconds.HasValue) return null;
        var currentGameTime = Character?.CurrentGameTimeSeconds ?? 0;
        var remaining = effect.ExpiresAtEpochSeconds.Value - currentGameTime;
        return remaining > 0 ? remaining : 0;
    }

    private string GetDurationBadgeClass(long remainingSeconds)
    {
        if (remainingSeconds < 60)
        {
            var rounds = remainingSeconds / 3;
            return rounds <= 3 ? "bg-danger" : rounds <= 10 ? "bg-warning text-dark" : "bg-info";
        }
        if (remainingSeconds < 600) return "bg-info";
        if (remainingSeconds < 3600) return "bg-info";
        return "bg-secondary";
    }

    private void SetMode(HealthMode mode)
    {
        healthMode = mode;
        showOverflowWarning = false; // Clear any pending warning on mode change
        woundDamageExcess = 0;
    }

    private async Task ApplyToPool(string pool)
    {
        if (Character == null) return;
        pendingPool = pool;

        if (healthMode == HealthMode.Damage)
        {
            if (pool == "FAT")
            {
                // Check FAT overflow to VIT
                var projectedFat = Character.Fatigue.Value - Character.Fatigue.PendingDamage - healthAmount;
                if (projectedFat < 0)
                {
                    var overflow = Math.Abs(projectedFat);
                    overflowWarningMessage = $"This will exceed FAT capacity. {overflow} points will cascade to VIT pending damage.";
                    showOverflowWarning = true;
                    return;
                }
            }
            else if (pool == "VIT")
            {
                // Check VIT bounds - warn if damage would exceed current VIT
                var projectedVit = Character.Vitality.Value - Character.Vitality.PendingDamage - healthAmount;
                if (projectedVit < 0)
                {
                    var excess = Math.Abs(projectedVit);
                    woundDamageExcess = excess;
                    overflowWarningMessage = $"This will exceed VIT capacity. {excess} points of damage beyond VIT may result in wounds.";
                    showOverflowWarning = true;
                    return;
                }
            }
        }

        if (healthMode == HealthMode.Healing)
        {
            // Check overheal for both FAT and VIT
            var currentValue = pool == "FAT" ? Character.Fatigue.Value : Character.Vitality.Value;
            var pendingHealing = pool == "FAT" ? Character.Fatigue.PendingHealing : Character.Vitality.PendingHealing;
            var maxValue = pool == "FAT" ? Character.Fatigue.BaseValue : Character.Vitality.BaseValue;
            var projectedValue = currentValue + pendingHealing + healthAmount;

            if (projectedValue > maxValue)
            {
                var overheal = projectedValue - maxValue;
                overflowWarningMessage = $"This will exceed max {pool}. {overheal} points of temporary overheal will be applied.";
                showOverflowWarning = true;
                return;
            }
        }

        await ExecuteApply();
    }

    private async Task ConfirmApply()
    {
        showOverflowWarning = false;
        await ExecuteApply();
    }

    private void CancelApply()
    {
        showOverflowWarning = false;
        pendingPool = "";
        woundDamageExcess = 0;
    }

    private async Task ExecuteApply()
    {
        if (Character == null || string.IsNullOrEmpty(pendingPool)) return;
        isProcessing = true;

        try
        {
            var character = await characterPortal.FetchAsync(CharacterId);

            if (healthMode == HealthMode.Damage)
            {
                if (pendingPool == "FAT")
                    character.Fatigue.PendingDamage += healthAmount;
                else
                    character.Vitality.PendingDamage += healthAmount;
            }
            else
            {
                if (pendingPool == "FAT")
                    character.Fatigue.PendingHealing += healthAmount;
                else
                    character.Vitality.PendingHealing += healthAmount;
            }

            await characterPortal.UpdateAsync(character);

            var updateType = healthMode == HealthMode.Damage
                ? CharacterUpdateType.Damage
                : CharacterUpdateType.Healing;
            var action = healthMode == HealthMode.Damage ? "damage" : "healing";

            await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = updateType,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"{healthAmount} {pendingPool} {action}"
            });

            ShowFeedback($"Saved: {healthAmount} {pendingPool} {action} applied", "alert-success", "bi-check-circle");
            await OnCharacterUpdated.InvokeAsync();
        }
        catch (Exception ex)
        {
            ShowFeedback($"Error saving: {ex.Message}", "alert-danger", "bi-exclamation-triangle");
        }
        finally
        {
            isProcessing = false;
            pendingPool = "";
            woundDamageExcess = 0;
        }
    }

    private async Task ApplyAndAddWound()
    {
        showOverflowWarning = false;

        // First apply the damage
        await ExecuteApply();

        // Then open wound form modal
        var result = await DialogService.OpenAsync<WoundFormModal>(
            "Add Wound (VIT Exceeded)",
            new Dictionary<string, object>
            {
                { "Character", Character! },
                { "CharacterId", CharacterId },
                { "TableId", TableId }
            },
            new DialogOptions { Width = "500px", CloseDialogOnOverlayClick = true });

        if (result == true)
        {
            await OnCharacterUpdated.InvokeAsync();
        }

        woundDamageExcess = 0;
    }

    private async Task OpenEffectManagement()
    {
        var result = await DialogService.OpenAsync<EffectManagementModal>(
            "Manage Effects",
            new Dictionary<string, object>
            {
                { "Character", Character! },
                { "CharacterId", CharacterId },
                { "TableId", TableId }
            },
            new DialogOptions
            {
                Width = "800px",
                Height = "600px",
                CloseDialogOnOverlayClick = true
            });

        if (result is true)
        {
            await OnCharacterUpdated.InvokeAsync();
        }
    }

    private void ShowFeedback(string message, string alertClass, string icon = "bi-check-circle")
    {
        feedbackMessage = message;
        feedbackClass = alertClass;
        feedbackIcon = icon;
    }

    private async Task OpenWoundManagement()
    {
        var result = await DialogService.OpenAsync<WoundManagementModal>(
            "Manage Wounds",
            new Dictionary<string, object>
            {
                { "Character", Character! },
                { "CharacterId", CharacterId },
                { "TableId", TableId }
            },
            new DialogOptions
            {
                Width = "700px",
                Height = "500px",
                CloseDialogOnOverlayClick = true
            });

        // Refresh character data when modal closes
        await OnCharacterUpdated.InvokeAsync();
    }
}
