@* GM Actions tab - damage, healing, effects, and character management *@

@using GameMechanics
@using GameMechanics.Messaging
@using Threa.Dal.Dto
@using Radzen

@inject IDataPortal<CharacterEdit> characterPortal
@inject IChildDataPortal<EffectRecord> effectPortal
@inject IDataPortal<GameMechanics.GamePlay.TableCharacterDetacher> detacherPortal
@inject ITimeEventPublisher TimeEventPublisher
@inject DialogService DialogService

<div class="row g-3">
    <!-- Health Management (unified damage/healing) -->
    <div class="col-md-6">
        <div class="card h-100">
            <div class="card-header text-white" style="transition: background-color 0.2s ease; background-color: @(healthMode == HealthMode.Damage ? "var(--bs-danger)" : "var(--bs-success)");">
                <strong>
                    <i class="bi @(healthMode == HealthMode.Damage ? "bi-heart-pulse" : "bi-bandaid") me-1"></i>
                    @(healthMode == HealthMode.Damage ? "Apply Damage" : "Apply Healing")
                </strong>
            </div>
            <div class="card-body">
                <div class="btn-group w-100 mb-3" role="group">
                    <button class="btn @(healthMode == HealthMode.Damage ? "btn-danger" : "btn-outline-danger")"
                            @onclick="() => SetMode(HealthMode.Damage)">
                        <i class="bi bi-dash-circle me-1"></i>Damage
                    </button>
                    <button class="btn @(healthMode == HealthMode.Healing ? "btn-success" : "btn-outline-success")"
                            @onclick="() => SetMode(HealthMode.Healing)">
                        <i class="bi bi-plus-circle me-1"></i>Healing
                    </button>
                </div>
                <div class="mb-3">
                    <label class="form-label">Amount</label>
                    <input type="number" class="form-control" @bind="healthAmount" min="1" />
                </div>
                <div class="d-flex gap-2">
                    <button class="btn @(healthMode == HealthMode.Damage ? "btn-danger" : "btn-success") flex-grow-1"
                            @onclick='() => ApplyToPool("FAT")' disabled="@isProcessing">
                        <i class="bi @(healthMode == HealthMode.Damage ? "bi-dash-circle" : "bi-plus-circle") me-1"></i>FAT
                    </button>
                    <button class="btn @(healthMode == HealthMode.Damage ? "btn-danger" : "btn-success") flex-grow-1"
                            @onclick='() => ApplyToPool("VIT")' disabled="@isProcessing">
                        <i class="bi @(healthMode == HealthMode.Damage ? "bi-dash-circle" : "bi-plus-circle") me-1"></i>VIT
                    </button>
                </div>

                @if (showOverflowWarning)
                {
                    <div class="alert @(healthMode == HealthMode.Damage ? "alert-warning" : "alert-info") mt-3 mb-0">
                        <i class="bi bi-exclamation-triangle me-1"></i>
                        @overflowWarningMessage
                        <div class="mt-2 d-flex gap-2 flex-wrap">
                            <button class="btn @(healthMode == HealthMode.Damage ? "btn-warning" : "btn-info") btn-sm"
                                    @onclick="ConfirmApply" disabled="@isProcessing">
                                Apply Anyway
                            </button>
                            @if (healthMode == HealthMode.Damage && pendingPool == "VIT" && woundDamageExcess > 0)
                            {
                                <button class="btn btn-danger btn-sm"
                                        @onclick="ApplyAndAddWound" disabled="@isProcessing">
                                    <i class="bi bi-bandaid me-1"></i>Apply + Add Wound
                                </button>
                            }
                            <button class="btn btn-secondary btn-sm" @onclick="CancelApply">
                                Cancel
                            </button>
                        </div>
                    </div>
                }
            </div>
        </div>
    </div>

    <!-- Effects -->
    <div class="col-md-6">
        <div class="card h-100">
            <div class="card-header bg-warning text-dark">
                <strong><i class="bi bi-stars me-1"></i>Apply Effect</strong>
            </div>
            <div class="card-body">
                <select class="form-select mb-2" @bind="selectedEffect">
                    <option value="">Select effect...</option>
                    <option value="Stunned">Stunned</option>
                    <option value="Blinded">Blinded</option>
                    <option value="Prone">Prone</option>
                    <option value="Frightened">Frightened</option>
                    <option value="Slowed">Slowed</option>
                </select>
                <button class="btn btn-warning w-100" @onclick="ApplyEffect"
                        disabled="@(string.IsNullOrEmpty(selectedEffect) || isProcessing)">
                    <i class="bi bi-plus-lg me-1"></i>Apply Effect
                </button>
            </div>
        </div>
    </div>

    <!-- Wounds -->
    <div class="col-md-6">
        <div class="card h-100">
            <div class="card-header bg-danger text-white">
                <strong><i class="bi bi-bandaid me-1"></i>Manage Wounds</strong>
            </div>
            <div class="card-body d-flex flex-column">
                <p class="text-muted small flex-grow-1">
                    Add, edit, and remove wounds. Wounds apply AS penalties and periodic damage.
                </p>
                <button class="btn btn-outline-danger w-100" @onclick="OpenWoundManagement" disabled="@isProcessing">
                    <i class="bi bi-bandaid me-1"></i>Manage Wounds
                    @if (Character != null)
                    {
                        var woundCount = Character.Effects.Count(e => e.EffectType == EffectType.Wound);
                        if (woundCount > 0)
                        {
                            <span class="badge bg-light text-danger ms-1">@woundCount</span>
                        }
                    }
                </button>
            </div>
        </div>
    </div>

    <!-- Character Management -->
    <div class="col-12">
        <div class="card h-100">
            <div class="card-header bg-secondary text-white">
                <strong><i class="bi bi-gear me-1"></i>Character Management</strong>
            </div>
            <div class="card-body d-flex flex-column">
                <p class="text-muted small flex-grow-1">
                    Remove this character from the table. They will need to submit a new join request to rejoin.
                </p>
                <button class="btn btn-outline-danger w-100" @onclick="ConfirmRemove" disabled="@isProcessing">
                    <i class="bi bi-x-circle me-1"></i>Remove from Table
                </button>
            </div>
        </div>
    </div>
</div>

@* Feedback messages *@
@if (!string.IsNullOrEmpty(feedbackMessage))
{
    <div class="alert @feedbackClass mt-3 alert-dismissible fade show" role="alert">
        <i class="bi @feedbackIcon me-1"></i>
        @feedbackMessage
        <button type="button" class="btn-close" @onclick="() => feedbackMessage = null"></button>
    </div>
}

@* Remove Confirmation Dialog *@
@if (showRemoveConfirm)
{
    <div class="modal fade show d-block" style="background-color: rgba(0,0,0,0.5);" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header bg-danger text-white">
                    <h5 class="modal-title">Remove Character</h5>
                    <button type="button" class="btn-close btn-close-white" @onclick="CancelRemove"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to remove <strong>@Character?.Name</strong> from this table?</p>
                    <p class="text-muted small">The character will no longer be attached to this campaign and the player will need to submit a new join request to rejoin.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CancelRemove">Cancel</button>
                    <button type="button" class="btn btn-danger" @onclick="ExecuteRemove" disabled="@isProcessing">
                        <i class="bi bi-x-circle"></i> Remove
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public CharacterEdit? Character { get; set; }

    [Parameter]
    public int CharacterId { get; set; }

    [Parameter]
    public Guid TableId { get; set; }

    [Parameter]
    public EventCallback OnCharacterRemoved { get; set; }

    [Parameter]
    public EventCallback OnCharacterUpdated { get; set; }

    // Health mode enum and state
    private enum HealthMode { Damage, Healing }
    private HealthMode healthMode = HealthMode.Damage;
    private int healthAmount = 1;
    private bool showOverflowWarning;
    private string overflowWarningMessage = "";
    private string pendingPool = "";
    private int woundDamageExcess;

    // Effect state
    private string selectedEffect = "";

    // General state
    private bool isProcessing;
    private bool showRemoveConfirm;

    // Feedback
    private string? feedbackMessage;
    private string feedbackClass = "alert-info";
    private string feedbackIcon = "bi-info-circle";

    private void SetMode(HealthMode mode)
    {
        healthMode = mode;
        showOverflowWarning = false; // Clear any pending warning on mode change
        woundDamageExcess = 0;
    }

    private async Task ApplyToPool(string pool)
    {
        if (Character == null) return;
        pendingPool = pool;

        if (healthMode == HealthMode.Damage)
        {
            if (pool == "FAT")
            {
                // Check FAT overflow to VIT
                var projectedFat = Character.Fatigue.Value - Character.Fatigue.PendingDamage - healthAmount;
                if (projectedFat < 0)
                {
                    var overflow = Math.Abs(projectedFat);
                    overflowWarningMessage = $"This will exceed FAT capacity. {overflow} points will cascade to VIT pending damage.";
                    showOverflowWarning = true;
                    return;
                }
            }
            else if (pool == "VIT")
            {
                // Check VIT bounds - warn if damage would exceed current VIT
                var projectedVit = Character.Vitality.Value - Character.Vitality.PendingDamage - healthAmount;
                if (projectedVit < 0)
                {
                    var excess = Math.Abs(projectedVit);
                    woundDamageExcess = excess;
                    overflowWarningMessage = $"This will exceed VIT capacity. {excess} points of damage beyond VIT may result in wounds.";
                    showOverflowWarning = true;
                    return;
                }
            }
        }

        if (healthMode == HealthMode.Healing)
        {
            // Check overheal for both FAT and VIT
            var currentValue = pool == "FAT" ? Character.Fatigue.Value : Character.Vitality.Value;
            var pendingHealing = pool == "FAT" ? Character.Fatigue.PendingHealing : Character.Vitality.PendingHealing;
            var maxValue = pool == "FAT" ? Character.Fatigue.BaseValue : Character.Vitality.BaseValue;
            var projectedValue = currentValue + pendingHealing + healthAmount;

            if (projectedValue > maxValue)
            {
                var overheal = projectedValue - maxValue;
                overflowWarningMessage = $"This will exceed max {pool}. {overheal} points of temporary overheal will be applied.";
                showOverflowWarning = true;
                return;
            }
        }

        await ExecuteApply();
    }

    private async Task ConfirmApply()
    {
        showOverflowWarning = false;
        await ExecuteApply();
    }

    private void CancelApply()
    {
        showOverflowWarning = false;
        pendingPool = "";
        woundDamageExcess = 0;
    }

    private async Task ExecuteApply()
    {
        if (Character == null || string.IsNullOrEmpty(pendingPool)) return;
        isProcessing = true;

        try
        {
            var character = await characterPortal.FetchAsync(CharacterId);

            if (healthMode == HealthMode.Damage)
            {
                if (pendingPool == "FAT")
                    character.Fatigue.PendingDamage += healthAmount;
                else
                    character.Vitality.PendingDamage += healthAmount;
            }
            else
            {
                if (pendingPool == "FAT")
                    character.Fatigue.PendingHealing += healthAmount;
                else
                    character.Vitality.PendingHealing += healthAmount;
            }

            await characterPortal.UpdateAsync(character);

            var updateType = healthMode == HealthMode.Damage
                ? CharacterUpdateType.Damage
                : CharacterUpdateType.Healing;
            var action = healthMode == HealthMode.Damage ? "damage" : "healing";

            await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = updateType,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"{healthAmount} {pendingPool} {action}"
            });

            ShowFeedback($"Saved: {healthAmount} {pendingPool} {action} applied", "alert-success", "bi-check-circle");
            await OnCharacterUpdated.InvokeAsync();
        }
        catch (Exception ex)
        {
            ShowFeedback($"Error saving: {ex.Message}", "alert-danger", "bi-exclamation-triangle");
        }
        finally
        {
            isProcessing = false;
            pendingPool = "";
            woundDamageExcess = 0;
        }
    }

    private async Task ApplyAndAddWound()
    {
        showOverflowWarning = false;

        // First apply the damage
        await ExecuteApply();

        // Then open wound form modal
        var result = await DialogService.OpenAsync<WoundFormModal>(
            "Add Wound (VIT Exceeded)",
            new Dictionary<string, object>
            {
                { "Character", Character! },
                { "CharacterId", CharacterId },
                { "TableId", TableId }
            },
            new DialogOptions { Width = "500px", CloseDialogOnOverlayClick = true });

        if (result == true)
        {
            await OnCharacterUpdated.InvokeAsync();
        }

        woundDamageExcess = 0;
    }

    private async Task ApplyEffect()
    {
        if (Character == null || string.IsNullOrEmpty(selectedEffect)) return;
        isProcessing = true;

        try
        {
            var character = await characterPortal.FetchAsync(CharacterId);

            var effect = await effectPortal.CreateChildAsync(
                EffectType.Condition,
                selectedEffect,
                (string?)null,
                (int?)null,
                (string?)null
            );
            effect.Source = "GM";

            character.Effects.AddEffect(effect);
            await characterPortal.UpdateAsync(character);

            await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.EffectAdded,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = selectedEffect
            });

            ShowFeedback($"Saved: {selectedEffect} effect applied", "alert-success", "bi-check-circle");
            selectedEffect = "";
            await OnCharacterUpdated.InvokeAsync();
        }
        catch (Exception ex)
        {
            ShowFeedback($"Error saving: {ex.Message}", "alert-danger", "bi-exclamation-triangle");
        }
        finally
        {
            isProcessing = false;
        }
    }

    private void ConfirmRemove()
    {
        showRemoveConfirm = true;
    }

    private void CancelRemove()
    {
        showRemoveConfirm = false;
    }

    private async Task ExecuteRemove()
    {
        isProcessing = true;

        try
        {
            var result = await detacherPortal.ExecuteAsync(CharacterId);

            if (result.Success)
            {
                await OnCharacterRemoved.InvokeAsync();
            }
            else
            {
                ShowFeedback($"Error: {result.ErrorMessage}", "alert-danger", "bi-exclamation-triangle");
            }
        }
        catch (Exception ex)
        {
            ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-triangle");
        }
        finally
        {
            isProcessing = false;
            showRemoveConfirm = false;
        }
    }

    private void ShowFeedback(string message, string alertClass, string icon = "bi-check-circle")
    {
        feedbackMessage = message;
        feedbackClass = alertClass;
        feedbackIcon = icon;
    }

    private async Task OpenWoundManagement()
    {
        var result = await DialogService.OpenAsync<WoundManagementModal>(
            "Manage Wounds",
            new Dictionary<string, object>
            {
                { "Character", Character! },
                { "CharacterId", CharacterId },
                { "TableId", TableId }
            },
            new DialogOptions
            {
                Width = "700px",
                Height = "500px",
                CloseDialogOnOverlayClick = true
            });

        // Refresh character data when modal closes
        await OnCharacterUpdated.InvokeAsync();
    }
}
