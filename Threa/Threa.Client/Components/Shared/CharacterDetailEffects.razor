@* Character Detail Effects - Read-only view of active effects for character detail modal *@

@using GameMechanics
@using GameMechanics.Effects
@using Threa.Dal.Dto
@using Radzen

@inject DialogService DialogService

<div class="character-detail-effects">
    @* Summary Header *@
    @if (GetEffects().Any())
    {
        <div class="row g-3 mb-4">
            <div class="col-auto">
                <div class="card bg-light">
                    <div class="card-body py-2 px-3 text-center">
                        <div class="text-muted small">Active Effects</div>
                        <div class="h4 mb-0">@GetEffects().Count()</div>
                    </div>
                </div>
            </div>
            @{
                var totalASMod = GetTotalASModifier();
            }
            @if (totalASMod != 0)
            {
                <div class="col-auto">
                    <div class="card @(totalASMod > 0 ? "bg-success-subtle" : "bg-danger-subtle")">
                        <div class="card-body py-2 px-3 text-center">
                            <div class="text-muted small">Total AS Modifier</div>
                            <div class="h4 mb-0 @(totalASMod > 0 ? "text-success" : "text-danger")">
                                @(totalASMod > 0 ? "+" : "")@totalASMod
                            </div>
                        </div>
                    </div>
                </div>
            }
            @{
                var attrMods = GetTotalAttributeModifiers();
            }
            @if (attrMods.Any())
            {
                <div class="col-auto">
                    <div class="card bg-light">
                        <div class="card-body py-2 px-3">
                            <div class="text-muted small mb-1">Attribute Modifiers</div>
                            <div class="d-flex flex-wrap gap-1">
                                @foreach (var mod in attrMods)
                                {
                                    <span class="badge @(mod.Value > 0 ? "bg-success" : "bg-danger")">
                                        @mod.Key @(mod.Value > 0 ? "+" : "")@mod.Value
                                    </span>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            }
        </div>
    }

    @* Effects List (Compact Table View for Read-Only) *@
    @if (GetEffects().Any())
    {
        <div class="table-responsive">
            <table class="table table-hover align-middle">
                <thead class="table-light">
                    <tr>
                        <th style="width: 40px;"></th>
                        <th>Effect</th>
                        <th>Type</th>
                        <th>Duration</th>
                        <th>Modifiers</th>
                        <th>Source</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var effect in GetEffects())
                    {
                        var state = EffectState.Deserialize(effect.BehaviorState);
                        <tr>
                            <td class="text-center">
                                <i class="bi @GetEffectIcon(effect, state) @GetEffectIconColor(effect.EffectType)"></i>
                            </td>
                            <td>
                                <strong>@effect.Name</strong>
                                @if (!string.IsNullOrEmpty(effect.Description ?? state.Description))
                                {
                                    <br />
                                    <small class="text-muted">@(effect.Description ?? state.Description)</small>
                                }
                            </td>
                            <td>
                                <span class="badge @GetEffectBadgeClass(effect.EffectType)">
                                    @effect.EffectType
                                </span>
                            </td>
                            <td>
                                @if (effect.ExpiresAtEpochSeconds.HasValue)
                                {
                                    var remaining = effect.ExpiresAtEpochSeconds.Value - (Character?.CurrentGameTimeSeconds ?? 0);
                                    if (remaining > 0)
                                    {
                                        <span class="text-info">
                                            <i class="bi bi-clock me-1"></i>@FormatDuration(remaining)
                                        </span>
                                    }
                                    else
                                    {
                                        <span class="text-warning">
                                            <i class="bi bi-clock me-1"></i>Expired
                                        </span>
                                    }
                                }
                                else if (effect.DurationRounds.HasValue)
                                {
                                    var remaining = effect.DurationRounds.Value - effect.ElapsedRounds;
                                    <span class="text-info">
                                        <i class="bi bi-clock me-1"></i>@remaining rnd@(remaining != 1 ? "s" : "")
                                    </span>
                                }
                                else
                                {
                                    <span class="text-secondary">
                                        <i class="bi bi-infinity me-1"></i>Permanent
                                    </span>
                                }
                            </td>
                            <td>
                                @{
                                    var modSummary = GetModifierSummary(state);
                                }
                                @if (!string.IsNullOrEmpty(modSummary))
                                {
                                    <span class="small">@modSummary</span>
                                }
                                else
                                {
                                    <span class="text-muted small">-</span>
                                }
                            </td>
                            <td>
                                <small class="text-muted">@(effect.Source ?? "-")</small>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    }
    else
    {
        <div class="alert alert-secondary text-center">
            <i class="bi bi-stars me-1"></i>
            No active effects on this character.
        </div>
    }

    @* Manage Effects Button *@
    <div class="mt-3">
        <button class="btn btn-outline-primary" @onclick="OpenEffectManagement">
            <i class="bi bi-sliders me-1"></i>Manage Effects
        </button>
    </div>
</div>

@code {
    [Parameter]
    public CharacterEdit? Character { get; set; }

    [Parameter]
    public int CharacterId { get; set; }

    [Parameter]
    public Guid TableId { get; set; }

    private IEnumerable<EffectRecord> GetEffects() =>
        Character?.Effects
            .Where(e => e.EffectType != EffectType.Wound)
            .OrderBy(e => e.EffectType)
            .ThenBy(e => e.Name)
        ?? Enumerable.Empty<EffectRecord>();

    private int GetTotalASModifier()
    {
        return GetEffects().Sum(e =>
        {
            var state = EffectState.Deserialize(e.BehaviorState);
            return state.ASModifier ?? 0;
        });
    }

    private Dictionary<string, int> GetTotalAttributeModifiers()
    {
        var totals = new Dictionary<string, int>();

        foreach (var effect in GetEffects())
        {
            var state = EffectState.Deserialize(effect.BehaviorState);
            if (state.AttributeModifiers != null)
            {
                foreach (var mod in state.AttributeModifiers)
                {
                    if (totals.ContainsKey(mod.Key))
                        totals[mod.Key] += mod.Value;
                    else
                        totals[mod.Key] = mod.Value;
                }
            }
        }

        return totals.Where(t => t.Value != 0).ToDictionary(t => t.Key, t => t.Value);
    }

    private static string GetEffectIcon(EffectRecord effect, EffectState state)
    {
        if (!string.IsNullOrEmpty(state.IconName))
            return state.IconName;
        if (!string.IsNullOrEmpty(effect.IconName))
            return effect.IconName;

        return effect.EffectType switch
        {
            EffectType.Buff => "bi-arrow-up-circle-fill",
            EffectType.Debuff => "bi-arrow-down-circle-fill",
            EffectType.Condition => "bi-exclamation-triangle-fill",
            EffectType.Poison => "bi-droplet-fill",
            EffectType.Disease => "bi-virus",
            EffectType.SpellEffect => "bi-magic",
            EffectType.ItemEffect => "bi-gem",
            EffectType.Environmental => "bi-cloud-fill",
            EffectType.CombatStance => "bi-shield-fill",
            EffectType.Concentration => "bi-hourglass-split",
            _ => "bi-stars"
        };
    }

    private static string GetEffectIconColor(EffectType effectType) => effectType switch
    {
        EffectType.Buff => "text-success",
        EffectType.Debuff => "text-danger",
        EffectType.Condition => "text-warning",
        EffectType.Poison => "text-purple",
        EffectType.Disease => "text-secondary",
        EffectType.SpellEffect => "text-info",
        EffectType.ItemEffect => "text-primary",
        EffectType.Environmental => "text-dark",
        _ => "text-secondary"
    };

    private static string GetEffectBadgeClass(EffectType effectType) => effectType switch
    {
        EffectType.Buff => "bg-success",
        EffectType.Debuff => "bg-danger",
        EffectType.Condition => "bg-purple",
        EffectType.Poison => "bg-dark",
        EffectType.Disease => "bg-secondary",
        EffectType.SpellEffect => "bg-info",
        EffectType.ItemEffect => "bg-primary",
        EffectType.Environmental => "bg-dark",
        _ => "bg-secondary"
    };

    private static string FormatDuration(long seconds)
    {
        if (seconds < 60)
            return $"{seconds}s";
        if (seconds < 3600)
            return $"{seconds / 60}m {seconds % 60}s";
        if (seconds < 86400)
            return $"{seconds / 3600}h {(seconds % 3600) / 60}m";
        return $"{seconds / 86400}d {(seconds % 86400) / 3600}h";
    }

    private static string GetModifierSummary(EffectState state)
    {
        var parts = new List<string>();

        if (state.ASModifier.HasValue && state.ASModifier.Value != 0)
        {
            var sign = state.ASModifier.Value > 0 ? "+" : "";
            parts.Add($"AS {sign}{state.ASModifier.Value}");
        }

        if (state.AttributeModifiers != null)
        {
            foreach (var kvp in state.AttributeModifiers.Where(m => m.Value != 0).Take(2))
            {
                var sign = kvp.Value > 0 ? "+" : "";
                parts.Add($"{kvp.Key} {sign}{kvp.Value}");
            }
            if (state.AttributeModifiers.Count > 2)
                parts.Add("...");
        }

        if (state.FatDamagePerTick.HasValue || state.VitDamagePerTick.HasValue)
        {
            parts.Add("dmg/tick");
        }

        if (state.FatHealingPerTick.HasValue || state.VitHealingPerTick.HasValue)
        {
            parts.Add("heal/tick");
        }

        return string.Join(", ", parts.Take(4));
    }

    private async Task OpenEffectManagement()
    {
        await DialogService.OpenAsync<EffectManagementModal>(
            "Manage Effects",
            new Dictionary<string, object>
            {
                { "Character", Character! },
                { "CharacterId", CharacterId },
                { "TableId", TableId }
            },
            new DialogOptions { Width = "900px", Height = "600px", CloseDialogOnOverlayClick = true });
    }
}
