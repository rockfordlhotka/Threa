@using GameMechanics
@using GameMechanics.GamePlay
@using GameMechanics.Messaging
@using GameMechanics.Effects.Behaviors
@using Radzen
@using Threa.Dal
@using Threa.Client.Components.Shared
@using Threa.Client.Components.Pages.GamePlay
@using Threa.Client.Components.Pages.GamePlay.Targeting

@implements IAsyncDisposable

@inject IDataPortal<CharacterEdit> characterPortal
@inject IDataPortal<TableEdit> tablePortal
@inject IDataPortal<TableCharacterList> characterListPortal
@inject DialogService DialogService
@inject ITableDal tableDal
@inject ITimeEventSubscriber TimeEventSubscriber
@inject ITimeEventPublisher TimeEventPublisher
@inject ICharacterItemDal CharacterItemDal
@inject IItemTemplateDal ItemTemplateDal
@inject IActivityLogService ActivityLog
@inject ITargetingInteractionManager TargetingManager

<div class="character-detail-modal">
    <!-- Header with character switcher, summary, and close -->
    <div class="modal-header d-flex align-items-center border-bottom pb-3 mb-3 gap-3">
        <!-- Character Selector -->
        <select class="form-select" style="max-width: 200px; flex-shrink: 0;" @bind="selectedCharacterId" @bind:after="OnCharacterChanged">
            @foreach (var charInfo in AllCharacters)
            {
                <option value="@charInfo.CharacterId">@charInfo.CharacterName</option>
            }
        </select>

        <!-- Character Summary (when loaded) -->
        @if (character != null && !isLoading)
        {
            <div class="d-flex align-items-center gap-3 flex-grow-1">
                <!-- Species -->
                <span class="text-muted small">@character.Species</span>

                <!-- Health Bars -->
                <div class="d-flex align-items-center gap-2" style="min-width: 200px;">
                    <div class="d-flex align-items-center gap-1">
                        <small class="text-muted" style="width: 28px; font-size: 0.7rem;">FAT</small>
                        <div style="width: 80px;">
                            <PendingPoolBar CurrentValue="@character.Fatigue.Value"
                                           MaxValue="@character.Fatigue.BaseValue"
                                           PendingDamage="@character.Fatigue.PendingDamage"
                                           PendingHealing="@character.Fatigue.PendingHealing"
                                           Height="8px" />
                        </div>
                    </div>
                    <div class="d-flex align-items-center gap-1">
                        <small class="text-muted" style="width: 28px; font-size: 0.7rem;">VIT</small>
                        <div style="width: 80px;">
                            <PendingPoolBar CurrentValue="@character.Vitality.Value"
                                           MaxValue="@character.Vitality.BaseValue"
                                           PendingDamage="@character.Vitality.PendingDamage"
                                           PendingHealing="@character.Vitality.PendingHealing"
                                           Height="8px" />
                        </div>
                    </div>
                </div>

                <!-- Status Badges -->
                <div class="d-flex gap-1">
                    <span class="badge bg-primary" title="Action Points">
                        <i class="bi bi-lightning-charge"></i> @character.ActionPoints.Available/@character.ActionPoints.Max
                    </span>
                    @foreach (var wound in character.Effects.Where(e => e.EffectType == Threa.Dal.Dto.EffectType.Wound))
                    {
                        var woundState = WoundState.Deserialize(wound.BehaviorState);
                        var severity = woundState?.Severity ?? "Unknown";
                        var description = woundState?.Description ?? wound.Location ?? "Wound";
                        var badgeClass = severity switch
                        {
                            "Critical" => "bg-danger",
                            "Severe" => "bg-danger-subtle text-danger",
                            "Moderate" => "bg-warning text-dark",
                            "Minor" => "bg-secondary",
                            _ => "bg-warning text-dark"
                        };

                        <span class="badge @badgeClass"
                              style="cursor: help;"
                              title="@($"{severity} wound at {wound.Location}: {description}")">
                            <i class="bi bi-bandaid"></i> @(wound.Location?.Replace("Left", "L").Replace("Right", "R") ?? "?")
                        </span>
                    }
                    @if (character.Effects.Count(e => e.EffectType != Threa.Dal.Dto.EffectType.Wound) > 0)
                    {
                        <span class="badge bg-info" title="Active Effects">
                            <i class="bi bi-stars"></i> @character.Effects.Count(e => e.EffectType != Threa.Dal.Dto.EffectType.Wound)
                        </span>
                    }

                    @* NPC Visibility Toggle *@
                    @if (character.IsNpc)
                    {
                        <button class="btn @(character.VisibleToPlayers ? "btn-outline-warning" : "btn-outline-success") btn-sm ms-2"
                                @onclick="ToggleVisibility"
                                title="@(character.VisibleToPlayers ? "Hide from players" : "Reveal to players")">
                            <i class="bi @(character.VisibleToPlayers ? "bi-eye-slash" : "bi-eye") me-1"></i>
                            @(character.VisibleToPlayers ? "Hide" : "Reveal")
                        </button>
                    }
                </div>
            </div>
        }

        <!-- Close Button -->
        <button type="button" class="btn-close ms-auto" aria-label="Close" @onclick="Close"></button>
    </div>

    <!-- Tab navigation -->
    <div class="tab-buttons mb-3">
        @foreach (var tabName in tabNames)
        {
            <button class="tab-link @(activeTab == tabName ? "active" : "")"
                    @onclick="() => activeTab = tabName">
                @tabName
            </button>
        }
    </div>

    <!-- Tab content -->
    <div class="tab-content p-3" style="min-height: 400px; max-height: 70vh; overflow-y: auto;">
        @if (isLoading)
        {
            <div class="text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-2 text-muted">Loading character data...</p>
            </div>
        }
        else if (character != null)
        {
            @if (activeTab == "GM Actions")
            {
                <CharacterDetailGmActions Character="character"
                                          CharacterId="selectedCharacterId"
                                          TableId="TableId"
                                          OnCharacterUpdated="OnCharacterUpdated" />
            }
            else if (activeTab == "Combat")
            {
                <!-- Targeting Notification Badge -->
                @if (pendingTargetingRequests.Any())
                {
                    <div class="mb-3">
                        <TargetingNotificationBadge PendingRequests="@pendingTargetingRequests"
                                                    OnOpenTargeting="OpenTargetingModal"
                                                    OnViewRequest="ViewTargetingRequest" />
                    </div>
                }

                <CombatContent Character="character"
                               Table="table"
                               AvailableTargets="GetAvailableTargets()"
                               ActivityEntries="activityLog"
                               GetActivityCssClass="GetActivityClass"
                               CharacterItemDal="CharacterItemDal"
                               ItemTemplateDal="ItemTemplateDal"
                               ActivityLog="ActivityLog"
                               OnCharacterChanged="SaveCharacterAsync"
                               OnInitiateTargeting="HandleInitiateTargeting" />
            }
            else if (activeTab == "Character Sheet")
            {
                <CharacterDetailSheet Character="character"
                                       CharacterId="selectedCharacterId"
                                       TableId="TableId"
                                       TableTheme="@tableTheme"
                                       IsEditMode="@isEditMode"
                                       IsEditModeChanged="@((bool val) => { isEditMode = val; StateHasChanged(); })"
                                       OnCharacterUpdated="OnCharacterUpdated" />
            }
            else if (activeTab == "Inventory")
            {
                <CharacterDetailInventory Character="character"
                                         CharacterId="selectedCharacterId"
                                         TableId="TableId"
                                         TableTheme="@tableTheme" />
            }
            else if (activeTab == "Narrative")
            {
                <CharacterDetailNarrative Character="character"
                                          TableId="TableId"
                                          CharacterId="selectedCharacterId"
                                          InitialGmNotes="@currentGmNotes"
                                          OnGmNotesChanged="@((notes) => currentGmNotes = notes)"
                                          CurrentTimeSeconds="currentTimeSeconds"
                                          TableTheme="@tableTheme"
                                          OnCharacterUpdated="OnCharacterUpdated" />
            }
            else if (activeTab == "Admin")
            {
                <CharacterDetailAdmin Character="character"
                                       CharacterId="selectedCharacterId"
                                       TableId="TableId"
                                       OnCharacterRemoved="OnCharacterRemoved" />
            }
        }
        else
        {
            <div class="alert alert-warning">
                <i class="bi bi-exclamation-triangle me-1"></i>
                Unable to load character data.
            </div>
        }
    </div>
</div>

<!-- Targeting Modal -->
@if (showTargetingModal && currentTargetingInteraction != null)
{
    <div class="modal d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5); z-index: 1100;">
        <div class="modal-dialog modal-xl modal-dialog-centered">
            <div class="modal-content">
                <TargetingModal Interaction="@currentTargetingInteraction"
                                IsAttacker="@isTargetingAttacker"
                                maxAPBoost="@GetTargetingMaxAPBoost()"
                                maxFATBoost="@GetTargetingMaxFATBoost()"
                                defenderDodgeAS="@GetDefenderDodgeAS()"
                                defenderParryAS="@GetDefenderParryAS()"
                                defenderIsInParryMode="@GetDefenderIsInParryMode()"
                                defenderCanActiveDefense="@GetDefenderCanActiveDefense()"
                                defenderCanParry="@GetDefenderCanParry()"
                                OnAttackerDataUpdated="UpdateTargetingAttackerData"
                                OnDefenderDataUpdated="UpdateTargetingDefenderData"
                                OnAttackerConfirmChanged="ToggleTargetingAttackerConfirm"
                                OnDefenderConfirmChanged="ToggleTargetingDefenderConfirm"
                                OnCancel="CancelTargeting"
                                OnClose="CloseTargetingModal"
                                OnAcceptDamage="AcceptTargetingDamage" />
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public int CharacterId { get; set; }

    [Parameter]
    public Guid TableId { get; set; }

    [Parameter]
    public IEnumerable<TableCharacterInfo> AllCharacters { get; set; } = Enumerable.Empty<TableCharacterInfo>();

    private static readonly string[] tabNames = ["GM Actions", "Combat", "Character Sheet", "Inventory", "Narrative", "Admin"];
    private string activeTab = tabNames[0];
    private int selectedCharacterId;
    private bool isLoading = true;
    private CharacterEdit? character;
    private string? currentGmNotes;
    private bool subscribed;
    private bool ownedSubscription;
    private bool isEditMode;
    private string tableTheme = "fantasy";
    private long currentTimeSeconds;
    private TableEdit? table;
    private List<TableCharacterInfo> tableCharacters = new();
    private List<Play.ActivityLogEntry> activityLog = new();
    private IDisposable? activityLogSubscription;

    // Targeting state
    private List<TargetingRequestMessage> pendingTargetingRequests = new();
    private TargetingInteraction? currentTargetingInteraction;
    private bool showTargetingModal;
    private bool isTargetingAttacker;

    protected override async Task OnInitializedAsync()
    {
        selectedCharacterId = CharacterId;

        // Load table, characters, and theme
        try
        {
            table = await tablePortal.FetchAsync(TableId);
            tableTheme = table?.Theme ?? "fantasy";
            if (table != null)
                currentTimeSeconds = table.StartTimeSeconds + (table.CurrentRound * 3L);
            
            await LoadTableCharactersAsync();
            SubscribeToActivityLog(TableId);
        }
        catch
        {
            tableTheme = "fantasy";
        }

        await LoadCharacterAsync();
        await SubscribeToUpdatesAsync();
    }

    private async Task SubscribeToUpdatesAsync()
    {
        if (subscribed) return;

        await TimeEventSubscriber.ConnectAsync();
        // Track whether this component initiated the subscription so we only unsubscribe if we own it.
        // GmTable (the parent) may have already subscribed on the shared scoped instance.
        ownedSubscription = !TimeEventSubscriber.IsSubscribed;
        await TimeEventSubscriber.SubscribeAsync();
        TimeEventSubscriber.CharacterUpdateReceived += OnCharacterUpdateReceived;

        // Subscribe to targeting events
        TimeEventSubscriber.TargetingRequestReceived += OnTargetingRequestReceived;
        TimeEventSubscriber.TargetingResponseReceived += OnTargetingResponseReceived;
        TimeEventSubscriber.TargetingUpdateReceived += OnTargetingUpdateReceived;
        TimeEventSubscriber.TargetingResultReceived += OnTargetingResultReceived;
        TimeEventSubscriber.TargetingCancelledReceived += OnTargetingCancelledReceived;

        subscribed = true;
    }

    private void OnCharacterUpdateReceived(object? sender, CharacterUpdateMessage e)
    {
        // Only refresh if the updated character is the one we're viewing
        if (e.CharacterId != selectedCharacterId) return;

        InvokeAsync(async () =>
        {
            // Refresh character data silently â€” do NOT toggle isLoading here, as that
            // destroys and recreates child components, resetting their local state
            // (e.g. healthMode selection in CharacterDetailGmActions).
            try
            {
                character = await characterPortal.FetchAsync(selectedCharacterId);
            }
            finally
            {
                StateHasChanged();
            }
        });
    }

    private async Task OnCharacterChanged()
    {
        await LoadCharacterAsync();
    }

    private async Task LoadCharacterAsync(bool showLoading = true)
    {
        if (showLoading)
        {
            isLoading = true;
            StateHasChanged();
        }

        try
        {
            character = await characterPortal.FetchAsync(selectedCharacterId);

            // Sync character setting with table theme (rebuilds wallet if needed)
            if (character != null && !string.IsNullOrEmpty(tableTheme) && character.Setting != tableTheme)
            {
                character.Setting = tableTheme;
                character = await character.SaveAsync();
            }

            // Load equipped items and chip data so chip skills are visible on the character sheet
            if (character != null)
            {
                var equippedItems = await CharacterItemDal.GetEquippedItemsWithTemplatesAsync(character.Id);
                character.SetEquippedItems(equippedItems);
                var allItems = await CharacterItemDal.GetCharacterItemsAsync(character.Id);
                character.SetChipItems(allItems);
            }

            // Load GM notes directly from DAL to ensure we get the latest saved value
            currentGmNotes = await tableDal.GetGmNotesAsync(TableId, selectedCharacterId);
        }
        catch
        {
            character = null;
            currentGmNotes = null;
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private void Close()
    {
        DialogService.Close();
    }

    private async Task OnCharacterUpdated()
    {
        // Reload the character silently to preserve child component state (e.g. healthMode selection)
        await LoadCharacterAsync(showLoading: false);
    }

    private void OnCharacterRemoved()
    {
        // Close the modal - the character has been removed from the table
        DialogService.Close("removed");
    }

    private async Task ToggleVisibility()
    {
        if (character == null || !character.IsNpc) return;

        var wasVisible = character.VisibleToPlayers;
        character.VisibleToPlayers = !character.VisibleToPlayers;

        try
        {
            await characterPortal.UpdateAsync(character);

            // Publish update for real-time sync
            await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = character.Id,
                UpdateType = CharacterUpdateType.General,
                CampaignId = TableId.ToString(),
                Description = character.VisibleToPlayers ? "Revealed to players" : "Hidden from players"
            });
        }
        catch
        {
            // Revert on failure
            character.VisibleToPlayers = wasVisible;
        }

        StateHasChanged();
    }

    private async Task LoadTableCharactersAsync()
    {
        if (table == null) return;
        var charList = await characterListPortal.FetchAsync(table.Id);
        tableCharacters = charList.ToList();
    }

    private void SubscribeToActivityLog(Guid tableId)
    {
        // Unsubscribe from any previous subscription
        activityLogSubscription?.Dispose();

        activityLogSubscription = ActivityLog.Subscribe(tableId, msg =>
        {
            InvokeAsync(() =>
            {
                activityLog.Add(new Play.ActivityLogEntry(msg.Timestamp, msg.Message, msg.Source, msg.Category));
                if (activityLog.Count > 100) activityLog.RemoveAt(0);
                StateHasChanged();
            });
        });
    }

    private List<TargetSelectionModal.TargetInfo> GetAvailableTargets()
    {
        if (table == null || character == null)
            return new List<TargetSelectionModal.TargetInfo>();

        return tableCharacters
            .Where(c => c.CharacterId != character.Id)
            .Where(c => !c.IsNpc || c.VisibleToPlayers) // PCs always visible, NPCs only if revealed
            .Select(c => new TargetSelectionModal.TargetInfo
            {
                CharacterId = c.CharacterId,
                CharacterName = c.CharacterName,
                PlayerName = c.IsNpc ? null : "Player",
                IsNPC = c.IsNpc,
                Disposition = c.Disposition
            })
            .ToList();
    }

    private async Task HandleInitiateTargeting((TargetingActionType ActionType, int TargetId, string TargetName, TargetingAttackerData AttackerData) args)
    {
        if (character == null || table == null) return;

        var (interaction, queuePosition) = await TargetingManager.StartInteractionAsync(
            table.Id,
            character.Id,
            character.Name,
            args.TargetId,
            args.TargetName,
            args.AttackerData);

        currentTargetingInteraction = interaction;
        showTargetingModal = true;
        isTargetingAttacker = true;

        if (queuePosition > 0)
        {
            // Log to activity feed
            activityLog.Add(new Play.ActivityLogEntry(
                DateTime.UtcNow,
                $"Attack queued. {args.TargetName} has {queuePosition} other incoming attacks.",
                character.Name,
                ActivityCategory.Combat));
            if (activityLog.Count > 100) activityLog.RemoveAt(0);
        }

        StateHasChanged();
    }

    // ================================
    // Targeting Helper Methods
    // ================================

    private int GetTargetingMaxAPBoost()
    {
        if (character == null) return 0;
        // Reserve 1 AP for the action cost
        return Math.Max(0, character.ActionPoints.Available - 1);
    }

    private int GetTargetingMaxFATBoost()
    {
        if (character == null) return 0;
        // Reserve 1 FAT for the action cost
        return Math.Max(0, character.Fatigue.Value - 1);
    }

    private int GetDefenderDodgeAS()
    {
        if (character == null) return 0;
        var dodgeSkill = character.Skills.FirstOrDefault(s =>
            s.Name.Equals("Dodge", StringComparison.OrdinalIgnoreCase));
        return dodgeSkill?.AbilityScore ?? 0;
    }

    private int GetDefenderParryAS()
    {
        if (character == null) return 0;
        // Find weapon skill AS for parry
        var equippedItems = character.GetEquippedItems();
        var mainHand = equippedItems?.FirstOrDefault(i => i.Item.EquippedSlot == Threa.Dal.Dto.EquipmentSlot.MainHand);
        if (mainHand?.Template?.RelatedSkill != null)
        {
            var skill = character.Skills.FirstOrDefault(s =>
                s.Id.Equals(mainHand.Template.RelatedSkill, StringComparison.OrdinalIgnoreCase));
            return skill?.AbilityScore ?? 0;
        }
        return 0;
    }

    private bool GetDefenderIsInParryMode()
    {
        if (character == null) return false;
        return GameMechanics.Effects.Behaviors.CombatStanceBehavior.IsInParryMode(character);
    }

    private bool GetDefenderCanActiveDefense()
    {
        if (character == null) return false;
        return !character.IsPassedOut &&
               ((character.ActionPoints.Available >= 1 && character.Fatigue.Value >= 1) ||
                character.ActionPoints.Available >= 2);
    }

    private bool GetDefenderCanParry()
    {
        if (character == null) return false;
        return GetDefenderCanActiveDefense() || GetDefenderIsInParryMode();
    }

    // ================================
    // Targeting Modal Callbacks
    // ================================

    private async Task UpdateTargetingAttackerData(TargetingAttackerData data)
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.UpdateAttackerDataAsync(currentTargetingInteraction.InteractionId, data);
    }

    private async Task UpdateTargetingDefenderData(TargetingDefenderData data)
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.UpdateDefenderDataAsync(currentTargetingInteraction.InteractionId, data);
    }

    private async Task ToggleTargetingAttackerConfirm(bool confirmed)
    {
        if (currentTargetingInteraction == null) return;
        if (confirmed)
        {
            await TargetingManager.ConfirmAttackerAsync(currentTargetingInteraction.InteractionId);
        }
        else
        {
            await TargetingManager.UpdateAttackerDataAsync(currentTargetingInteraction.InteractionId, currentTargetingInteraction.AttackerData, false);
        }
    }

    private async Task ToggleTargetingDefenderConfirm(bool confirmed)
    {
        if (currentTargetingInteraction == null || currentTargetingInteraction.DefenderData == null) return;
        if (confirmed)
        {
            await TargetingManager.ConfirmDefenderAsync(currentTargetingInteraction.InteractionId);
        }
        else
        {
            await TargetingManager.UpdateDefenderDataAsync(currentTargetingInteraction.InteractionId, currentTargetingInteraction.DefenderData, false);
        }
    }

    private async Task CancelTargeting()
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.CancelAsync(currentTargetingInteraction.InteractionId, "Cancelled by attacker");
        showTargetingModal = false;
        currentTargetingInteraction = null;
    }

    private void OpenTargetingModal()
    {
        if (character == null) return;

        // Open the first pending request
        var request = pendingTargetingRequests.FirstOrDefault();
        if (request != null)
        {
            ViewTargetingRequest(request);
        }
    }

    private void ViewTargetingRequest(TargetingRequestMessage request)
    {
        var interaction = TargetingManager.GetInteraction(request.InteractionId);
        if (interaction != null)
        {
            currentTargetingInteraction = interaction;
            showTargetingModal = true;
            isTargetingAttacker = false;
            StateHasChanged();
        }
    }

    private void CloseTargetingModal()
    {
        showTargetingModal = false;
        currentTargetingInteraction = null;
        // Remove from pending if it's resolved
        if (currentTargetingInteraction != null)
        {
            pendingTargetingRequests.RemoveAll(r => r.InteractionId == currentTargetingInteraction.InteractionId);
        }
    }

    private async Task AcceptTargetingDamage()
    {
        if (currentTargetingInteraction == null) return;
        await TargetingManager.AcceptDamageAsync(currentTargetingInteraction.InteractionId);

        // Apply damage to character if we're the defender
        if (!isTargetingAttacker && character != null && currentTargetingInteraction.Resolution != null)
        {
            var resolution = currentTargetingInteraction.Resolution;
            if (resolution.IsHit)
            {
                character.Fatigue.PendingDamage += resolution.FATDamage;
                character.Vitality.PendingDamage += resolution.VITDamage;

                var savable = character as Csla.Core.ISavable;
                if (savable != null)
                {
                    await savable.SaveAsync();
                }

                activityLog.Add(new Play.ActivityLogEntry(
                    DateTime.UtcNow,
                    $"Took {resolution.FATDamage} FAT and {resolution.VITDamage} VIT damage from {currentTargetingInteraction.AttackerName}",
                    character.Name,
                    ActivityCategory.Combat));
                if (activityLog.Count > 100) activityLog.RemoveAt(0);
            }
        }

        StateHasChanged();
    }

    private string GetActivityClass(ActivityCategory category) =>
        category switch
        {
            ActivityCategory.Combat => "text-danger",
            ActivityCategory.Announcement => "text-primary fw-bold",
            ActivityCategory.Health => "text-success",
            ActivityCategory.Effect => "text-warning",
            ActivityCategory.Time => "text-info",
            ActivityCategory.Session => "text-secondary fst-italic",
            ActivityCategory.Player => "text-muted",
            _ => ""
        };

    private async Task SaveCharacterAsync()
    {
        if (character == null) return;
        
        try
        {
            character = await character.SaveAsync();
            
            // Publish update for real-time sync
            await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = character.Id,
                UpdateType = CharacterUpdateType.General,
                CampaignId = TableId.ToString(),
                Description = "Character updated"
            });
            
            StateHasChanged();
        }
        catch (Exception)
        {
            // Handle save errors silently
        }
    }

    // ================================
    // Targeting Event Handlers
    // ================================

    private void OnTargetingRequestReceived(object? sender, TargetingRequestMessage e)
    {
        // Ignore if not our table or no character
        if (table == null || e.TableId != table.Id || character == null) return;

        // Check if we are the defender - add to pending queue
        if (e.DefenderId == character.Id)
        {
            _ = InvokeAsync(() =>
            {
                pendingTargetingRequests.Add(e);
                StateHasChanged();
            });
        }
        // Check if we are the attacker - open modal immediately
        else if (e.AttackerId == character.Id)
        {
            _ = InvokeAsync(() =>
            {
                currentTargetingInteraction = TargetingManager.GetInteraction(e.InteractionId);
                if (currentTargetingInteraction != null)
                {
                    showTargetingModal = true;
                    isTargetingAttacker = true;
                    StateHasChanged();
                }
            });
        }
    }

    private void OnTargetingResponseReceived(object? sender, TargetingResponseMessage e)
    {
        // Ignore if not our table
        if (table == null || e.TableId != table.Id) return;
        if (currentTargetingInteraction == null || e.InteractionId != currentTargetingInteraction.InteractionId) return;

        _ = InvokeAsync(() =>
        {
            // Update local interaction state
            var interaction = TargetingManager.GetInteraction(e.InteractionId);
            if (interaction != null)
            {
                currentTargetingInteraction = interaction;
            }
            StateHasChanged();
        });
    }

    private void OnTargetingUpdateReceived(object? sender, TargetingUpdateMessage e)
    {
        // Ignore if not our table
        if (table == null || e.TableId != table.Id) return;
        if (currentTargetingInteraction == null || e.InteractionId != currentTargetingInteraction.InteractionId) return;

        _ = InvokeAsync(() =>
        {
            // Update local interaction state
            var interaction = TargetingManager.GetInteraction(e.InteractionId);
            if (interaction != null)
            {
                currentTargetingInteraction = interaction;
            }
            StateHasChanged();
        });
    }

    private void OnTargetingResultReceived(object? sender, TargetingResultMessage e)
    {
        // Ignore if not our table
        if (table == null || e.TableId != table.Id) return;

        _ = InvokeAsync(() =>
        {
            // Update local interaction state if this is our current interaction
            if (currentTargetingInteraction != null && e.InteractionId == currentTargetingInteraction.InteractionId)
            {
                var interaction = TargetingManager.GetInteraction(e.InteractionId);
                if (interaction != null)
                {
                    currentTargetingInteraction = interaction;
                }
            }

            // Remove from pending requests if we're the defender
            pendingTargetingRequests.RemoveAll(r => r.InteractionId == e.InteractionId);

            StateHasChanged();
        });
    }

    private void OnTargetingCancelledReceived(object? sender, TargetingCancelledMessage e)
    {
        // Ignore if not our table
        if (table == null || e.TableId != table.Id) return;

        _ = InvokeAsync(() =>
        {
            // Update local interaction state if this is our current interaction
            if (currentTargetingInteraction != null && e.InteractionId == currentTargetingInteraction.InteractionId)
            {
                var interaction = TargetingManager.GetInteraction(e.InteractionId);
                if (interaction != null)
                {
                    currentTargetingInteraction = interaction;
                }
            }

            // Remove from pending requests
            pendingTargetingRequests.RemoveAll(r => r.InteractionId == e.InteractionId);

            StateHasChanged();
        });
    }

    public async ValueTask DisposeAsync()
    {
        if (subscribed)
        {
            TimeEventSubscriber.CharacterUpdateReceived -= OnCharacterUpdateReceived;

            // Unsubscribe from targeting events
            TimeEventSubscriber.TargetingRequestReceived -= OnTargetingRequestReceived;
            TimeEventSubscriber.TargetingResponseReceived -= OnTargetingResponseReceived;
            TimeEventSubscriber.TargetingUpdateReceived -= OnTargetingUpdateReceived;
            TimeEventSubscriber.TargetingResultReceived -= OnTargetingResultReceived;
            TimeEventSubscriber.TargetingCancelledReceived -= OnTargetingCancelledReceived;

            // Only tear down the underlying Rx subscriptions if this component initiated them.
            // When GmTable opens this modal, GmTable already owns the subscription on the shared
            // scoped ITimeEventSubscriber. Calling UnsubscribeAsync here would destroy those Rx
            // subscriptions and prevent GmTable from receiving any further messages.
            if (ownedSubscription)
            {
                await TimeEventSubscriber.UnsubscribeAsync();
            }
            subscribed = false;
        }

        activityLogSubscription?.Dispose();
    }
}
