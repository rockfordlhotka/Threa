---
phase: 09-password-recovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Threa.Dal/Dto/Player.cs
  - Threa.Dal/IPlayerDal.cs
  - Threa.Dal.MockDb/PlayerDal.cs
  - GameMechanics/Player/PasswordRecovery.cs
  - GameMechanics.Test/PasswordRecoveryTests.cs
autonomous: true

must_haves:
  truths:
    - "Player DTO has FailedRecoveryAttempts and RecoveryLockoutUntil fields"
    - "IPlayerDal has GetSecretQuestionAsync method that returns question without answer"
    - "IPlayerDal has ResetPasswordAsync method for setting new password"
    - "PasswordRecovery validates answer case-insensitively with trimmed whitespace"
    - "Lockout enforced after 3 failed attempts for 15 minutes"
    - "Unknown username returns null/empty (no exception to prevent enumeration)"
    - "Password reset requires same validation as registration (min 6 chars)"
  artifacts:
    - path: "Threa.Dal/Dto/Player.cs"
      provides: "FailedRecoveryAttempts and RecoveryLockoutUntil properties"
      contains: "FailedRecoveryAttempts"
    - path: "Threa.Dal/IPlayerDal.cs"
      provides: "GetSecretQuestionAsync and ResetPasswordAsync methods"
      contains: "GetSecretQuestionAsync"
    - path: "Threa.Dal.MockDb/PlayerDal.cs"
      provides: "Implementation of recovery DAL methods"
      min_lines: 140
    - path: "GameMechanics/Player/PasswordRecovery.cs"
      provides: "CSLA business object for password recovery workflow"
      exports: ["PasswordRecovery"]
    - path: "GameMechanics.Test/PasswordRecoveryTests.cs"
      provides: "Unit tests for password recovery logic"
      min_lines: 50
  key_links:
    - from: "GameMechanics/Player/PasswordRecovery.cs"
      to: "IPlayerDal"
      via: "CSLA [Inject] in Execute methods"
      pattern: "\\[Inject\\] IPlayerDal"
    - from: "GameMechanics/Player/PasswordRecovery.cs"
      to: "BCrypt.Net.BCrypt"
      via: "Password hashing on reset"
      pattern: "BCrypt\\.Net\\.BCrypt\\.(GenerateSalt|HashPassword)"
---

<objective>
Create the data layer and business object for password recovery workflow.

Purpose: Enable users who forgot their password to reset it by answering their secret question, with lockout protection against brute force attempts.

Output: Extended Player DTO with lockout fields, IPlayerDal with recovery methods, MockDb implementation, PasswordRecovery CSLA business object with step-based execution, unit tests.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-password-recovery/09-CONTEXT.md

# Prior phase patterns
@.planning/phases/08-registration-foundation/08-01-SUMMARY.md

# Key existing files to reference
@Threa.Dal/Dto/Player.cs
@Threa.Dal/IPlayerDal.cs
@Threa.Dal.MockDb/PlayerDal.cs
@GameMechanics/Player/UserRegistration.cs
@GameMechanics/Player/UserValidation.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Player DTO and IPlayerDal for Recovery</name>
  <files>Threa.Dal/Dto/Player.cs, Threa.Dal/IPlayerDal.cs</files>
  <action>
**1. Add lockout tracking fields to Player DTO (Threa.Dal/Dto/Player.cs):**

Add after the SecretAnswer property:
```csharp
public int FailedRecoveryAttempts { get; set; } = 0;
public DateTime? RecoveryLockoutUntil { get; set; }
```

**2. Add recovery methods to IPlayerDal (Threa.Dal/IPlayerDal.cs):**

Add these method signatures:
```csharp
/// <summary>
/// Gets the secret question for a username. Returns null if user not found (prevents enumeration).
/// </summary>
Task<string?> GetSecretQuestionAsync(string username);

/// <summary>
/// Validates the secret answer. Returns true if correct and not locked out.
/// Increments failed attempts on wrong answer. Clears attempts on success.
/// </summary>
Task<bool> ValidateSecretAnswerAsync(string username, string answer);

/// <summary>
/// Resets password for username. Should only be called after successful answer validation.
/// </summary>
Task ResetPasswordAsync(string username, string newPassword);

/// <summary>
/// Checks if user is currently locked out from recovery attempts.
/// </summary>
Task<bool> IsRecoveryLockedOutAsync(string username);

/// <summary>
/// Gets the number of remaining recovery attempts before lockout.
/// </summary>
Task<int> GetRemainingRecoveryAttemptsAsync(string username);
```

Note: These methods use username (not id) because the user doesn't have their id during recovery.
  </action>
  <verify>
Build succeeds: `dotnet build Threa.Dal/Threa.Dal.csproj`
  </verify>
  <done>Player DTO has lockout fields, IPlayerDal has all recovery method signatures.</done>
</task>

<task type="auto">
  <name>Task 2: Implement MockDb PlayerDal Recovery Methods</name>
  <files>Threa.Dal.MockDb/PlayerDal.cs</files>
  <action>
Implement the new IPlayerDal methods in MockDb PlayerDal:

```csharp
public Task<string?> GetSecretQuestionAsync(string username)
{
    lock (MockDb.Players)
    {
        var player = MockDb.Players.FirstOrDefault(p => p.Email == username);
        // Return null for unknown user (prevents enumeration)
        return Task.FromResult(player?.SecretQuestion);
    }
}

public Task<bool> IsRecoveryLockedOutAsync(string username)
{
    lock (MockDb.Players)
    {
        var player = MockDb.Players.FirstOrDefault(p => p.Email == username);
        if (player == null) return Task.FromResult(false);

        var isLockedOut = player.RecoveryLockoutUntil.HasValue &&
                          player.RecoveryLockoutUntil.Value > DateTime.UtcNow;
        return Task.FromResult(isLockedOut);
    }
}

public Task<int> GetRemainingRecoveryAttemptsAsync(string username)
{
    lock (MockDb.Players)
    {
        var player = MockDb.Players.FirstOrDefault(p => p.Email == username);
        if (player == null) return Task.FromResult(3); // Default for unknown (don't reveal)

        const int maxAttempts = 3;
        var remaining = maxAttempts - player.FailedRecoveryAttempts;
        return Task.FromResult(remaining > 0 ? remaining : 0);
    }
}

public Task<bool> ValidateSecretAnswerAsync(string username, string answer)
{
    lock (MockDb.Players)
    {
        var player = MockDb.Players.FirstOrDefault(p => p.Email == username);
        if (player == null) return Task.FromResult(false);

        // Check lockout
        if (player.RecoveryLockoutUntil.HasValue &&
            player.RecoveryLockoutUntil.Value > DateTime.UtcNow)
        {
            return Task.FromResult(false);
        }

        // Clear expired lockout
        if (player.RecoveryLockoutUntil.HasValue &&
            player.RecoveryLockoutUntil.Value <= DateTime.UtcNow)
        {
            player.FailedRecoveryAttempts = 0;
            player.RecoveryLockoutUntil = null;
        }

        // Normalize answer (trim + lowercase) and compare
        var normalizedAnswer = answer?.Trim().ToLowerInvariant() ?? string.Empty;
        var isCorrect = player.SecretAnswer == normalizedAnswer;

        if (isCorrect)
        {
            // Reset attempts on success
            player.FailedRecoveryAttempts = 0;
            player.RecoveryLockoutUntil = null;
        }
        else
        {
            // Increment failed attempts
            player.FailedRecoveryAttempts++;

            // Lockout after 3 failed attempts (15 minutes)
            if (player.FailedRecoveryAttempts >= 3)
            {
                player.RecoveryLockoutUntil = DateTime.UtcNow.AddMinutes(15);
            }
        }

        return Task.FromResult(isCorrect);
    }
}

public Task ResetPasswordAsync(string username, string newPassword)
{
    lock (MockDb.Players)
    {
        var player = MockDb.Players.FirstOrDefault(p => p.Email == username);
        if (player == null)
            throw new NotFoundException($"Player {username}");

        // Hash new password with BCrypt
        var salt = BCrypt.Net.BCrypt.GenerateSalt(12);
        player.Salt = salt;
        player.HashedPassword = BCrypt.Net.BCrypt.HashPassword(newPassword, salt);

        // Clear recovery state
        player.FailedRecoveryAttempts = 0;
        player.RecoveryLockoutUntil = null;

        return Task.CompletedTask;
    }
}
```

Required using: `using System;` (for DateTime)
  </action>
  <verify>
Build succeeds: `dotnet build Threa.Dal.MockDb/Threa.Dal.MockDb.csproj`
  </verify>
  <done>MockDb PlayerDal implements all recovery methods with lockout logic.</done>
</task>

<task type="auto">
  <name>Task 3: Create PasswordRecovery Business Object and Tests</name>
  <files>GameMechanics/Player/PasswordRecovery.cs, GameMechanics.Test/PasswordRecoveryTests.cs</files>
  <action>
**1. Create PasswordRecovery CSLA command object (GameMechanics/Player/PasswordRecovery.cs):**

This is a CSLA CommandBase for the multi-step recovery workflow. Use Execute pattern (not Create/Insert) since this is a command, not a persisted entity.

```csharp
using System;
using System.Threading.Tasks;
using Csla;
using Threa.Dal;

namespace GameMechanics.Player;

/// <summary>
/// CSLA command for password recovery workflow.
/// Step 1: GetSecretQuestion - Fetches question for username
/// Step 2: ValidateAnswer - Validates secret answer
/// Step 3: ResetPassword - Sets new password
/// </summary>
[Serializable]
public class PasswordRecovery : CommandBase<PasswordRecovery>
{
    #region Properties

    public static readonly PropertyInfo<string> UsernameProperty = RegisterProperty<string>(nameof(Username));
    public string Username
    {
        get => ReadProperty(UsernameProperty);
        set => LoadProperty(UsernameProperty, value);
    }

    public static readonly PropertyInfo<string> SecretQuestionProperty = RegisterProperty<string>(nameof(SecretQuestion));
    public string SecretQuestion
    {
        get => ReadProperty(SecretQuestionProperty);
        private set => LoadProperty(SecretQuestionProperty, value);
    }

    public static readonly PropertyInfo<string> SecretAnswerProperty = RegisterProperty<string>(nameof(SecretAnswer));
    public string SecretAnswer
    {
        get => ReadProperty(SecretAnswerProperty);
        set => LoadProperty(SecretAnswerProperty, value);
    }

    public static readonly PropertyInfo<string> NewPasswordProperty = RegisterProperty<string>(nameof(NewPassword));
    public string NewPassword
    {
        get => ReadProperty(NewPasswordProperty);
        set => LoadProperty(NewPasswordProperty, value);
    }

    public static readonly PropertyInfo<bool> IsAnswerValidProperty = RegisterProperty<bool>(nameof(IsAnswerValid));
    public bool IsAnswerValid
    {
        get => ReadProperty(IsAnswerValidProperty);
        private set => LoadProperty(IsAnswerValidProperty, value);
    }

    public static readonly PropertyInfo<bool> IsLockedOutProperty = RegisterProperty<bool>(nameof(IsLockedOut));
    public bool IsLockedOut
    {
        get => ReadProperty(IsLockedOutProperty);
        private set => LoadProperty(IsLockedOutProperty, value);
    }

    public static readonly PropertyInfo<int> RemainingAttemptsProperty = RegisterProperty<int>(nameof(RemainingAttempts));
    public int RemainingAttempts
    {
        get => ReadProperty(RemainingAttemptsProperty);
        private set => LoadProperty(RemainingAttemptsProperty, value);
    }

    public static readonly PropertyInfo<bool> PasswordResetSuccessProperty = RegisterProperty<bool>(nameof(PasswordResetSuccess));
    public bool PasswordResetSuccess
    {
        get => ReadProperty(PasswordResetSuccessProperty);
        private set => LoadProperty(PasswordResetSuccessProperty, value);
    }

    public static readonly PropertyInfo<string> ErrorMessageProperty = RegisterProperty<string>(nameof(ErrorMessage));
    public string ErrorMessage
    {
        get => ReadProperty(ErrorMessageProperty);
        private set => LoadProperty(ErrorMessageProperty, value);
    }

    #endregion

    #region Factory Methods

    public static async Task<PasswordRecovery> GetSecretQuestionAsync(string username, IDataPortal<PasswordRecovery> portal)
    {
        var cmd = await portal.CreateAsync();
        cmd.Username = username;
        return await portal.ExecuteAsync(cmd);
    }

    #endregion

    #region Execute

    [Execute]
    private async Task ExecuteAsync([Inject] IPlayerDal dal)
    {
        // If NewPassword is set, this is Step 3 (reset password)
        if (!string.IsNullOrEmpty(NewPassword))
        {
            await ExecuteResetPasswordAsync(dal);
            return;
        }

        // If SecretAnswer is set, this is Step 2 (validate answer)
        if (!string.IsNullOrEmpty(SecretAnswer))
        {
            await ExecuteValidateAnswerAsync(dal);
            return;
        }

        // Otherwise, this is Step 1 (get secret question)
        await ExecuteGetSecretQuestionAsync(dal);
    }

    private async Task ExecuteGetSecretQuestionAsync(IPlayerDal dal)
    {
        // Check lockout first
        IsLockedOut = await dal.IsRecoveryLockedOutAsync(Username);
        if (IsLockedOut)
        {
            ErrorMessage = "Too many failed attempts. Please try again later.";
            return;
        }

        // Get secret question (returns null for unknown user)
        var question = await dal.GetSecretQuestionAsync(Username);

        // Return generic message even if user not found (prevent enumeration)
        // The UI will show "If that username exists..." message
        SecretQuestion = question ?? string.Empty;
        RemainingAttempts = await dal.GetRemainingRecoveryAttemptsAsync(Username);
    }

    private async Task ExecuteValidateAnswerAsync(IPlayerDal dal)
    {
        // Check lockout first
        IsLockedOut = await dal.IsRecoveryLockedOutAsync(Username);
        if (IsLockedOut)
        {
            ErrorMessage = "Too many failed attempts. Please try again later.";
            return;
        }

        // Validate answer
        IsAnswerValid = await dal.ValidateSecretAnswerAsync(Username, SecretAnswer);
        RemainingAttempts = await dal.GetRemainingRecoveryAttemptsAsync(Username);

        if (!IsAnswerValid)
        {
            // Check if now locked out
            IsLockedOut = await dal.IsRecoveryLockedOutAsync(Username);
            if (IsLockedOut)
            {
                ErrorMessage = "Too many failed attempts. Please try again later.";
            }
            else
            {
                ErrorMessage = $"Incorrect answer. You have {RemainingAttempts} attempt(s) remaining.";
            }
        }
    }

    private async Task ExecuteResetPasswordAsync(IPlayerDal dal)
    {
        // Validate password length
        if (string.IsNullOrEmpty(NewPassword) || NewPassword.Length < 6)
        {
            ErrorMessage = "Password must be at least 6 characters.";
            PasswordResetSuccess = false;
            return;
        }

        try
        {
            await dal.ResetPasswordAsync(Username, NewPassword);
            PasswordResetSuccess = true;
        }
        catch (NotFoundException)
        {
            ErrorMessage = "Password reset failed. Please try again.";
            PasswordResetSuccess = false;
        }
    }

    #endregion
}
```

**2. Create unit tests (GameMechanics.Test/PasswordRecoveryTests.cs):**

```csharp
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Csla;
using Csla.Configuration;
using GameMechanics.Player;
using Microsoft.Extensions.DependencyInjection;
using Threa.Dal;
using Threa.Dal.MockDb;

namespace GameMechanics.Test;

[TestClass]
[DoNotParallelize]
public class PasswordRecoveryTests
{
    private static IServiceProvider? _serviceProvider;
    private static IDataPortal<PasswordRecovery>? _portal;

    [ClassInitialize]
    public static void ClassInit(TestContext context)
    {
        var services = new ServiceCollection();
        services.AddCsla(o => o.AddAspNetCore());
        services.AddTransient<IPlayerDal, PlayerDal>();
        _serviceProvider = services.BuildServiceProvider();
        _portal = _serviceProvider.GetRequiredService<IDataPortal<PasswordRecovery>>();
    }

    [TestInitialize]
    public void TestInit()
    {
        // Clear MockDb before each test
        MockDb.Clear();
    }

    private async Task<int> CreateTestUser(string username = "testuser", string secretAnswer = "test answer")
    {
        // Create a test user with known credentials
        var registrationPortal = _serviceProvider!.GetRequiredService<IDataPortal<UserRegistration>>();
        var registration = await registrationPortal.CreateAsync();
        registration.Username = username;
        registration.Password = "password123";
        registration.SecretQuestion = "What is your test question?";
        registration.SecretAnswer = secretAnswer;
        registration = await registration.SaveAsync();
        return registration.Id;
    }

    [TestMethod]
    public async Task GetSecretQuestion_ExistingUser_ReturnsQuestion()
    {
        // Arrange
        await CreateTestUser("testuser");

        // Act
        var cmd = await _portal!.CreateAsync();
        cmd.Username = "testuser";
        cmd = await _portal.ExecuteAsync(cmd);

        // Assert
        Assert.AreEqual("What is your test question?", cmd.SecretQuestion);
        Assert.IsFalse(cmd.IsLockedOut);
        Assert.AreEqual(3, cmd.RemainingAttempts);
    }

    [TestMethod]
    public async Task GetSecretQuestion_UnknownUser_ReturnsEmptyQuestion()
    {
        // Act - no user created
        var cmd = await _portal!.CreateAsync();
        cmd.Username = "unknownuser";
        cmd = await _portal.ExecuteAsync(cmd);

        // Assert - empty question but no error (prevent enumeration)
        Assert.AreEqual(string.Empty, cmd.SecretQuestion);
        Assert.IsFalse(cmd.IsLockedOut);
    }

    [TestMethod]
    public async Task ValidateAnswer_CorrectAnswer_ReturnsValid()
    {
        // Arrange
        await CreateTestUser("testuser", "my secret");

        // Act
        var cmd = await _portal!.CreateAsync();
        cmd.Username = "testuser";
        cmd.SecretAnswer = "My Secret"; // Different case, extra spaces ok via trim
        cmd = await _portal.ExecuteAsync(cmd);

        // Assert
        Assert.IsTrue(cmd.IsAnswerValid);
        Assert.IsFalse(cmd.IsLockedOut);
    }

    [TestMethod]
    public async Task ValidateAnswer_WrongAnswer_ReturnsInvalid()
    {
        // Arrange
        await CreateTestUser("testuser", "correct answer");

        // Act
        var cmd = await _portal!.CreateAsync();
        cmd.Username = "testuser";
        cmd.SecretAnswer = "wrong answer";
        cmd = await _portal.ExecuteAsync(cmd);

        // Assert
        Assert.IsFalse(cmd.IsAnswerValid);
        Assert.AreEqual(2, cmd.RemainingAttempts);
        Assert.IsFalse(cmd.IsLockedOut);
    }

    [TestMethod]
    public async Task ValidateAnswer_ThreeWrongAttempts_LocksOut()
    {
        // Arrange
        await CreateTestUser("testuser", "correct answer");

        // Act - 3 wrong attempts
        for (int i = 0; i < 3; i++)
        {
            var cmd = await _portal!.CreateAsync();
            cmd.Username = "testuser";
            cmd.SecretAnswer = "wrong answer";
            cmd = await _portal.ExecuteAsync(cmd);
        }

        // Assert - next attempt should show locked out
        var checkCmd = await _portal!.CreateAsync();
        checkCmd.Username = "testuser";
        checkCmd = await _portal.ExecuteAsync(checkCmd);

        Assert.IsTrue(checkCmd.IsLockedOut);
        Assert.IsTrue(checkCmd.ErrorMessage.Contains("Too many failed attempts"));
    }

    [TestMethod]
    public async Task ResetPassword_ValidPassword_Succeeds()
    {
        // Arrange
        await CreateTestUser("testuser", "secret");

        // Act
        var cmd = await _portal!.CreateAsync();
        cmd.Username = "testuser";
        cmd.NewPassword = "newpassword123";
        cmd = await _portal.ExecuteAsync(cmd);

        // Assert
        Assert.IsTrue(cmd.PasswordResetSuccess);
        Assert.AreEqual(string.Empty, cmd.ErrorMessage);
    }

    [TestMethod]
    public async Task ResetPassword_ShortPassword_Fails()
    {
        // Arrange
        await CreateTestUser("testuser", "secret");

        // Act
        var cmd = await _portal!.CreateAsync();
        cmd.Username = "testuser";
        cmd.NewPassword = "short"; // Less than 6 chars
        cmd = await _portal.ExecuteAsync(cmd);

        // Assert
        Assert.IsFalse(cmd.PasswordResetSuccess);
        Assert.IsTrue(cmd.ErrorMessage.Contains("at least 6 characters"));
    }

    [TestMethod]
    public async Task ValidateAnswer_CaseInsensitive_Succeeds()
    {
        // Arrange - answer stored as lowercase trimmed
        await CreateTestUser("testuser", "My Secret Answer");

        // Act - provide different case with extra spaces
        var cmd = await _portal!.CreateAsync();
        cmd.Username = "testuser";
        cmd.SecretAnswer = "  MY SECRET ANSWER  ";
        cmd = await _portal.ExecuteAsync(cmd);

        // Assert
        Assert.IsTrue(cmd.IsAnswerValid);
    }
}
```

Add `[DoNotParallelize]` attribute since tests modify shared MockDb state.
  </action>
  <verify>
1. Build succeeds: `dotnet build GameMechanics/GameMechanics.csproj`
2. Tests pass: `dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "FullyQualifiedName~PasswordRecoveryTests"`
  </verify>
  <done>PasswordRecovery CSLA command exists with step-based execution, unit tests pass for all recovery scenarios.</done>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` - All projects compile
2. `dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "FullyQualifiedName~PasswordRecoveryTests"` - All recovery tests pass
3. `dotnet test GameMechanics.Test/GameMechanics.Test.csproj` - All tests pass (including existing)
4. Player DTO has FailedRecoveryAttempts and RecoveryLockoutUntil properties
5. IPlayerDal has GetSecretQuestionAsync, ValidateSecretAnswerAsync, ResetPasswordAsync methods
6. PasswordRecovery.cs exists with Username, SecretQuestion, SecretAnswer, NewPassword, IsAnswerValid, IsLockedOut, RemainingAttempts properties
</verification>

<success_criteria>
- Player DTO extended with FailedRecoveryAttempts (int), RecoveryLockoutUntil (DateTime?) properties
- IPlayerDal extended with GetSecretQuestionAsync, ValidateSecretAnswerAsync, ResetPasswordAsync, IsRecoveryLockedOutAsync, GetRemainingRecoveryAttemptsAsync methods
- MockDb PlayerDal implements all recovery methods with:
  - Case-insensitive, trimmed answer validation
  - 3-attempt lockout with 15-minute duration
  - BCrypt password hashing on reset
- PasswordRecovery CSLA CommandBase with step-based execution:
  - Step 1: Get secret question (empty for unknown user)
  - Step 2: Validate answer with attempt tracking
  - Step 3: Reset password with min 6 char validation
- Unit tests verify all scenarios including lockout behavior
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-password-recovery/09-01-SUMMARY.md`
</output>
