---
phase: 22-concentration-system
plan: 04
type: execute
wave: 4
depends_on: ["22-03"]
files_modified:
  - GameMechanics/CharacterEdit.cs
  - GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs
  - GameMechanics.Test/ConcentrationCheckTests.cs
autonomous: true
estimated_minutes: 25
gap_closure: true

must_haves:
  truths:
    - "CharacterEdit.GetConcentrationEffect returns the active concentration effect or null"
    - "CharacterEdit.GetConcentrationType returns the concentration type string or null"
    - "CharacterEdit.CheckConcentration calculates Focus AS + 4dF+ vs TV with damage penalty"
    - "CheckConcentration returns ConcentrationCheckResult with Success, Roll, AS, TV, DamagePenalty"
    - "Failed concentration check calls BreakConcentration automatically"
  artifacts:
    - path: "GameMechanics/CharacterEdit.cs"
      provides: "GetConcentrationEffect, GetConcentrationType, CheckConcentration, ConcentrationCheckResult"
      contains: "GetConcentrationEffect|GetConcentrationType|CheckConcentration|ConcentrationCheckResult"
    - path: "GameMechanics.Test/ConcentrationCheckTests.cs"
      provides: "Tests for concentration check mechanics"
      min_lines: 60
  key_links:
    - from: "CharacterEdit.CheckConcentration"
      to: "IDiceRoller"
      via: "injects dice roller for testability"
      pattern: "Roll4dFPlus|IDiceRoller"
    - from: "CharacterEdit.CheckConcentration"
      to: "CharacterEdit.BreakConcentration"
      via: "calls BreakConcentration on failure"
      pattern: "BreakConcentration"
---

<objective>
Implement CharacterEdit concentration methods: GetConcentrationEffect, GetConcentrationType, CheckConcentration with Focus skill check and damage penalty.

Purpose: Enable concentration checks when defending passively and provide character-level API for concentration state queries.

Output: CharacterEdit methods for concentration state and checks, ConcentrationCheckResult class, and tests.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/22-concentration-system/22-CONTEXT.md
@.planning/phases/22-concentration-system/22-03-SUMMARY.md

Key context:
- ConcentrationBehavior has static IsConcentrating(CharacterEdit) method
- ConcentrationBehavior has static BreakConcentration(CharacterEdit, string) method
- Focus skill check: Focus AS + 4dF+ vs TV (attacker's AV)
- Damage penalty: -1 per 2 points of damage dealt (rounded down)
- If check fails, concentration breaks automatically
- IDiceRoller pattern used throughout project for testability

Design spec (from CONCENTRATION_SYSTEM.md):
```
Concentration Check = Focus Skill AS + 4dF+ vs Attacker's AV
Damage Penalty = -1 per 2 points of damage dealt (round down)
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ConcentrationCheckResult class</name>
  <files>GameMechanics/CharacterEdit.cs</files>
  <action>
Add a new class at the end of the CharacterEdit.cs file (or in a separate file if the project prefers - check existing patterns):

```csharp
/// <summary>
/// Result of a concentration check when defending passively while concentrating.
/// </summary>
public class ConcentrationCheckResult
{
    /// <summary>
    /// True if concentration was maintained, false if broken.
    /// </summary>
    public bool Success { get; set; }

    /// <summary>
    /// The Ability Score used (Focus AS with damage penalty applied).
    /// </summary>
    public int AS { get; set; }

    /// <summary>
    /// The 4dF+ roll result.
    /// </summary>
    public int Roll { get; set; }

    /// <summary>
    /// The total result (AS + Roll).
    /// </summary>
    public int Result { get; set; }

    /// <summary>
    /// The Target Value (attacker's AV).
    /// </summary>
    public int TV { get; set; }

    /// <summary>
    /// The damage penalty applied (-1 per 2 damage).
    /// </summary>
    public int DamagePenalty { get; set; }

    /// <summary>
    /// Reason for failure (if Success is false).
    /// </summary>
    public string? Reason { get; set; }
}
```
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>ConcentrationCheckResult class exists with Success, AS, Roll, Result, TV, DamagePenalty, Reason properties</done>
</task>

<task type="auto">
  <name>Task 2: Add GetConcentrationEffect method</name>
  <files>GameMechanics/CharacterEdit.cs</files>
  <action>
Add instance method to CharacterEdit (near the Effects property or with other effect-related methods):

```csharp
/// <summary>
/// Gets the active concentration effect on this character, if any.
/// </summary>
/// <returns>The concentration effect, or null if not concentrating</returns>
public EffectRecord? GetConcentrationEffect()
{
    foreach (var effect in Effects)
    {
        if (effect.EffectType == Threa.Dal.Dto.EffectType.Concentration)
            return effect;
    }
    return null;
}
```

Note: The static IsConcentrating method in ConcentrationBehavior uses the same pattern. This instance method provides easier access from CharacterEdit.
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>GetConcentrationEffect returns concentration effect or null</done>
</task>

<task type="auto">
  <name>Task 3: Add GetConcentrationType method</name>
  <files>GameMechanics/CharacterEdit.cs</files>
  <action>
Add instance method to CharacterEdit:

```csharp
/// <summary>
/// Gets the type of concentration the character is performing.
/// </summary>
/// <returns>The concentration type (e.g., "MagazineReload", "SustainedSpell"), or null if not concentrating</returns>
public string? GetConcentrationType()
{
    var effect = GetConcentrationEffect();
    if (effect == null)
        return null;

    var state = GameMechanics.Effects.Behaviors.ConcentrationState.FromJson(effect.BehaviorState);
    return state?.ConcentrationType;
}
```

Add using statement if not present: `using GameMechanics.Effects.Behaviors;`
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>GetConcentrationType returns concentration type string or null</done>
</task>

<task type="auto">
  <name>Task 4: Implement CheckConcentration method</name>
  <files>GameMechanics/CharacterEdit.cs</files>
  <action>
Add the CheckConcentration method to CharacterEdit. This method performs a concentration check using the Focus skill.

First, find how the project gets dice roller and Focus skill. Check existing combat/action methods in CharacterEdit or resolvers.

Then add:

```csharp
/// <summary>
/// Performs a concentration check against an attacker's AV.
/// Called when the character uses passive defense while concentrating.
/// </summary>
/// <param name="attackerAV">The attacker's Attack Value (target value for the check)</param>
/// <param name="damageDealt">Damage dealt by the attack (applies -1 per 2 damage penalty)</param>
/// <param name="diceRoller">Dice roller for testability</param>
/// <returns>Result of the concentration check</returns>
public ConcentrationCheckResult CheckConcentration(int attackerAV, int damageDealt, IDiceRoller diceRoller)
{
    // Check if actually concentrating
    if (GetConcentrationEffect() == null)
    {
        return new ConcentrationCheckResult
        {
            Success = true,  // Not concentrating, no check needed
            Reason = "Not concentrating"
        };
    }

    // Find Focus skill
    var focusSkill = Skills.FirstOrDefault(s =>
        s.Name.Equals("Focus", StringComparison.OrdinalIgnoreCase));

    if (focusSkill == null)
    {
        // No Focus skill - automatic failure
        ConcentrationBehavior.BreakConcentration(this, "No Focus skill - concentration broken");
        return new ConcentrationCheckResult
        {
            Success = false,
            Reason = "No Focus skill",
            TV = attackerAV
        };
    }

    // Calculate damage penalty: -1 per 2 damage dealt (round down)
    int damagePenalty = -(damageDealt / 2);

    // Calculate Focus AS
    // AS = Attribute + Skill Level - 5 + Modifiers
    // Focus uses WIL attribute
    int focusAS = focusSkill.AbilityScore + damagePenalty;

    // Roll 4dF+
    int roll = diceRoller.Roll4dFPlus();

    // Calculate result
    int result = focusAS + roll;
    bool success = result >= attackerAV;

    // Break concentration if failed
    if (!success)
    {
        string reason = $"Failed concentration check ({result} vs {attackerAV})";
        ConcentrationBehavior.BreakConcentration(this, reason);
    }

    return new ConcentrationCheckResult
    {
        Success = success,
        AS = focusAS,
        Roll = roll,
        Result = result,
        TV = attackerAV,
        DamagePenalty = damagePenalty,
        Reason = success ? null : "Check failed"
    };
}
```

Notes:
- Check how Skills collection works in CharacterEdit
- The AbilityScore property on skills may need to be calculated differently
- Adjust the Focus AS calculation based on actual skill/attribute patterns in the codebase
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>CheckConcentration calculates Focus AS + 4dF+ vs TV with damage penalty and breaks concentration on failure</done>
</task>

<task type="auto">
  <name>Task 5: Add convenience method without dice roller</name>
  <files>GameMechanics/CharacterEdit.cs</files>
  <action>
Add an overload that uses the default dice roller for non-test scenarios:

```csharp
/// <summary>
/// Performs a concentration check against an attacker's AV using default dice roller.
/// </summary>
/// <param name="attackerAV">The attacker's Attack Value (target value for the check)</param>
/// <param name="damageDealt">Damage dealt by the attack (applies -1 per 2 damage penalty)</param>
/// <returns>Result of the concentration check</returns>
public ConcentrationCheckResult CheckConcentration(int attackerAV, int damageDealt)
{
    return CheckConcentration(attackerAV, damageDealt, new Dice());
}
```

Note: Check what the default dice roller class is called in this project (likely `Dice` or `DiceRoller`).
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>CheckConcentration overload uses default dice roller</done>
</task>

<task type="auto">
  <name>Task 6: Create concentration check tests</name>
  <files>GameMechanics.Test/ConcentrationCheckTests.cs</files>
  <action>
Create a new test file for concentration check mechanics. Use DeterministicDiceRoller for predictable results.

Tests to include:
1. CheckConcentration_NotConcentrating_ReturnsSuccess - returns Success=true with no check
2. CheckConcentration_NoFocusSkill_AutomaticFailure - breaks concentration when Focus skill missing
3. CheckConcentration_SuccessfulCheck_MaintainsConcentration - passes when roll + AS >= TV
4. CheckConcentration_FailedCheck_BreaksConcentration - fails and breaks when roll + AS < TV
5. CheckConcentration_DamagePenalty_Applied - verifies -1 per 2 damage penalty
6. CheckConcentration_ZeroDamage_NoPenalty - no penalty when no damage dealt
7. GetConcentrationEffect_WhenConcentrating_ReturnsEffect
8. GetConcentrationType_WhenConcentrating_ReturnsType

Use the test patterns established in the project:
- DeterministicDiceRoller for controlled roll results
- Set up character with Focus skill and concentration effect
- Verify concentration is broken/maintained as expected
  </action>
  <verify>dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "FullyQualifiedName~ConcentrationCheckTests"</verify>
  <done>All 8 tests pass covering concentration check calculations and edge cases</done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build Threa.sln`
2. Tests pass: `dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "FullyQualifiedName~ConcentrationCheck"`
3. Code review:
   - ConcentrationCheckResult has all required properties
   - GetConcentrationEffect returns correct effect or null
   - GetConcentrationType returns correct type string or null
   - CheckConcentration uses Focus skill AS + 4dF+ vs TV
   - CheckConcentration applies -1 per 2 damage penalty
   - CheckConcentration calls BreakConcentration on failure
   - Tests use DeterministicDiceRoller for predictable results
</verification>

<success_criteria>
- ConcentrationCheckResult class exists with Success, AS, Roll, Result, TV, DamagePenalty, Reason
- GetConcentrationEffect returns the active concentration effect or null
- GetConcentrationType returns the concentration type string or null
- CheckConcentration calculates Focus AS + 4dF+ vs attackerAV
- CheckConcentration applies damage penalty: -1 per 2 damage dealt
- Failed concentration check automatically breaks concentration
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-concentration-system/22-04-SUMMARY.md`
</output>

---

## Notes

**Focus Skill Lookup**: The Focus skill is used for concentration checks per the design spec. If the skill doesn't exist on a character, concentration automatically fails. This encourages characters to take Focus skill if they plan to use concentration-heavy abilities.

**Damage Penalty Formula**: `-1 per 2 damage dealt (round down)`
- 0 damage = 0 penalty
- 1 damage = 0 penalty
- 2 damage = -1 penalty
- 3 damage = -1 penalty
- 4 damage = -2 penalty
- etc.

**IDiceRoller Pattern**: Following the project's testability pattern, CheckConcentration accepts IDiceRoller. Tests use DeterministicDiceRoller for predictable outcomes, while production code uses the default Dice class.

**Integration Points**:
- Plan 22-06 (Defense Integration) will call CheckConcentration after passive defense damage resolution
- The concentration check happens regardless of hit/miss, but damage penalty only applies if damage was dealt

---

*Plan created: 2026-01-29*
*Gap closure for: Passive defense triggers concentration check with damage penalty*
