---
phase: 22-concentration-system
plan: 07
type: execute
wave: 6
depends_on: ["22-05", "22-06"]
files_modified:
  - Threa/Threa.Client/Components/Shared/ConcentrationIndicator.razor
  - Threa/Threa.Client/Components/Shared/ConcentrationIndicator.razor.cs
  - Threa/Threa.Client/Components/Pages/GamePlay/TabStatus.razor
  - Threa/Threa.Client/Components/Shared/CharacterStatusCard.razor
  - Threa/Threa.Client/Components/Pages/GamePlay/Play.razor
  - Threa/Threa.Client/Components/Pages/GamePlay/Play.razor.cs
  - Threa/Threa.Client/wwwroot/css/app.css
autonomous: true
estimated_minutes: 45
gap_closure: true

must_haves:
  truths:
    - "ConcentrationIndicator displays concentration type and name"
    - "Casting-time concentration shows progress bar (X/Y rounds)"
    - "Sustained concentration shows linked effect count and drain rate"
    - "Indicator visible in TabStatus for player view"
    - "Indicator visible in CharacterStatusCard for GM dashboard"
    - "Drop Concentration button available for voluntary break"
    - "Magazine reload completion updates weapon CurrentRounds from LastConcentrationResult"
    - "Sustained concentration break removes linked effects from all table characters"
  artifacts:
    - path: "Threa/Threa.Client/Components/Shared/ConcentrationIndicator.razor"
      provides: "Reusable concentration status display component"
      min_lines: 40
    - path: "Threa/Threa.Client/Components/Shared/ConcentrationIndicator.razor.cs"
      provides: "Component logic for concentration display"
      min_lines: 30
    - path: "Threa/Threa.Client/Components/Pages/GamePlay/Play.razor.cs"
      provides: "LastConcentrationResult processing for magazine reload and sustained break"
      contains: "ProcessConcentrationResult|MagazineReload|SustainedBreak|LinkedEffectIds"
  key_links:
    - from: "TabStatus.razor"
      to: "ConcentrationIndicator"
      via: "renders when character is concentrating"
      pattern: "ConcentrationIndicator.*IsConcentrating"
    - from: "CharacterStatusCard.razor"
      to: "ConcentrationIndicator"
      via: "renders when character is concentrating"
      pattern: "ConcentrationIndicator.*IsConcentrating"
    - from: "Play.razor.cs ProcessConcentrationResult"
      to: "CharacterItem.CurrentRounds"
      via: "MagazineReloadPayload updates weapon"
      pattern: "MagazineReload.*CurrentRounds"
    - from: "Play.razor.cs ProcessConcentrationResult"
      to: "EffectList.RemoveEffect"
      via: "SustainedBreak removes linked effects from targets"
      pattern: "SustainedBreak.*LinkedEffectIds.*RemoveEffect"
---

<objective>
Create UI components to display concentration status and process LastConcentrationResult for magazine reload completion and sustained effect removal.

Purpose: Players and GMs need visibility into concentration state, and the UI layer must handle the deferred actions when concentration completes or breaks - updating weapon ammo for magazine reload and removing linked effects for sustained concentration break.

Output: ConcentrationIndicator component integrated into TabStatus and CharacterStatusCard, plus LastConcentrationResult processing in Play.razor.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/22-concentration-system/22-CONTEXT.md
@.planning/phases/22-concentration-system/22-05-SUMMARY.md
@.planning/phases/22-concentration-system/22-06-SUMMARY.md

Key context:
- ConcentrationBehavior.IsConcentrating(character) checks concentration status
- CharacterEdit.GetConcentrationEffect() returns the active concentration effect
- CharacterEdit.GetConcentrationType() returns the concentration type
- CharacterEdit.LastConcentrationResult stores completion/interruption result from behaviors
- ConcentrationCompletionResult has ActionType, Payload, Message, Success properties
- MagazineReloadPayload has WeaponItemId, MagazineItemId, RoundsToLoad
- ConcentrationState has SpellName, CurrentProgress, TotalRequired, LinkedEffectIds, FatDrainPerRound, VitDrainPerRound
- ConcentrationBehavior.BreakConcentration(character, reason) for voluntary drop
- Radzen components (RadzenProgressBar, RadzenBadge) for UI elements
- TabStatus.razor displays character status for player
- CharacterStatusCard.razor displays character summary for GM dashboard
- Play.razor is the main gameplay page with access to all table characters

UI Design (from CONCENTRATION_SYSTEM.md):
- Show concentration icon/badge when concentrating
- Display effect name being concentrated on
- For casting-time: show progress (X of Y rounds)
- For sustained: show linked effects count and drain rate

LastConcentrationResult Processing:
- After effect expiration/removal, check LastConcentrationResult
- If ActionType="MagazineReload" and Success=true: update weapon CurrentRounds
- If ActionType="SustainedBreak": iterate table characters and remove effects matching LinkedEffectIds
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConcentrationIndicator.razor component</name>
  <files>Threa/Threa.Client/Components/Shared/ConcentrationIndicator.razor</files>
  <action>
Create a new Razor component for displaying concentration status:

```razor
@using GameMechanics.Effects.Behaviors
@using Threa.Dal.Dto

@if (IsConcentrating)
{
    <div class="concentration-indicator @(Compact ? "compact" : "")">
        <div class="concentration-header d-flex align-items-center gap-2">
            <RadzenBadge BadgeStyle="BadgeStyle.Warning" IsPill="true">
                <i class="rzi rzi-brain me-1"></i>
                Concentrating
            </RadzenBadge>
            <span class="concentration-name">@GetConcentrationName()</span>
        </div>

        @if (!Compact)
        {
            <div class="concentration-details mt-2">
                @if (IsCastingTime)
                {
                    <div class="progress-section">
                        <small class="text-muted d-block mb-1">
                            @CurrentProgress / @TotalRequired rounds
                        </small>
                        <RadzenProgressBar Value="@ProgressPercent"
                                           Max="100"
                                           ShowValue="false"
                                           Style="height: 8px;" />
                    </div>
                }
                else if (IsSustained)
                {
                    <div class="sustained-section">
                        @if (LinkedEffectCount > 0)
                        {
                            <small class="text-muted d-block">
                                <i class="rzi rzi-link"></i>
                                @LinkedEffectCount linked effect(s)
                            </small>
                        }
                        @if (!string.IsNullOrEmpty(DrainDisplay))
                        {
                            <small class="text-warning d-block">
                                <i class="rzi rzi-flash"></i>
                                @DrainDisplay/round
                            </small>
                        }
                    </div>
                }
            </div>

            @if (ShowDropButton)
            {
                <div class="concentration-actions mt-2">
                    <RadzenButton Text="Drop Concentration"
                                  Size="ButtonSize.Small"
                                  ButtonStyle="ButtonStyle.Light"
                                  Click="@OnDropConcentration" />
                </div>
            }
        }
    </div>
}
```
  </action>
  <verify>Component file exists and contains RadzenBadge and RadzenProgressBar elements</verify>
  <done>ConcentrationIndicator.razor created with concentration type display, progress bar, and drain info</done>
</task>

<task type="auto">
  <name>Task 2: Create ConcentrationIndicator.razor.cs code-behind</name>
  <files>Threa/Threa.Client/Components/Shared/ConcentrationIndicator.razor.cs</files>
  <action>
Create the code-behind file with parameters and computed properties:

```csharp
using Microsoft.AspNetCore.Components;
using GameMechanics;
using GameMechanics.Effects.Behaviors;
using Threa.Dal.Dto;

namespace Threa.Client.Components.Shared;

public partial class ConcentrationIndicator : ComponentBase
{
    /// <summary>
    /// The character to display concentration status for.
    /// </summary>
    [Parameter]
    public CharacterEdit? Character { get; set; }

    /// <summary>
    /// If true, shows compact view (badge only, no progress/details).
    /// </summary>
    [Parameter]
    public bool Compact { get; set; }

    /// <summary>
    /// If true, shows the Drop Concentration button.
    /// </summary>
    [Parameter]
    public bool ShowDropButton { get; set; } = true;

    /// <summary>
    /// Callback when concentration is dropped voluntarily.
    /// </summary>
    [Parameter]
    public EventCallback OnConcentrationDropped { get; set; }

    private bool IsConcentrating => Character != null && ConcentrationBehavior.IsConcentrating(Character);

    private ConcentrationState? State
    {
        get
        {
            if (Character == null) return null;
            var effect = Character.GetConcentrationEffect();
            if (effect == null) return null;
            return ConcentrationState.FromJson(effect.BehaviorState);
        }
    }

    private bool IsCastingTime => State?.ConcentrationType is "MagazineReload" or "SpellCasting" or "RitualPreparation";
    private bool IsSustained => State?.ConcentrationType is "SustainedSpell" or "SustainedAbility" or "MentalControl";

    private int CurrentProgress => State?.CurrentProgress ?? 0;
    private int TotalRequired => State?.TotalRequired ?? 1;
    private int LinkedEffectCount => State?.LinkedEffectIds?.Count ?? 0;

    private double ProgressPercent
    {
        get
        {
            if (TotalRequired <= 0) return 0;
            return Math.Min(100, (double)CurrentProgress / TotalRequired * 100);
        }
    }

    private string? DrainDisplay
    {
        get
        {
            if (State == null) return null;
            var parts = new List<string>();
            if (State.FatDrainPerRound > 0)
                parts.Add($"{State.FatDrainPerRound} FAT");
            if (State.VitDrainPerRound > 0)
                parts.Add($"{State.VitDrainPerRound} VIT");
            return parts.Count > 0 ? string.Join(" + ", parts) : null;
        }
    }

    private string GetConcentrationName()
    {
        if (State?.SpellName != null)
            return State.SpellName;

        var effect = Character?.GetConcentrationEffect();
        if (effect?.Name != null)
            return effect.Name;

        return State?.ConcentrationType ?? "Unknown";
    }

    private async Task OnDropConcentration()
    {
        if (Character != null)
        {
            ConcentrationBehavior.BreakConcentration(Character, "Voluntarily dropped concentration");
            await OnConcentrationDropped.InvokeAsync();
        }
    }
}
```
  </action>
  <verify>dotnet build Threa/Threa.Client/Threa.Client.csproj</verify>
  <done>ConcentrationIndicator.razor.cs created with character parameter, state parsing, and computed properties</done>
</task>

<task type="auto">
  <name>Task 3: Add component styling</name>
  <files>Threa/Threa.Client/wwwroot/css/app.css</files>
  <action>
Add CSS for the concentration indicator at the end of app.css:

```css
/* Concentration Indicator */
.concentration-indicator {
    background: var(--rz-base-100);
    border: 1px solid var(--rz-warning);
    border-left: 4px solid var(--rz-warning);
    border-radius: var(--rz-border-radius);
    padding: 0.75rem;
    margin-bottom: 0.5rem;
}

.concentration-indicator.compact {
    padding: 0.25rem 0.5rem;
    background: transparent;
    border: none;
}

.concentration-indicator .concentration-name {
    font-weight: 500;
    color: var(--rz-text-color);
}

.concentration-indicator .progress-section .rz-progressbar {
    background: var(--rz-base-200);
}

.concentration-indicator .sustained-section small {
    display: flex;
    align-items: center;
    gap: 0.25rem;
}
```
  </action>
  <verify>CSS file contains concentration-indicator class</verify>
  <done>Component styling added with warning accent, progress bar styling, and compact mode</done>
</task>

<task type="auto">
  <name>Task 4: Integrate into TabStatus.razor</name>
  <files>Threa/Threa.Client/Components/Pages/GamePlay/TabStatus.razor</files>
  <action>
Find TabStatus.razor and add the ConcentrationIndicator near the top of the status display (after health pools, before effects list).

Add the component reference:

```razor
@* Near the top of status content, after health bars *@
<ConcentrationIndicator Character="@Character"
                        ShowDropButton="true"
                        OnConcentrationDropped="@OnCharacterChanged" />
```

If there's no OnCharacterChanged callback, use an appropriate callback or create a simple refresh method:

```csharp
private async Task RefreshCharacter()
{
    StateHasChanged();
    // If character needs to be re-fetched, do so here
}
```

Make sure to add the using directive if needed:
```razor
@using Threa.Client.Components.Shared
```
  </action>
  <verify>dotnet build Threa/Threa.Client/Threa.Client.csproj</verify>
  <done>ConcentrationIndicator integrated into TabStatus showing player's concentration status</done>
</task>

<task type="auto">
  <name>Task 5: Integrate into CharacterStatusCard.razor</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterStatusCard.razor</files>
  <action>
Find CharacterStatusCard.razor and add a compact ConcentrationIndicator to show concentration status in the GM dashboard.

Add the component in compact mode (just the badge, no progress details):

```razor
@* In the card body, possibly near the effects count *@
<ConcentrationIndicator Character="@Character"
                        Compact="true"
                        ShowDropButton="false" />
```

For the GM dashboard cards, we want:
- Compact mode (just badge + name)
- No drop button (GM clicks to open modal for detailed view)

Make sure to add the using directive if needed:
```razor
@using Threa.Client.Components.Shared
```
  </action>
  <verify>dotnet build Threa/Threa.Client/Threa.Client.csproj</verify>
  <done>Compact ConcentrationIndicator integrated into CharacterStatusCard for GM dashboard view</done>
</task>

<task type="auto">
  <name>Task 6: Implement ProcessConcentrationResult for magazine reload</name>
  <files>Threa/Threa.Client/Components/Pages/GamePlay/Play.razor.cs</files>
  <action>
Add a method to process LastConcentrationResult after effect expiration. This handles the magazine reload completion (CONC-03).

1. Find where effects are processed (likely after time advancement or effect removal).

2. Add a method to process concentration results:

```csharp
/// <summary>
/// Processes the LastConcentrationResult from a character after concentration ends.
/// Handles magazine reload completion and sustained effect cleanup.
/// </summary>
private async Task ProcessConcentrationResult(CharacterEdit character)
{
    var result = character.LastConcentrationResult;
    if (result == null) return;

    try
    {
        switch (result.ActionType)
        {
            case "MagazineReload":
                if (result.Success)
                {
                    await ExecuteMagazineReload(character, result.Payload);
                    // Show success message
                    NotificationService?.Notify(NotificationSeverity.Success,
                        "Reload Complete", result.Message);
                }
                else
                {
                    // Reload was interrupted
                    NotificationService?.Notify(NotificationSeverity.Warning,
                        "Reload Interrupted", result.Message);
                }
                break;

            case "SustainedBreak":
                await ProcessSustainedBreak(result.Payload);
                NotificationService?.Notify(NotificationSeverity.Info,
                    "Concentration Broken", result.Message);
                break;

            case "SpellCast":
                // TODO: Implement when spell system is ready
                if (result.Success)
                {
                    NotificationService?.Notify(NotificationSeverity.Success,
                        "Spell Cast", result.Message);
                }
                break;
        }
    }
    finally
    {
        // Always clear the result after processing
        character.ClearConcentrationResult();
    }
}
```

3. Add the magazine reload execution method:

```csharp
/// <summary>
/// Executes the magazine reload by updating the weapon's CurrentRounds.
/// </summary>
private async Task ExecuteMagazineReload(CharacterEdit character, string? payloadJson)
{
    if (string.IsNullOrEmpty(payloadJson)) return;

    var payload = MagazineReloadPayload.FromJson(payloadJson);
    if (payload == null) return;

    // Find the weapon item and update its CurrentRounds
    // The weapon should be in the character's inventory
    var weapon = character.Items?.FirstOrDefault(i => i.Id == payload.WeaponItemId);
    if (weapon != null)
    {
        weapon.CurrentRounds = payload.RoundsToLoad;
        // Save the character to persist the change
        await SaveCharacterAsync(character);
    }
}
```

4. Call ProcessConcentrationResult after time advancement or effect processing:
   - Look for where AdvanceRound or ProcessEndOfRound is called
   - After effects are processed, check each character's LastConcentrationResult
   - Pattern: after time/effects processing, iterate table characters and call ProcessConcentrationResult
  </action>
  <verify>dotnet build Threa/Threa.Client/Threa.Client.csproj</verify>
  <done>ProcessConcentrationResult handles MagazineReload by updating weapon.CurrentRounds</done>
</task>

<task type="auto">
  <name>Task 7: Implement ProcessSustainedBreak for linked effect removal</name>
  <files>Threa/Threa.Client/Components/Pages/GamePlay/Play.razor.cs</files>
  <action>
Add a method to process sustained concentration break by removing linked effects from all table characters.

```csharp
/// <summary>
/// Processes sustained concentration break by removing all linked effects from table characters.
/// </summary>
private async Task ProcessSustainedBreak(string? payloadJson)
{
    if (string.IsNullOrEmpty(payloadJson)) return;

    // Parse the payload to get LinkedEffectIds
    try
    {
        var payload = System.Text.Json.JsonSerializer.Deserialize<SustainedBreakPayload>(payloadJson);
        if (payload?.LinkedEffectIds == null || payload.LinkedEffectIds.Count == 0) return;

        var linkedIds = new HashSet<Guid>(payload.LinkedEffectIds);

        // Iterate through all table characters and remove matching effects
        foreach (var character in TableCharacters)
        {
            var effectsToRemove = character.Effects
                .Where(e => e.Id.HasValue && linkedIds.Contains(e.Id.Value))
                .ToList();

            foreach (var effect in effectsToRemove)
            {
                character.Effects.RemoveEffect(effect);
            }

            // Also remove effects that have matching SourceEffectId
            var linkedBySource = character.Effects
                .Where(e => e.SourceEffectId.HasValue && linkedIds.Contains(e.SourceEffectId.Value))
                .ToList();

            foreach (var effect in linkedBySource)
            {
                character.Effects.RemoveEffect(effect);
            }

            // Save if any effects were removed
            if (effectsToRemove.Count > 0 || linkedBySource.Count > 0)
            {
                await SaveCharacterAsync(character);
            }
        }
    }
    catch (Exception ex)
    {
        Logger?.LogError(ex, "Error processing sustained break payload");
    }
}

/// <summary>
/// Payload structure for sustained break result.
/// </summary>
private class SustainedBreakPayload
{
    public List<Guid>? LinkedEffectIds { get; set; }
    public string? SpellName { get; set; }
}
```

The key points:
1. Parse LinkedEffectIds from the payload
2. Iterate through all TableCharacters (all characters at the current table)
3. Find effects with matching Id OR matching SourceEffectId
4. Remove all matching effects
5. Save characters that had effects removed
  </action>
  <verify>dotnet build Threa/Threa.Client/Threa.Client.csproj</verify>
  <done>ProcessSustainedBreak removes linked effects from all table characters using LinkedEffectIds</done>
</task>

<task type="auto">
  <name>Task 8: Wire up result processing to time advancement</name>
  <files>Threa/Threa.Client/Components/Pages/GamePlay/Play.razor.cs</files>
  <action>
Find the method that advances time/rounds and add a call to process concentration results for all characters.

1. Look for methods like AdvanceRound(), ProcessEndOfRound(), or OnTimeAdvanced().

2. After effects are processed (OnTick, OnExpire), add:

```csharp
// After effects processing for all characters
foreach (var character in TableCharacters)
{
    await ProcessConcentrationResult(character);
}
```

3. Also call ProcessConcentrationResult after voluntary concentration drop (when BreakConcentration is called):
   - Find where the ConcentrationIndicator's OnConcentrationDropped callback is handled
   - Add ProcessConcentrationResult call there

The flow should be:
1. Time advances -> Effects tick/expire/remove
2. ConcentrationBehavior.OnExpire/OnRemove sets LastConcentrationResult
3. ProcessConcentrationResult reads and handles the result
4. Character is saved
5. LastConcentrationResult is cleared
  </action>
  <verify>dotnet build Threa/Threa.Client/Threa.Client.csproj</verify>
  <done>ProcessConcentrationResult called after time advancement for all table characters</done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build Threa/Threa.sln`
2. Code review:
   - ConcentrationIndicator displays badge with "Concentrating" label
   - Casting-time shows progress bar and X/Y rounds text
   - Sustained shows linked effect count and drain rate
   - Compact mode shows only badge and name
   - Drop button calls BreakConcentration and invokes callback
   - ProcessConcentrationResult handles MagazineReload, SustainedBreak, SpellCast
   - ExecuteMagazineReload updates weapon.CurrentRounds
   - ProcessSustainedBreak iterates table characters and removes linked effects
3. Manual testing:
   - TabStatus shows full concentration indicator when character is concentrating
   - CharacterStatusCard shows compact badge when character is concentrating
   - Drop Concentration button works and refreshes display
   - Magazine reload completion updates weapon ammo count
   - Sustained concentration break removes effects from target characters
</verification>

<success_criteria>
- ConcentrationIndicator component displays concentration type, name, and appropriate details
- Casting-time concentration shows progress bar with X/Y rounds
- Sustained concentration shows linked effect count and drain rate per round
- TabStatus renders ConcentrationIndicator for player view with drop button
- CharacterStatusCard renders compact ConcentrationIndicator for GM dashboard
- Drop Concentration button calls BreakConcentration and refreshes UI
- ProcessConcentrationResult handles MagazineReload and updates weapon.CurrentRounds (CONC-03)
- ProcessSustainedBreak removes linked effects from all table characters
- Component builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/22-concentration-system/22-07-SUMMARY.md`
</output>

---

## Notes

**Component Modes**:
- **Full Mode** (TabStatus): Shows all details - badge, name, progress/drain info, drop button
- **Compact Mode** (CharacterStatusCard): Shows only badge and name for space efficiency

**Drop Button Behavior**:
- Player can voluntarily drop concentration at any time
- Uses BreakConcentration which triggers OnRemove (handles cleanup)
- Invokes callback so parent can refresh character state

**Integration Points**:
- TabStatus: Player's view of their own character
- CharacterStatusCard: GM's dashboard showing all characters
- Play.razor: Main gameplay page that processes concentration results

**LastConcentrationResult Processing Flow**:
1. Effect expires or is removed (OnExpire/OnRemove in ConcentrationBehavior)
2. LastConcentrationResult is set with ActionType, Payload, Message, Success
3. After effects processing, ProcessConcentrationResult is called for each character
4. Based on ActionType:
   - "MagazineReload" + Success=true: Update weapon.CurrentRounds from payload
   - "SustainedBreak": Iterate table characters, remove effects matching LinkedEffectIds
   - "SpellCast": TODO when spell system is ready
5. ClearConcentrationResult() is called to prevent re-processing

**CONC-03 Completion**: The magazine reload requirement is now fully covered - OnExpire stores the result, and this plan's Task 6 processes it to update the weapon.

**Sustained Break Completion**: Plan 22-03's PrepareLinkedEffectRemoval stores the LinkedEffectIds, and this plan's Task 7 processes them to remove effects from all target characters.

---

*Plan created: 2026-01-29*
*Gap closure for: UI displays concentration type, progress, linked effects, and drain cost + LastConcentrationResult processing*
