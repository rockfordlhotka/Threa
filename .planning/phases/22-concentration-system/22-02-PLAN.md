# Phase 22-02: ConcentrationBehavior Casting Time Implementation

---
phase: 22-concentration-system
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs
  - GameMechanics/CharacterEdit.cs
  - GameMechanics.Test/ConcentrationBehaviorCastingTimeTests.cs
autonomous: true
estimated_minutes: 25

must_haves:
  truths:
    - "OnTick increments CurrentProgress by RoundsPerTick for casting-time concentration types"
    - "OnTick expires early with CompletionMessage when CurrentProgress reaches TotalRequired"
    - "OnTick updates effect Description with progress string for user display"
    - "OnExpire executes deferred action and stores result with Success=true"
    - "OnRemove does NOT execute deferred action and stores result with Success=false"
    - "CharacterEdit.LastConcentrationResult stores completion/interruption result from concentration effects"
    - "CONC-03 partial: Magazine reload completion stores result in LastConcentrationResult (weapon update handled by UI in 22-07)"
  artifacts:
    - path: "GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs"
      provides: "OnTick, OnExpire, OnRemove, ConcentrationCompletionResult, helper methods"
      contains: "ConcentrationCompletionResult|IsCastingTimeConcentration|TickCastingTime|ExecuteDeferredAction|HandleCastingTimeInterruption|CreateMagazineReloadState|CreateSpellCastingState"
    - path: "GameMechanics/CharacterEdit.cs"
      provides: "LastConcentrationResult property for behavior-to-UI communication"
      contains: "LastConcentrationResult|ClearConcentrationResult"
    - path: "GameMechanics.Test/ConcentrationBehaviorCastingTimeTests.cs"
      provides: "Comprehensive tests for casting-time concentration lifecycle"
      min_lines: 100
  key_links:
    - from: "ConcentrationBehavior.OnExpire"
      to: "CharacterEdit.LastConcentrationResult"
      via: "stores ConcentrationCompletionResult for UI processing"
      pattern: "LastConcentrationResult.*=.*ConcentrationCompletionResult"
    - from: "ConcentrationBehavior.OnTick"
      to: "EffectTickResult.ExpireEarly"
      via: "returns ExpireEarly when progress complete"
      pattern: "ExpireEarly.*CompletionMessage"
---

<objective>
Implement casting-time concentration with OnTick progress tracking, OnExpire deferred action execution, and OnRemove cleanup without execution.

Purpose: Enable casting-time concentration (magazine reload, spell casting) to track progress over multiple rounds and execute or cancel deferred actions appropriately.

Output: ConcentrationBehavior with working lifecycle methods, CharacterEdit integration, helper methods, and passing tests.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-concentration-system/22-CONTEXT.md

Key context from 22-01:
- ConcentrationState has DeferredActionType, DeferredActionPayload, CompletionMessage, InterruptionMessage
- MagazineReloadPayload and SpellCastPayload classes exist for serializing deferred action parameters
- EffectRecord has SourceEffectId and SourceCasterId for effect linking
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ConcentrationCompletionResult class</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Add a new public class at the end of the ConcentrationBehavior.cs file (before the final closing brace of the namespace):

```csharp
/// <summary>
/// Result of a concentration effect completing or being interrupted.
/// Used to communicate the outcome to the UI/controller layer.
/// </summary>
public class ConcentrationCompletionResult
{
    /// <summary>
    /// The type of action that was being concentrated on (e.g., "MagazineReload", "SpellCast").
    /// </summary>
    public string ActionType { get; set; } = "";

    /// <summary>
    /// The serialized payload for the action (for further processing by UI/controller).
    /// </summary>
    public string? Payload { get; set; }

    /// <summary>
    /// Message to display to the user.
    /// </summary>
    public string Message { get; set; } = "";

    /// <summary>
    /// True if concentration completed successfully, false if interrupted.
    /// </summary>
    public bool Success { get; set; }
}
```

This class is used by OnExpire and OnRemove to communicate results to the UI layer.
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>ConcentrationCompletionResult class exists with ActionType, Payload, Message, Success properties</done>
</task>

<task type="auto">
  <name>Task 2: Add LastConcentrationResult to CharacterEdit</name>
  <files>GameMechanics/CharacterEdit.cs</files>
  <action>
1. Add using statement at the top of CharacterEdit.cs:
   ```csharp
   using GameMechanics.Effects.Behaviors;
   ```

2. Find the fields section of CharacterEdit (look for private fields near the top). Add:
   ```csharp
   /// <summary>
   /// Result from the last concentration effect that completed or was interrupted.
   /// Used by UI/controller to handle deferred actions like magazine reload.
   /// Cleared after processing.
   /// </summary>
   [NonSerialized]
   private ConcentrationCompletionResult? _lastConcentrationResult;
   ```

3. Add property and helper method in the public properties section:
   ```csharp
   /// <summary>
   /// Result from the last concentration effect that completed or was interrupted.
   /// The UI/controller layer should read this after processing effect expiration/removal.
   /// </summary>
   public ConcentrationCompletionResult? LastConcentrationResult
   {
       get => _lastConcentrationResult;
       set => _lastConcentrationResult = value;
   }

   /// <summary>
   /// Clears the last concentration result after processing.
   /// Call this after the UI/controller has handled the result.
   /// </summary>
   public void ClearConcentrationResult()
   {
       _lastConcentrationResult = null;
   }
   ```

Note: This property is NOT a CSLA managed property - it's transient state for behavior-to-UI communication that doesn't persist to database.
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>CharacterEdit has LastConcentrationResult property with getter/setter and ClearConcentrationResult() method</done>
</task>

<task type="auto">
  <name>Task 3: Refactor OnTick for generic casting-time progress</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Find the existing OnTick method in ConcentrationBehavior.cs. The current implementation has a switch statement that calls TickMagazineReload for magazine reload type.

Replace the entire OnTick method with a generic implementation:
1. Deserialize ConcentrationState from effect.BehaviorState
2. Check if IsCastingTimeConcentration(state.ConcentrationType) returns true
3. If yes, call TickCastingTime helper; otherwise return EffectTickResult.Continue()

Add these new private methods after OnTick:
- IsCastingTimeConcentration(string? type): returns true for "MagazineReload", "SpellCasting", "RitualPreparation"
- TickCastingTime(EffectRecord effect, CharacterEdit character, ConcentrationState state): increments CurrentProgress, updates Description via GetProgressDescription, checks if complete and returns ExpireEarly if so
- GetProgressDescription(ConcentrationState state): returns progress string based on ConcentrationType

Remove the old TickMagazineReload method entirely.

The TickCastingTime method should:
- Increment state.CurrentProgress by Math.Max(1, state.RoundsPerTick)
- Set effect.Description = GetProgressDescription(state)
- If state.TotalRequired > 0 and state.CurrentProgress >= state.TotalRequired, serialize state and return ExpireEarly with CompletionMessage
- Otherwise serialize state and return Continue()
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>OnTick method handles all casting-time types via IsCastingTimeConcentration check and TickCastingTime helper; old TickMagazineReload method removed</done>
</task>

<task type="auto">
  <name>Task 4: Implement OnExpire with deferred action execution</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Find the existing OnExpire method stub in ConcentrationBehavior.cs (contains comment about TODO or stub).

Replace the OnExpire method body with:
1. Deserialize ConcentrationState from effect.BehaviorState, return early if null
2. If IsCastingTimeConcentration(state.ConcentrationType) and state.DeferredActionType is not null, call ExecuteDeferredAction

Add ExecuteDeferredAction(CharacterEdit character, ConcentrationState state) private method:
- Switch on state.DeferredActionType
- Case "MagazineReload": call ExecuteMagazineReload
- Case "SpellCast": call ExecuteSpellCast
- Default: do nothing (future action types)

Add ExecuteMagazineReload(CharacterEdit character, ConcentrationState state) private method:
- Deserialize MagazineReloadPayload from state.DeferredActionPayload, return early if null
- Set character.LastConcentrationResult to new ConcentrationCompletionResult with ActionType="MagazineReload", Payload=state.DeferredActionPayload, Message=state.CompletionMessage or default, Success=true

Add ExecuteSpellCast(CharacterEdit character, ConcentrationState state) private method:
- Deserialize SpellCastPayload from state.DeferredActionPayload, return early if null
- Set character.LastConcentrationResult to new ConcentrationCompletionResult with ActionType="SpellCast", Payload=state.DeferredActionPayload, Message=state.CompletionMessage or default, Success=true
- Include TODO comment: spell effects creation pending spell system implementation
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>OnExpire dispatches to ExecuteMagazineReload or ExecuteSpellCast based on DeferredActionType; results stored in character.LastConcentrationResult with Success=true</done>
</task>

<task type="auto">
  <name>Task 5: Implement OnRemove for interruption cleanup</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Find the existing OnRemove method stub in ConcentrationBehavior.cs.

Replace the OnRemove method body with:
1. Deserialize ConcentrationState from effect.BehaviorState, return early if null
2. If IsCastingTimeConcentration(state.ConcentrationType), call HandleCastingTimeInterruption
3. Add comment: sustained concentration cleanup handled in 22-03

Add HandleCastingTimeInterruption(CharacterEdit character, ConcentrationState state) private method:
- Build message from state.InterruptionMessage or default to "{ConcentrationType} interrupted!"
- Set character.LastConcentrationResult to new ConcentrationCompletionResult with:
  - ActionType = state.DeferredActionType ?? state.ConcentrationType ?? "Unknown"
  - Payload = state.DeferredActionPayload
  - Message = the interruption message
  - Success = false (indicates interruption, not completion)

Key distinction: OnRemove must NOT call ExecuteDeferredAction - the deferred action is lost when concentration is interrupted.
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>OnRemove handles casting-time interruption by storing result with Success=false; deferred action NOT executed</done>
</task>

<task type="auto">
  <name>Task 6: Add CreateMagazineReloadState helper</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Find any existing CreateMagazineReloadState method in ConcentrationBehavior. If it exists, replace it with this updated version. If not, add it as a public static method:

```csharp
/// <summary>
/// Creates state for magazine reload concentration.
/// </summary>
/// <param name="weaponItemId">The weapon CharacterItem ID being reloaded</param>
/// <param name="magazineItemId">The magazine/ammo source CharacterItem ID</param>
/// <param name="roundsToLoad">Number of rounds to load when complete</param>
/// <param name="totalRounds">Number of concentration rounds required (default 3)</param>
/// <returns>Serialized ConcentrationState JSON</returns>
public static string CreateMagazineReloadState(
    Guid weaponItemId,
    Guid magazineItemId,
    int roundsToLoad,
    int totalRounds = 3)
{
    var payload = new MagazineReloadPayload
    {
        WeaponItemId = weaponItemId,
        MagazineItemId = magazineItemId,
        RoundsToLoad = roundsToLoad
    };

    return new ConcentrationState
    {
        ConcentrationType = "MagazineReload",
        TotalRequired = totalRounds,
        CurrentProgress = 0,
        RoundsPerTick = 1,
        TargetItemId = magazineItemId,
        SourceItemId = weaponItemId,
        DeferredActionType = "MagazineReload",
        DeferredActionPayload = payload.Serialize(),
        CompletionMessage = $"Magazine loaded with {roundsToLoad} rounds!",
        InterruptionMessage = "Reload interrupted!"
    }.Serialize();
}
```
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>CreateMagazineReloadState creates ConcentrationState with MagazineReloadPayload in DeferredActionPayload</done>
</task>

<task type="auto">
  <name>Task 7: Add CreateSpellCastingState helper (stub)</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Add a public static method for creating spell casting concentration state:

```csharp
/// <summary>
/// Creates state for spell casting concentration.
/// STUB: Full implementation pending spell system in future milestone.
/// </summary>
/// <param name="spellId">The spell ID to cast</param>
/// <param name="targetId">Target character ID (if single-target spell)</param>
/// <param name="castingRounds">Number of rounds required to cast</param>
/// <param name="spellName">Display name of the spell</param>
/// <returns>Serialized ConcentrationState JSON</returns>
public static string CreateSpellCastingState(
    int spellId,
    Guid? targetId,
    int castingRounds,
    string spellName)
{
    var payload = new SpellCastPayload
    {
        SpellId = spellId,
        TargetId = targetId
    };

    return new ConcentrationState
    {
        ConcentrationType = "SpellCasting",
        TotalRequired = castingRounds,
        CurrentProgress = 0,
        RoundsPerTick = 1,
        DeferredActionType = "SpellCast",
        DeferredActionPayload = payload.Serialize(),
        CompletionMessage = $"{spellName} cast successfully!",
        InterruptionMessage = $"{spellName} interrupted!"
    }.Serialize();
}
```
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>CreateSpellCastingState creates ConcentrationState with SpellCastPayload (stub for future spell system)</done>
</task>

<task type="auto">
  <name>Task 8: Create concentration behavior casting time tests</name>
  <files>GameMechanics.Test/ConcentrationBehaviorCastingTimeTests.cs</files>
  <action>
Create a new test file. Check existing test patterns in GameMechanics.Test/ first - look at how other tests create CharacterEdit and EffectRecord instances (likely using CSLA DataPortal or test helpers).

The tests should cover:
1. OnTick_CastingTime_IncrementsProgress - verify CurrentProgress increases by RoundsPerTick
2. OnTick_CastingTime_ExpiresEarlyWhenComplete - verify ExpireEarly returned when progress reaches TotalRequired
3. OnTick_CastingTime_UpdatesDescription - verify effect.Description updated with progress
4. OnExpire_MagazineReload_SetsCompletionResult - verify LastConcentrationResult set with Success=true
5. OnExpire_SpellCast_SetsCompletionResult - verify stub works
6. OnRemove_CastingTime_SetsInterruptionResult - verify LastConcentrationResult.Success=false
7. OnRemove_CastingTime_DoesNotExecuteDeferredAction - verify no Success=true result
8. CreateMagazineReloadState_CreatesValidState - verify serialization roundtrip
9. CreateSpellCastingState_CreatesValidState - verify serialization roundtrip

Use the test infrastructure already established in the project. If CSLA business objects require special test setup, follow the existing patterns from other test classes.

Note: If the project uses mock/test doubles for EffectRecord and CharacterEdit, create minimal implementations. Otherwise use DataPortal.Create or similar.
  </action>
  <verify>dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "FullyQualifiedName~ConcentrationBehaviorCastingTimeTests"</verify>
  <done>All 9 tests pass covering OnTick progress, OnExpire execution, OnRemove interruption, and helper methods</done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build Threa.sln`
2. Tests pass: `dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "FullyQualifiedName~ConcentrationBehavior"`
3. Code review:
   - ConcentrationCompletionResult has all 4 properties
   - CharacterEdit.LastConcentrationResult is non-CSLA transient property
   - OnTick increments progress and updates description
   - OnTick returns ExpireEarly when TotalRequired reached
   - OnExpire calls ExecuteMagazineReload or ExecuteSpellCast
   - OnRemove calls HandleCastingTimeInterruption (no execution)
   - IsCastingTimeConcentration covers MagazineReload, SpellCasting, RitualPreparation
   - CreateMagazineReloadState produces valid JSON with payload
   - CreateSpellCastingState produces valid JSON with payload
</verification>

<success_criteria>
- ConcentrationCompletionResult class exists with ActionType, Payload, Message, Success
- CharacterEdit.LastConcentrationResult property stores/clears results
- OnTick increments CurrentProgress and updates Description for all casting-time types
- OnExpire executes deferred action and sets LastConcentrationResult.Success = true
- OnRemove does NOT execute deferred action and sets LastConcentrationResult.Success = false
- CreateMagazineReloadState creates complete state with deferred action payload
- CreateSpellCastingState creates complete state for future use
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-concentration-system/22-02-SUMMARY.md`
</output>

---

## Notes

**Task Ordering Rationale**: Tasks are ordered so dependencies are satisfied:
1. ConcentrationCompletionResult class (used by Tasks 4, 5)
2. CharacterEdit.LastConcentrationResult property (used by Tasks 4, 5)
3-5. OnTick/OnExpire/OnRemove (use the above)
6-7. Helper methods (independent utilities)
8. Tests (require all above)

**Architecture Decision**: The deferred action execution stores results in `CharacterEdit.LastConcentrationResult` rather than directly modifying items. This is because:
1. CharacterEdit doesn't have direct access to CharacterItems (they're in a separate DAL call)
2. The UI/controller layer that handles effect expiration has access to both the character and inventory
3. This maintains separation of concerns - behaviors communicate intent, callers execute

**CONC-03 Coverage**: The actual weapon magazine update is handled by the UI/controller layer that processes LastConcentrationResult after effect expiration. Plan 22-07 (UI components) will implement the processing of LastConcentrationResult for magazine reload completion.

**Future Work (22-03)**: Sustained concentration will add:
- FAT/VIT drain in OnTick
- LinkedEffectIds tracking
- OnRemove removes linked effects from targets

---

*Plan created: 2026-01-29*
*Focus: Casting-time concentration mechanics for magazine reload and spell casting stub*
