---
phase: 22-concentration-system
plan: 03
type: execute
wave: 3
depends_on: ["22-02"]
files_modified:
  - GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs
  - GameMechanics/EffectList.cs
  - GameMechanics/CharacterEdit.cs
  - GameMechanics.Test/ConcentrationBehaviorSustainedTests.cs
autonomous: true
estimated_minutes: 30
gap_closure: true

must_haves:
  truths:
    - "OnTick applies FatDrainPerRound and VitDrainPerRound to character for SustainedSpell type"
    - "OnTick expires early when character FAT or VIT reaches 0 or below"
    - "OnRemove removes all effects from all characters that have matching SourceEffectId"
    - "CreateSustainedConcentrationState helper creates valid state with drain and linked effect fields"
  artifacts:
    - path: "GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs"
      provides: "IsSustainedConcentration, TickSustainedConcentration, ApplyDrain, RemoveLinkedEffects"
      contains: "IsSustainedConcentration|TickSustainedConcentration|ApplyDrain|RemoveLinkedEffects|CreateSustainedConcentrationState"
    - path: "GameMechanics.Test/ConcentrationBehaviorSustainedTests.cs"
      provides: "Tests for sustained concentration drain and linked effect removal"
      min_lines: 80
  key_links:
    - from: "ConcentrationBehavior.OnTick"
      to: "CharacterEdit.FatigueDamage"
      via: "ApplyDrain increments pending damage"
      pattern: "FatigueDamage.*\\+="
    - from: "ConcentrationBehavior.OnRemove"
      to: "EffectList.RemoveEffect"
      via: "RemoveLinkedEffects calls RemoveEffect for each LinkedEffectId"
      pattern: "RemoveEffect.*LinkedEffectId"
---

<objective>
Implement sustained concentration mechanics: FAT/VIT drain per round and linked effect removal on concentration break.

Purpose: Enable sustained spells (like Invisibility, Telekinetic Hold) that drain caster resources per round and immediately end on all targets when concentration breaks.

Output: ConcentrationBehavior with sustained concentration logic in OnTick and OnRemove, plus helper method and tests.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/22-concentration-system/22-CONTEXT.md
@.planning/phases/22-concentration-system/22-02-SUMMARY.md

Key context from 22-02:
- ConcentrationBehavior has IsCastingTimeConcentration and TickCastingTime
- OnTick returns Continue() for non-casting-time types (placeholder for sustained)
- OnRemove handles casting-time interruption, has comment "Sustained concentration cleanup handled in 22-03"
- ConcentrationState has FatDrainPerRound, VitDrainPerRound, LinkedEffectIds, SpellName fields (from 22-01)

Sustained concentration design:
- ConcentrationType = "SustainedSpell"
- FatDrainPerRound/VitDrainPerRound applied each round in OnTick
- LinkedEffectIds stores effect GUIDs on target characters
- When concentration breaks (OnRemove), all effects with matching SourceEffectId are removed from all characters
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IsSustainedConcentration helper</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Add a private static method after IsCastingTimeConcentration:

```csharp
/// <summary>
/// Checks if the concentration type is a sustained type (maintains active effect indefinitely).
/// </summary>
private static bool IsSustainedConcentration(string? concentrationType)
{
    return concentrationType == "SustainedSpell"
        || concentrationType == "SustainedAbility"
        || concentrationType == "MentalControl";
}
```
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>IsSustainedConcentration method exists and returns true for SustainedSpell, SustainedAbility, MentalControl</done>
</task>

<task type="auto">
  <name>Task 2: Implement ApplyDrain helper</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Add a private method to apply FAT/VIT drain:

```csharp
/// <summary>
/// Applies FAT/VIT drain to the character for sustained concentration.
/// </summary>
/// <param name="character">The character concentrating</param>
/// <param name="state">The concentration state with drain values</param>
/// <returns>True if character can continue, false if exhausted</returns>
private static bool ApplyDrain(CharacterEdit character, ConcentrationState state)
{
    // Apply FAT drain
    if (state.FatDrainPerRound > 0)
    {
        character.FatigueDamage += state.FatDrainPerRound;
    }

    // Apply VIT drain
    if (state.VitDrainPerRound > 0)
    {
        character.VitalityDamage += state.VitDrainPerRound;
    }

    // Check if character is exhausted
    // CurrentFatigue = MaxFatigue - FatigueDamage, so exhausted when FatigueDamage >= MaxFatigue
    bool fatigueExhausted = character.FatigueDamage >= character.MaxFatigue;
    bool vitalityExhausted = character.VitalityDamage >= character.MaxVitality;

    return !(fatigueExhausted || vitalityExhausted);
}
```

Note: Check how CharacterEdit tracks health pools - it may use FatigueDamage/VitalityDamage or CurrentFatigue/CurrentVitality. Adjust the property names based on actual CharacterEdit implementation.
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>ApplyDrain method increments FatigueDamage/VitalityDamage and returns false when character is exhausted</done>
</task>

<task type="auto">
  <name>Task 3: Implement TickSustainedConcentration</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Add a private method to handle sustained concentration OnTick:

```csharp
/// <summary>
/// Handles OnTick for sustained concentration types.
/// Applies FAT/VIT drain and expires early if character is exhausted.
/// </summary>
private EffectTickResult TickSustainedConcentration(EffectRecord effect, CharacterEdit character, ConcentrationState state)
{
    // Apply drain
    bool canContinue = ApplyDrain(character, state);

    if (!canContinue)
    {
        // Character is exhausted, concentration breaks
        string message = $"Too exhausted to maintain {state.SpellName ?? "concentration"}";
        return EffectTickResult.ExpireEarly(message);
    }

    // Update description with drain info
    var drainParts = new List<string>();
    if (state.FatDrainPerRound > 0)
        drainParts.Add($"{state.FatDrainPerRound} FAT");
    if (state.VitDrainPerRound > 0)
        drainParts.Add($"{state.VitDrainPerRound} VIT");

    string drainDesc = drainParts.Count > 0 ? $" ({string.Join(" + ", drainParts)}/round)" : "";
    effect.Description = $"Sustaining {state.SpellName ?? "effect"}{drainDesc}";

    return EffectTickResult.Continue();
}
```
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>TickSustainedConcentration applies drain, updates description, and returns ExpireEarly when exhausted</done>
</task>

<task type="auto">
  <name>Task 4: Update OnTick to handle sustained concentration</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Find the OnTick method and update it to handle sustained concentration. The current implementation returns Continue() for non-casting types.

Replace the "Sustained concentration handled in 22-03" comment and the return statement with:

```csharp
// Handle sustained concentration types (SustainedSpell, SustainedAbility, MentalControl)
if (IsSustainedConcentration(state.ConcentrationType))
{
    return TickSustainedConcentration(effect, character, state);
}

// Unknown concentration type, just continue
return EffectTickResult.Continue();
```
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>OnTick calls TickSustainedConcentration for sustained types and applies drain per round</done>
</task>

<task type="auto">
  <name>Task 5: Implement RemoveLinkedEffects helper</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Add a private method to remove linked effects when concentration breaks.

IMPORTANT: The ConcentrationBehavior.OnRemove only has access to the caster's CharacterEdit. To remove effects from target characters, we need a way to find those characters. Since we don't have direct access to other characters in this context, we'll store the result in a way that the UI/controller layer can process.

Add this method:

```csharp
/// <summary>
/// Stores linked effect removal info in LastConcentrationResult for UI processing.
/// The actual removal must be done by the UI/controller layer which has access to all characters.
/// </summary>
private void PrepareLinkedEffectRemoval(CharacterEdit character, ConcentrationState state)
{
    if (state.LinkedEffectIds == null || state.LinkedEffectIds.Count == 0)
        return;

    // Store result for UI/controller to process
    // The UI layer will iterate through table characters and remove effects with matching IDs
    character.LastConcentrationResult = new ConcentrationCompletionResult
    {
        ActionType = "SustainedBreak",
        Payload = System.Text.Json.JsonSerializer.Serialize(new
        {
            LinkedEffectIds = state.LinkedEffectIds,
            SpellName = state.SpellName
        }),
        Message = $"{state.SpellName ?? "Sustained effect"} ended",
        Success = false  // Indicates concentration was broken, not completed
    };
}
```

Note: The actual effect removal from target characters happens in the UI/controller layer (plan 22-07) because ConcentrationBehavior doesn't have access to other characters. This is the same pattern used for casting-time concentration where the result is stored for later processing.
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>PrepareLinkedEffectRemoval stores linked effect IDs in LastConcentrationResult for UI processing</done>
</task>

<task type="auto">
  <name>Task 6: Update OnRemove to handle sustained concentration</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Find the OnRemove method and update it to handle sustained concentration. The current implementation has a comment "Sustained concentration cleanup handled in 22-03".

After the casting-time interruption handling, add:

```csharp
// Handle sustained concentration cleanup
if (IsSustainedConcentration(state.ConcentrationType))
{
    PrepareLinkedEffectRemoval(character, state);
}
```

The complete OnRemove method should now handle both casting-time (sets interruption result) and sustained (prepares linked effect removal).
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>OnRemove calls PrepareLinkedEffectRemoval for sustained concentration types</done>
</task>

<task type="auto">
  <name>Task 7: Add CreateSustainedConcentrationState helper</name>
  <files>GameMechanics/Effects/Behaviors/ConcentrationBehavior.cs</files>
  <action>
Add a public static helper method for creating sustained concentration state:

```csharp
/// <summary>
/// Creates state for sustained spell concentration.
/// </summary>
/// <param name="spellName">Display name of the sustained spell</param>
/// <param name="linkedEffectIds">Effect IDs on target characters (can be empty, added later)</param>
/// <param name="fatDrainPerRound">FAT cost per round (default 1)</param>
/// <param name="vitDrainPerRound">VIT cost per round (default 0)</param>
/// <param name="casterId">The character ID of the caster</param>
/// <returns>Serialized ConcentrationState JSON</returns>
public static string CreateSustainedConcentrationState(
    string spellName,
    List<Guid>? linkedEffectIds = null,
    int fatDrainPerRound = 1,
    int vitDrainPerRound = 0,
    Guid? casterId = null)
{
    return new ConcentrationState
    {
        ConcentrationType = "SustainedSpell",
        SpellName = spellName,
        LinkedEffectIds = linkedEffectIds ?? new List<Guid>(),
        FatDrainPerRound = fatDrainPerRound,
        VitDrainPerRound = vitDrainPerRound,
        SourceCasterId = casterId,
        // No fixed duration - sustained until dropped or broken
        TotalRequired = 0,
        CurrentProgress = 0
    }.Serialize();
}
```
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj</verify>
  <done>CreateSustainedConcentrationState helper creates valid sustained concentration state with all fields</done>
</task>

<task type="auto">
  <name>Task 8: Create sustained concentration tests</name>
  <files>GameMechanics.Test/ConcentrationBehaviorSustainedTests.cs</files>
  <action>
Create a new test file for sustained concentration. Follow the patterns established in ConcentrationBehaviorCastingTimeTests.cs.

Tests to include:
1. OnTick_SustainedSpell_AppliesFatDrain - verify FatigueDamage increases by FatDrainPerRound
2. OnTick_SustainedSpell_AppliesVitDrain - verify VitalityDamage increases by VitDrainPerRound
3. OnTick_SustainedSpell_ExpiresWhenFatigueExhausted - verify ExpireEarly when FAT reaches 0
4. OnTick_SustainedSpell_ExpiresWhenVitalityExhausted - verify ExpireEarly when VIT reaches 0
5. OnTick_SustainedSpell_UpdatesDescription - verify description shows spell name and drain
6. OnRemove_SustainedSpell_PreparesLinkedEffectRemoval - verify LastConcentrationResult has LinkedEffectIds
7. CreateSustainedConcentrationState_CreatesValidState - verify serialization roundtrip
8. IsSustainedConcentration_ReturnsTrueForSustainedTypes - verify helper method

Use the test infrastructure already established in the project. The tests should verify the behavior without needing actual UI integration.
  </action>
  <verify>dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "FullyQualifiedName~ConcentrationBehaviorSustainedTests"</verify>
  <done>All 8 tests pass covering sustained concentration drain, exhaustion, and linked effect preparation</done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build Threa.sln`
2. Tests pass: `dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "FullyQualifiedName~ConcentrationBehavior"`
3. Code review:
   - IsSustainedConcentration covers SustainedSpell, SustainedAbility, MentalControl
   - ApplyDrain increments FatigueDamage and VitalityDamage
   - TickSustainedConcentration applies drain and returns ExpireEarly when exhausted
   - OnTick dispatches to TickSustainedConcentration for sustained types
   - PrepareLinkedEffectRemoval stores linked effect IDs in LastConcentrationResult
   - OnRemove calls PrepareLinkedEffectRemoval for sustained types
   - CreateSustainedConcentrationState creates valid state with all fields
</verification>

<success_criteria>
- OnTick applies FatDrainPerRound to character.FatigueDamage for SustainedSpell type
- OnTick applies VitDrainPerRound to character.VitalityDamage for SustainedSpell type
- OnTick returns ExpireEarly when character FAT or VIT is exhausted
- OnRemove stores LinkedEffectIds in LastConcentrationResult for UI processing
- CreateSustainedConcentrationState creates state with SpellName, drain values, and LinkedEffectIds
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-concentration-system/22-03-SUMMARY.md`
</output>

---

## Notes

**Architecture Decision**: Like casting-time concentration, sustained concentration stores results in `LastConcentrationResult` rather than directly removing effects from target characters. This is because:
1. ConcentrationBehavior only has access to the caster's CharacterEdit
2. Target characters are separate CSLA objects that must be fetched separately
3. The UI/controller layer (plan 22-07) will process the result and remove linked effects from all table characters

**Linked Effect Removal Flow**:
1. Concentration breaks (OnRemove called)
2. PrepareLinkedEffectRemoval stores LinkedEffectIds in LastConcentrationResult
3. UI/controller reads LastConcentrationResult after effect processing
4. UI queries all table characters for effects with matching IDs
5. UI removes matching effects from each target character
6. UI clears LastConcentrationResult

**FAT/VIT Drain Notes**:
- Drain is applied to pending damage (FatigueDamage/VitalityDamage), not directly to current pools
- This matches the existing health management pattern where damage is pending until applied
- Time advancement will process pending damage normally

---

*Plan created: 2026-01-29*
*Gap closure for: Sustained concentration drains FAT/VIT + Breaking removes linked effects*
