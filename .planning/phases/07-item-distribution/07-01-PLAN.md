---
phase: 07-item-distribution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - GameMechanics/Messaging/TimeMessages.cs
  - Threa/Threa.Client/Components/Pages/GamePlay/GmTable.razor
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GM can see list of players at current game table"
    - "GM can select an item template to grant"
    - "GM can select a quantity for stackable items"
    - "GM can grant item to a specific player character"
    - "Granted items appear immediately in player inventory"
  artifacts:
    - path: "GameMechanics/Messaging/TimeMessages.cs"
      provides: "InventoryChanged enum value for CharacterUpdateType"
      contains: "InventoryChanged"
    - path: "Threa/Threa.Client/Components/Pages/GamePlay/GmTable.razor"
      provides: "Item Distribution panel UI"
      contains: "Item Distribution"
  key_links:
    - from: "GmTable.razor"
      to: "ItemManagementService.AddItemToInventoryAsync"
      via: "grant item workflow"
      pattern: "itemManagementService\\.AddItemToInventoryAsync"
    - from: "GmTable.razor"
      to: "TimeEventPublisher.PublishCharacterUpdateAsync"
      via: "player notification"
      pattern: "CharacterUpdateType\\.InventoryChanged"
    - from: "Play.razor"
      to: "LoadEquippedItemsAsync"
      via: "OnCharacterUpdateReceived"
      pattern: "LoadEquippedItemsAsync"
---

<objective>
GM Item Distribution: Add an "Item Distribution" panel to the GM Table page that allows Game Masters to grant items to player characters during gameplay sessions.

Purpose: Completes the inventory system by enabling GMs to give items (loot, rewards, quest items) to players in real-time. This is the final phase of the inventory milestone.

Output: GM can select an item template, set quantity, select a character at the table, and grant the item. The player sees the item appear in their inventory immediately without refreshing.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-item-distribution/07-RESEARCH.md

# Existing files to modify
@GameMechanics/Messaging/TimeMessages.cs
@Threa/Threa.Client/Components/Pages/GamePlay/GmTable.razor

# Reference patterns
@GameMechanics/Items/ItemManagementService.cs
@Threa/Threa.Client/Components/Pages/GamePlay/Play.razor
@Threa/Threa.Client/Components/Pages/GamePlay/TabPlayInventory.razor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InventoryChanged enum value</name>
  <files>GameMechanics/Messaging/TimeMessages.cs</files>
  <action>
Add a new enum value to CharacterUpdateType for inventory changes.

In the CharacterUpdateType enum (around line 285-299), add after `StatsChanged`:

```csharp
/// <summary>Inventory was modified (item added, removed, or changed).</summary>
InventoryChanged
```

This allows the existing CharacterUpdateMessage infrastructure to notify players when their inventory changes from GM actions.
  </action>
  <verify>Build succeeds: `dotnet build Threa.sln`</verify>
  <done>CharacterUpdateType.InventoryChanged enum value exists and project compiles</done>
</task>

<task type="auto">
  <name>Task 2: Add Item Distribution panel to GmTable.razor</name>
  <files>Threa/Threa.Client/Components/Pages/GamePlay/GmTable.razor</files>
  <action>
Add an "Item Distribution" panel to GmTable.razor that allows GM to grant items to characters.

**1. Add required injections** (after existing @inject lines ~line 24):
```razor
@inject IItemTemplateDal itemTemplateDal
@inject GameMechanics.Items.ItemManagementService itemManagementService
```

And add using statement:
```razor
@using Threa.Dal
@using Threa.Dal.Dto
```

**2. Add state fields** (in @code block, after `private string announcementText = "";` ~line 373):
```csharp
// Item distribution state
private List<ItemTemplate>? allTemplates;
private ItemType? selectedItemType;
private string itemSearchText = "";
private ItemTemplate? selectedTemplate;
private int grantQuantity = 1;

private IEnumerable<ItemTemplate> filteredTemplates =>
    allTemplates?
        .Where(t => t.IsActive)
        .Where(t => selectedItemType == null || t.ItemType == selectedItemType)
        .Where(t => string.IsNullOrEmpty(itemSearchText) ||
                    t.Name.Contains(itemSearchText, StringComparison.OrdinalIgnoreCase))
        .OrderBy(t => t.Name)
        .Take(15)
    ?? Enumerable.Empty<ItemTemplate>();

private static readonly ItemType[] itemTypes = Enum.GetValues<ItemType>();
```

**3. Load templates in LoadTable()** (add at end of LoadTable method, before catch):
```csharp
allTemplates = await itemTemplateDal.GetAllTemplatesAsync();
```

**4. Add Item Distribution UI panel** (after NPCs Panel, around line 167, before the closing `</div>` of col-md-4):
```razor
<!-- Item Distribution Panel -->
<div class="card mt-3">
    <div class="card-header d-flex justify-content-between align-items-center">
        <strong>Item Distribution</strong>
    </div>
    <div class="card-body">
        <!-- Search and Filter -->
        <div class="mb-2">
            <div class="input-group input-group-sm">
                <input type="text" class="form-control" placeholder="Search items..."
                       @bind="itemSearchText" @bind:event="oninput" />
                <select class="form-select" @bind="selectedItemType" style="max-width: 100px;">
                    <option value="">All</option>
                    @foreach (var type in itemTypes)
                    {
                        <option value="@type">@type</option>
                    }
                </select>
            </div>
        </div>

        <!-- Item List -->
        <div style="max-height: 200px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px;">
            @if (!filteredTemplates.Any())
            {
                <p class="text-muted small p-2 mb-0">No items found.</p>
            }
            else
            {
                @foreach (var template in filteredTemplates)
                {
                    <div class="p-2 border-bottom item-row @(selectedTemplate?.Id == template.Id ? "bg-primary text-white" : "")"
                         style="cursor: pointer;"
                         @onclick="() => SelectTemplate(template)">
                        <strong>@template.Name</strong>
                        <small class="ms-1 @(selectedTemplate?.Id == template.Id ? "" : "text-muted")">(@template.ItemType)</small>
                    </div>
                }
            }
        </div>

        <!-- Grant Controls -->
        @if (selectedTemplate != null && selectedCharacter != null)
        {
            <div class="mt-2 p-2 bg-light rounded">
                <div class="small mb-1">
                    Grant <strong>@selectedTemplate.Name</strong> to <strong>@selectedCharacter.CharacterName</strong>
                </div>
                <div class="input-group input-group-sm">
                    <span class="input-group-text">Qty</span>
                    <input type="number" class="form-control" @bind="grantQuantity"
                           min="1" max="@(selectedTemplate.IsStackable ? 999 : 1)" style="max-width: 80px;" />
                    <button class="btn btn-success" @onclick="GrantItemToCharacter">
                        <i class="bi bi-gift"></i> Grant
                    </button>
                </div>
                @if (!selectedTemplate.IsStackable && grantQuantity > 1)
                {
                    <small class="text-warning">This item is not stackable. Quantity will be 1.</small>
                }
            </div>
        }
        else
        {
            <p class="text-muted small mt-2 mb-0">Select an item and a character to grant.</p>
        }
    </div>
</div>
```

**5. Add helper methods** (in @code block, before the closing brace):
```csharp
private void SelectTemplate(ItemTemplate template)
{
    selectedTemplate = selectedTemplate?.Id == template.Id ? null : template;
    grantQuantity = 1;
}

private async Task GrantItemToCharacter()
{
    if (selectedCharacter == null || selectedTemplate == null || table == null)
        return;

    try
    {
        // Fetch full CharacterEdit for ItemManagementService
        var targetCharacter = await characterPortal.FetchAsync(selectedCharacter.CharacterId);

        // Create the item instance
        var newItem = new CharacterItem
        {
            Id = Guid.NewGuid(),
            ItemTemplateId = selectedTemplate.Id,
            OwnerCharacterId = selectedCharacter.CharacterId,
            StackSize = selectedTemplate.IsStackable ? grantQuantity : 1,
            CurrentDurability = selectedTemplate.HasDurability ? selectedTemplate.MaxDurability : null,
            CreatedAt = DateTime.UtcNow
        };

        // Add via service (handles effects)
        var result = await itemManagementService.AddItemToInventoryAsync(targetCharacter, newItem);

        if (!result.Success)
        {
            errorMessage = result.ErrorMessage;
            return;
        }

        // Notify player to refresh inventory
        await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
        {
            CharacterId = selectedCharacter.CharacterId,
            UpdateType = CharacterUpdateType.InventoryChanged,
            CampaignId = table.Id.ToString(),
            SourceId = "GM",
            Description = $"Granted {(selectedTemplate.IsStackable ? grantQuantity : 1)}x {selectedTemplate.Name}"
        });

        // Log the action
        var qty = selectedTemplate.IsStackable ? grantQuantity : 1;
        AddLogEntry($"Granted {qty}x {selectedTemplate.Name} to {selectedCharacter.CharacterName}", ActivityCategory.General);

        // Reset for next grant
        grantQuantity = 1;
        selectedTemplate = null;
    }
    catch (Exception ex)
    {
        errorMessage = $"Failed to grant item: {ex.Message}";
    }
}
```

**Key points:**
- Reuse existing `selectedCharacter` from character selection (already populated when GM clicks a character card)
- Use ItemManagementService.AddItemToInventoryAsync for proper effect handling
- Publish CharacterUpdateMessage with InventoryChanged type
- Player's Play.razor OnCharacterUpdateReceived already handles refresh
- Non-stackable items are forced to quantity 1
  </action>
  <verify>
1. Build succeeds: `dotnet build Threa.sln`
2. Run app and navigate to GM Table page
3. Verify "Item Distribution" panel appears below NPCs panel
4. Search for "sword" - items should filter
5. Select a character from character list, select an item, set quantity, click Grant
6. Check activity log shows grant message
  </verify>
  <done>
- Item Distribution panel visible on GM Table page
- Item search and type filter work
- Grant button creates item via ItemManagementService
- CharacterUpdateMessage published with InventoryChanged type
- Activity log shows grant action
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify player receives granted items in real-time</name>
  <files>None (verification only)</files>
  <action>
Verify the existing Play.razor infrastructure correctly handles InventoryChanged messages.

**Verification steps (no code changes needed):**

1. Review Play.razor OnCharacterUpdateReceived (lines 682-701):
   - Already handles ALL CharacterUpdateMessage types
   - Calls `character = await characterPortal.FetchAsync(character.Id)`
   - Calls `await LoadEquippedItemsAsync()`
   - Calls `StateHasChanged()`

2. Review TabPlayInventory.razor OnParametersSetAsync (lines 581-588):
   - Already reloads items when Character parameter changes
   - `await LoadItemsAsync()` is called

3. The chain is:
   - GM grants item -> CharacterUpdateMessage(InventoryChanged) published
   - Player's TimeEventSubscriber receives message
   - OnCharacterUpdateReceived fires
   - Character is re-fetched (includes new item)
   - TabPlayInventory.OnParametersSetAsync triggers (character object reference changed)
   - LoadItemsAsync reloads inventory from DAL

The existing code handles this without modification because:
- OnCharacterUpdateReceived doesn't filter by UpdateType - it refreshes for ANY update
- The character refetch from DAL includes all items
- TabPlayInventory reloads when Character parameter changes

**Manual test to verify:**
1. Open GM Table in one browser tab
2. Open Play page for a character at that table in another tab
3. From GM tab, grant an item to the character
4. Player tab should show the new item in Inventory tab without refresh
  </action>
  <verify>
Manual test with two browser windows:
1. Browser A: GM Table page with characters
2. Browser B: Play page with character at same table
3. GM grants item via Item Distribution panel
4. Player sees item in inventory immediately (within 1-2 seconds)
  </verify>
  <done>Player receives granted items in real-time via existing CharacterUpdateMessage infrastructure</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   - `dotnet build Threa.sln` passes
   - No compiler warnings in modified files

2. **Functional verification:**
   - Navigate to GM Table page at /gamemaster/table/{id}
   - "Item Distribution" panel appears below NPCs panel
   - Item search filters by name
   - Item type dropdown filters by type
   - Clicking item selects/deselects it (highlighted)
   - Selecting character + item shows grant controls
   - Quantity input respects stackable flag
   - Grant button creates item and logs action

3. **Real-time verification:**
   - Two browser windows: GM and Player
   - GM grants item to character
   - Player inventory updates within 2 seconds
   - No manual refresh required

4. **Edge cases:**
   - Non-stackable items force quantity 1
   - Deactivated templates don't appear in list
   - Error message shows if grant fails
</verification>

<success_criteria>
- [ ] CharacterUpdateType.InventoryChanged enum value exists
- [ ] Item Distribution panel visible on GM Table page
- [ ] GM can search and filter item templates
- [ ] GM can select item and character to grant
- [ ] Grant creates item via ItemManagementService (handles effects)
- [ ] CharacterUpdateMessage published after grant
- [ ] Player receives item in real-time (no refresh needed)
- [ ] Activity log shows grant action
- [ ] All requirements (DIST-01, DIST-02, DIST-03) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/07-item-distribution/07-01-SUMMARY.md`
</output>
