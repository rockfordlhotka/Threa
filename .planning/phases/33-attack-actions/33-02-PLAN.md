---
phase: 33-attack-actions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Threa/Threa.Client/Components/Pages/GamePlay/RangedAttackMode.razor
autonomous: true

must_haves:
  truths:
    - "Player clicking ranged Attack button sees a target selection step with 'Anonymous Target' as an option"
    - "After selecting Anonymous Target, player sees simplified TV modifier input (single number field) instead of full range/conditions/cover UI"
    - "After entering TV and rolling, player sees SV-only result display (AV - TV = SV) for anonymous ranged target"
    - "Anonymous ranged attack result logs to the activity feed with SV information"
    - "Weapon selection, fire mode, cost, and boost remain available for anonymous ranged targets"
    - "Full range/conditions/cover UI still works for non-anonymous targets (no regression)"
  artifacts:
    - path: "Threa/Threa.Client/Components/Pages/GamePlay/RangedAttackMode.razor"
      provides: "Target selection step, anonymous TV input, SV-only result display"
      contains: "Anonymous Target"
  key_links:
    - from: "RangedAttackMode.razor target selection"
      to: "RangedAttackMode.razor setup flow"
      via: "targetSelected boolean gates which TV input shows"
      pattern: "targetSelected"
    - from: "RangedAttackMode.razor anonymous TV input"
      to: "RangedAttackMode.razor ExecuteAttack()"
      via: "anonymousTVModifier feeds into FirearmAttackRequest"
      pattern: "anonymousTVModifier"
---

<objective>
Add anonymous target support to the ranged attack flow with simplified TV modifier input and SV-only result display.

Purpose: Enables solo ranged attacks where the player enters a single TV modifier number, rolls, and sees SV. This is the simplified path for anonymous targets alongside the full range/conditions/cover breakdown for real targets.

Output: Modified RangedAttackMode.razor with target selection step, conditional TV input, and conditional result display.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-attack-actions/33-CONTEXT.md
@.planning/phases/33-attack-actions/33-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add target selection and anonymous ranged attack flow to RangedAttackMode</name>
  <files>
    Threa/Threa.Client/Components/Pages/GamePlay/RangedAttackMode.razor
  </files>
  <action>
Modify `RangedAttackMode.razor` to add a target selection step and a simplified anonymous target flow. The changes are structured in three areas: target selection, setup phase, and result phase.

**New fields** (add to `@code` block):

```csharp
private bool targetSelected = false;
private bool isAnonymousTarget = false;
private int anonymousTVModifier = 0;
```

**1. Target Selection Step (replaces current flow when target not selected)**

Wrap the existing `@if (!hasRolled)` / `else` block inside an outer conditional:

- If `!targetSelected`: show target selection card (same pattern as melee in Plan 33-01):
  - Card header: "Select Target"
  - Card body with list-group:
    - "Anonymous Target" button with icon `bi-question-circle`, small text: "Solo attack — enter TV modifier, see SV after rolling"
    - On click: `targetSelected = true; isAnonymousTarget = true;`
  - Include the Cancel button row below the card (or keep the existing header cancel button visible).

- If `targetSelected`: show the existing `@if (!hasRolled)` / `else` flow, but with modifications below.

**2. Setup Phase Modifications (when `!hasRolled` and `targetSelected`)**

When `isAnonymousTarget` is true, replace the following cards with a single simplified TV input:
- **KEEP**: Card 1 (Weapon selection) — player still picks weapon
- **KEEP**: Card 2 (Fire Mode) — player still picks fire mode
- **REPLACE cards 3-6** (Range, Target Conditions, Attacker Conditions, Dodge Result) with a SINGLE card:
  - Card header: "Target Value (TV)"
  - Card body: An input-group with label "Total TV Modifier" and `<input type="number" @bind="anonymousTVModifier" />`
  - Small muted help text: "Enter total TV modifier (range, cover, conditions, etc.)"

When `isAnonymousTarget` is false, show the existing full UI unchanged (cards 3-6 as they are today).

- **KEEP**: Action Cost card and Boost card — always shown regardless of target type.

Update the step numbering in the card headers dynamically. When anonymous:
- 1. Weapon
- 2. Fire Mode
- 3. Target Value (TV)
- 4. Action Cost
- 5. Boost (Optional)

When not anonymous (existing flow):
- 1. Weapon
- 2. Fire Mode
- 3. Range
- 4. Target Conditions
- 5. Attacker Conditions
- 6. Defender's Dodge Result (if applicable)
- 7/6. Action Cost
- 8/7. Boost

**In the Attack Summary card** (right column), when `isAnonymousTarget`:
- Show weapon, attack type, skill AS, weapon modifier, boost, multi-action penalty, effect modifiers, AV Base (same calculation)
- Instead of the full TV breakdown (range, moving, prone, cover, size, dodge, fire mode), show a single row: "TV Modifier: @anonymousTVModifier"
- Keep the cost, boost cost, and ammo display rows

**3. ExecuteAttack() Modification**

When `isAnonymousTarget` is true, modify the `FirearmAttackRequest` construction:
- Set `Range = RangeCategory.Short` (doesn't matter, but required field)
- Set `TargetIsMoving = false`, `TargetIsProne = false`, `TargetIsCrouching = false`
- Set `TargetCover = CoverType.None`, `TargetSize = TargetSize.Normal`
- Set `TVAdjustment = anonymousTVModifier` — this makes the resolver use ONLY the player's TV modifier as the total TV adjustment
- Keep `AttackerIsMoving = false` (anonymous path skips attacker conditions)

Wait — actually, the `RangeModifiers.GetBaseTV(RangeCategory.Short)` would add a base TV from range, which we don't want for anonymous. The cleanest approach: set `TVAdjustment` to the full anonymous TV and set range to a value that contributes 0 TV. Check what `RangeModifiers.GetBaseTV(RangeCategory.PointBlank)` returns — if there's no PointBlank, check the enum values.

Alternative better approach: Since the `FirearmAttackResolver` adds up range TV + modifiers + TVAdjustment, and we want ONLY the player's number, we can set `TVAdjustment = anonymousTVModifier - RangeModifiers.GetBaseTV(RangeCategory.Short)` to cancel out the range base. But this is fragile.

**Simplest correct approach**: For anonymous targets, skip the `FirearmAttackResolver` entirely and do inline dice rolling (same as melee AttackMode does). This avoids coupling to the resolver's TV calculation:

```csharp
if (isAnonymousTarget)
{
    // Inline dice roll for anonymous target (same pattern as melee AttackMode)
    int avBase = GetAVBase();
    int diceRoll = GameMechanics.Dice.Roll4dFPlus();
    int av = avBase + diceRoll;
    int sv = av - anonymousTVModifier;
    int ammoConsumed = GetAmmoConsumption();
    int ammoRemaining = Math.Max(0, weapon.LoadedAmmo - ammoConsumed);

    attackResult = new FirearmAttackResult
    {
        AVBase = avBase,
        DiceRoll = diceRoll,
        AV = av,
        TV = anonymousTVModifier,
        RV = sv, // RV = AV - TV in the resolver, same as SV for single shot
        Hit = sv >= 0,
        FireMode = selectedFireMode,
        AmmoConsumed = ammoConsumed,
        AmmoRemaining = ammoRemaining,
        IsAOE = weapon.IsAOECapable,
        BlastRadius = weapon.BlastRadius,
        Hits = sv >= 0
            ? new List<FirearmHitResult> { new() { ShotNumber = 1, Hit = true, SV = sv + (weapon.BaseSV + weapon.AmmoDamageModifier), TVForShot = anonymousTVModifier, RVForShot = sv } }
            : new List<FirearmHitResult>(),
        OutputSV = weapon.IsAOECapable && sv >= 0 ? sv + (weapon.BaseSV + weapon.AmmoDamageModifier) : null,
        DirectHitSV = weapon.IsAOECapable && sv >= 0 ? sv + (weapon.BaseSV + weapon.AmmoDamageModifier) + weapon.DirectHitBonus : null
    };
    hasRolled = true;
}
```

Wait — this gets complicated and fragile with `FirearmAttackResult` construction. Let me reconsider.

**REVISED simplest approach**: Actually, check the `FirearmAttackResult` class to see if it can be constructed directly, or whether the resolver is the only clean way. Read `FirearmAttackResult.cs` and `FirearmAttackResolver.cs` to understand the result shape.

Actually, the best approach is: **Use the resolver, but correctly set TVAdjustment to achieve the desired total TV.** The resolver calculates TV as:
```
TV = RangeModifiers.GetBaseTV(Range) + movement + cover + size + TVAdjustment + fireModeTVMod
```

For anonymous targets, we want `TV = anonymousTVModifier`. So set:
- `Range = RangeCategory.Short` and `TVAdjustment = anonymousTVModifier - RangeModifiers.GetBaseTV(RangeCategory.Short)` minus any fire mode contribution

This is fragile. Instead, look at `RangeCategory` enum values — if there's a value with base TV = 0, use that. Check the `RangeModifiers.GetBaseTV` method.

**FINAL approach — just use TVAdjustment as the sole TV source:**

Set all condition flags to produce zero modifiers:
- `Range` = whatever has lowest TV... or better yet, just subtract out:

```csharp
// For anonymous targets: we want total TV = anonymousTVModifier
// The resolver adds: baseTV(range) + conditions + tvAdjustment + fireModeTV
// We set conditions to zero, pick Short range, and calculate tvAdjustment to cancel out baseTV + fireModeTV
int baseRangeTV = RangeModifiers.GetBaseTV(RangeCategory.Short);
int fireModeTV = selectedFireMode == FireMode.Burst ? 1 : selectedFireMode == FireMode.Suppression ? 3 : 0;
request.TVAdjustment = anonymousTVModifier - baseRangeTV - fireModeTV;
```

Actually this is getting too complex for the plan. Let me simplify the instruction:

**REVISED FINAL APPROACH**: Read `FirearmAttackResolver.cs` and `RangeModifiers.cs` at execution time to understand TV calculation. Then construct the request such that the total TV equals `anonymousTVModifier`. The key insight: set `Range = RangeCategory.Short`, all target condition bools false, cover None, size Normal, TVAdjustment = (anonymousTVModifier minus whatever GetBaseTV(Short) returns minus fire mode TV modifier). Read the resolver source to confirm the TV formula, then compute the correct TVAdjustment offset.

If this proves too fragile, fall back to inline dice rolling (bypass the resolver) and construct `FirearmAttackResult` manually. The result object is a simple POCO — check its constructor/properties.

**4. Result Phase Modifications (when `hasRolled` and `targetSelected`)**

When `isAnonymousTarget` is true, replace the full result breakdown with a simplified display:

Show a card with:
- Header: "bg-success" if SV >= 0, "bg-secondary" if SV < 0, with "Hit!" or "Miss" text
- Body: simplified table showing:
  - AV Base: @attackResult.AVBase
  - Dice Roll: @attackResult.DiceRoll (with +/- formatting)
  - **Attack Value (AV): @attackResult.AV** (bold, primary row)
  - Separator
  - TV Modifier: @anonymousTVModifier
  - **Success Value (SV): @(attackResult.AV - anonymousTVModifier)** (bold, large — this is THE key output)
- Ammo consumed/remaining display (same as existing)
- Footer: Done + New Attack + Change Target buttons

When `isAnonymousTarget` is false, show the existing full result display unchanged (no regression).

**5. CompleteAttack() Modification**

When `isAnonymousTarget`, generate a simplified activity log message:
```csharp
var sv = attackResult.AV - anonymousTVModifier;
var message = $"{Character?.Name} fires {weapon?.Name} vs anonymous target ({attackResult.FireMode}): AV {attackResult.AV}, TV {anonymousTVModifier}, SV {sv}";
message += $" ({attackResult.AmmoConsumed} ammo used, {attackResult.AmmoRemaining} remaining)";
```

**6. Navigation buttons**

- In `ResetAttack()`, do NOT reset `targetSelected` or `isAnonymousTarget` — "New Attack" stays on same target
- Add a "Change Target" button in the result footer that resets `targetSelected = false`, `isAnonymousTarget = false`, `anonymousTVModifier = 0`, and calls `ResetAttack()`
- The Cancel button continues to call `OnCancel` unchanged

**Important constraints:**
- Do NOT create new files or components
- Do NOT modify `FirearmAttackResolver` or any game mechanics code
- Do NOT remove any existing UI elements — only conditionally hide/show based on `isAnonymousTarget`
- Weapon selection and fire mode selection MUST still work for anonymous targets (they affect damage)
- AP/FAT costs are fully applied for anonymous targets (same code path)
  </action>
  <verify>
    Build the solution with `dotnet build Threa.sln` from the project root. Verify zero build errors.
  </verify>
  <done>
    - RangedAttackMode shows target selection as first step with "Anonymous Target" option
    - Anonymous path shows simplified single TV modifier input (not full range/conditions)
    - Anonymous result shows SV-only display (AV - TV = SV)
    - Weapon selection and fire mode work for anonymous targets
    - AP/FAT costs apply for anonymous targets
    - Activity log shows SV for anonymous ranged attacks
    - Existing full ranged attack flow (range/conditions/cover/dodge) works unchanged when not anonymous
    - Build succeeds with zero errors
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` — zero errors
2. Grep for "Anonymous Target" in RangedAttackMode.razor — should find target selection card
3. Grep for "anonymousTVModifier" in RangedAttackMode.razor — should find simplified TV input
4. Grep for "isAnonymousTarget" in RangedAttackMode.razor — should find conditional rendering
5. The existing full range/conditions/cover UI is preserved behind `@if (!isAnonymousTarget)` guard
6. SV calculation in anonymous result: attackResult.AV - anonymousTVModifier
</verification>

<success_criteria>
- Build passes
- Ranged attack flow has target selection as first step
- Anonymous Target option is present with simplified TV input
- Anonymous result shows SV = AV - TV clearly
- Existing full ranged attack flow is unchanged when target is not anonymous
- Weapon selection and fire mode are available for anonymous targets
</success_criteria>

<output>
After completion, create `.planning/phases/33-attack-actions/33-02-SUMMARY.md`
</output>
