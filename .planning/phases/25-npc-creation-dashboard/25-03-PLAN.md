---
phase: 25-npc-creation-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - GameMechanics/NpcSpawner.cs
autonomous: true

must_haves:
  truths:
    - "GM can spawn an NPC instance from a template"
    - "Spawned NPC is a full Character with IsNpc=true, IsTemplate=false, IsPlayable=true"
    - "Spawned NPC copies all stats from template"
    - "Spawned NPC is attached to the active table"
  artifacts:
    - path: "GameMechanics/NpcSpawner.cs"
      provides: "CSLA CommandBase for NPC spawning"
      contains: "ExecuteAsync"
      exports: ["NpcSpawner"]
  key_links:
    - from: "GameMechanics/NpcSpawner.cs"
      to: "ICharacterDal"
      via: "Fetch template, save spawned NPC"
      pattern: "characterDal\\.GetCharacterAsync"
    - from: "GameMechanics/NpcSpawner.cs"
      to: "ITableDal"
      via: "Attach NPC to table"
      pattern: "tableDal\\.AddCharacterToTableAsync"
---

<objective>
Create NpcSpawner CSLA command that spawns a new NPC instance from a template, copying all stats and attaching to the active table.

Purpose: This is the core business logic for CRTN-01 (quick-create NPC from template) and CRTN-02 (NPCs have full character stats). The spawner clones the template character, sets NPC flags, and attaches to the table.

Output: Working NPC spawner command that creates full CharacterEdit instances from templates.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-npc-creation-dashboard/25-RESEARCH.md
@.planning/phases/25-npc-creation-dashboard/25-01-SUMMARY.md

# Key patterns
@GameMechanics/CharacterEdit.cs
@GameMechanics/GamePlay/JoinRequestProcessor.cs
@Threa.Dal/ICharacterDal.cs
@Threa.Dal/ITableDal.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NpcSpawner command object</name>
  <files>GameMechanics/NpcSpawner.cs</files>
  <action>
Create new file `GameMechanics/NpcSpawner.cs`:

```csharp
using Csla;
using System;
using System.Linq;
using System.Threading.Tasks;
using Threa.Dal;
using Threa.Dal.Dto;

namespace GameMechanics;

/// <summary>
/// CSLA command that spawns a new NPC instance from a template.
/// Creates a full CharacterEdit with IsNpc=true, IsTemplate=false, IsPlayable=true.
/// </summary>
[Serializable]
public class NpcSpawner : CommandBase<NpcSpawner>
{
    #region Input Parameters

    public static readonly PropertyInfo<int> TemplateIdProperty = RegisterProperty<int>(nameof(TemplateId));
    public int TemplateId
    {
        get => ReadProperty(TemplateIdProperty);
        set => LoadProperty(TemplateIdProperty, value);
    }

    public static readonly PropertyInfo<Guid> TableIdProperty = RegisterProperty<Guid>(nameof(TableId));
    public Guid TableId
    {
        get => ReadProperty(TableIdProperty);
        set => LoadProperty(TableIdProperty, value);
    }

    public static readonly PropertyInfo<string> NameProperty = RegisterProperty<string>(nameof(Name));
    public string Name
    {
        get => ReadProperty(NameProperty);
        set => LoadProperty(NameProperty, value);
    }

    public static readonly PropertyInfo<NpcDisposition> DispositionProperty = RegisterProperty<NpcDisposition>(nameof(Disposition));
    public NpcDisposition Disposition
    {
        get => ReadProperty(DispositionProperty);
        set => LoadProperty(DispositionProperty, value);
    }

    public static readonly PropertyInfo<string?> SessionNotesProperty = RegisterProperty<string?>(nameof(SessionNotes));
    public string? SessionNotes
    {
        get => ReadProperty(SessionNotesProperty);
        set => LoadProperty(SessionNotesProperty, value);
    }

    #endregion

    #region Output

    public static readonly PropertyInfo<int> SpawnedCharacterIdProperty = RegisterProperty<int>(nameof(SpawnedCharacterId));
    public int SpawnedCharacterId
    {
        get => ReadProperty(SpawnedCharacterIdProperty);
        private set => LoadProperty(SpawnedCharacterIdProperty, value);
    }

    public static readonly PropertyInfo<bool> SuccessProperty = RegisterProperty<bool>(nameof(Success));
    public bool Success
    {
        get => ReadProperty(SuccessProperty);
        private set => LoadProperty(SuccessProperty, value);
    }

    public static readonly PropertyInfo<string?> ErrorMessageProperty = RegisterProperty<string?>(nameof(ErrorMessage));
    public string? ErrorMessage
    {
        get => ReadProperty(ErrorMessageProperty);
        private set => LoadProperty(ErrorMessageProperty, value);
    }

    #endregion

    [Execute]
    private async Task ExecuteAsync(
        [Inject] ICharacterDal characterDal,
        [Inject] ITableDal tableDal,
        [Inject] IChildDataPortal<AttributeEdit> attrPortal,
        [Inject] IChildDataPortal<SkillEdit> skillPortal)
    {
        try
        {
            // 1. Fetch template character
            var template = await characterDal.GetCharacterAsync(TemplateId);
            if (template == null)
            {
                Success = false;
                ErrorMessage = $"Template {TemplateId} not found";
                return;
            }

            // 2. Create new character DTO by copying template
            var npc = new Character
            {
                PlayerId = template.PlayerId, // GM's player ID
                Name = Name,
                TrueName = template.TrueName,
                Aliases = template.Aliases,
                Species = template.Species,
                DamageClass = template.DamageClass,
                Height = template.Height,
                Weight = template.Weight,
                SkinDescription = template.SkinDescription,
                HairDescription = template.HairDescription,
                Description = template.Description,
                Birthdate = template.Birthdate,
                ImageUrl = template.ImageUrl,

                // Health pools - copy base values and set current to max
                FatBaseValue = template.FatBaseValue,
                FatValue = template.FatBaseValue, // Start at full
                VitBaseValue = template.VitBaseValue,
                VitValue = template.VitBaseValue, // Start at full

                // Action points - start at max
                ActionPointMax = template.ActionPointMax,
                ActionPointRecovery = template.ActionPointRecovery,
                ActionPointAvailable = template.ActionPointMax,

                // XP
                XPTotal = template.XPTotal,
                XPBanked = template.XPBanked,

                // Currency
                CopperCoins = template.CopperCoins,
                SilverCoins = template.SilverCoins,
                GoldCoins = template.GoldCoins,
                PlatinumCoins = template.PlatinumCoins,

                // NPC flags - this is the key part
                IsNpc = true,
                IsTemplate = false,
                IsPlayable = true, // Ready for play immediately
                VisibleToPlayers = template.VisibleToPlayers,

                // Disposition - use parameter override or template default
                DefaultDisposition = Disposition,

                // Template organization - NPCs don't need these
                Category = null,
                Tags = null,
                TemplateNotes = null,
                DifficultyRating = template.DifficultyRating,

                // Source template tracking
                SourceTemplateId = TemplateId,
                SourceTemplateName = template.Name,

                // Session notes
                Notes = SessionNotes ?? string.Empty
            };

            // 3. Copy attributes
            npc.AttributeList = template.AttributeList
                .Select(a => new CharacterAttribute
                {
                    Name = a.Name,
                    Value = a.Value
                })
                .ToList();

            // 4. Copy skills
            npc.Skills = template.Skills
                .Select(s => new CharacterSkill
                {
                    Name = s.Name,
                    BaseLevel = s.BaseLevel,
                    TotalLevel = s.TotalLevel,
                    AssociatedAttributeName = s.AssociatedAttributeName,
                    DefaultLevel = s.DefaultLevel,
                    IsAvailable = s.IsAvailable
                })
                .ToList();

            // 5. Save the new NPC character
            var savedId = await characterDal.InsertCharacterAsync(npc);
            npc.Id = savedId;

            // 6. Attach to table
            var tableChar = new TableCharacter
            {
                TableId = TableId,
                CharacterId = savedId,
                PlayerId = template.PlayerId,
                JoinedAt = DateTime.UtcNow,
                ConnectionStatus = ConnectionStatus.Connected,
                GmNotes = SessionNotes
            };
            await tableDal.AddCharacterToTableAsync(tableChar);

            SpawnedCharacterId = savedId;
            Success = true;
        }
        catch (Exception ex)
        {
            Success = false;
            ErrorMessage = ex.Message;
        }
    }
}
```

Key implementation decisions per RESEARCH.md:
- Uses CommandBase pattern (like JoinRequestProcessor)
- NPCs get IsPlayable=true immediately (no activation needed)
- Health pools start at full (base values copied to current)
- AP starts at max
- Disposition can override template default
- SourceTemplateId/SourceTemplateName track origin
- Session notes stored in both Notes field and TableCharacter.GmNotes
  </action>
  <verify>
    Run: `dotnet build GameMechanics/GameMechanics.csproj`
    Expect: Build succeeds
  </verify>
  <done>
    NpcSpawner command exists with Execute method that clones template to NPC.
    Spawned NPC has correct flags (IsNpc=true, IsTemplate=false, IsPlayable=true).
    Spawned NPC is attached to table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify solution build and integration</name>
  <files></files>
  <action>
Build full solution to ensure NpcSpawner integrates correctly:

1. Build GameMechanics project
2. Build full solution
3. Verify no compile errors with DAL interfaces
  </action>
  <verify>
    Run: `dotnet build S:/src/rdl/threa/Threa.sln`
    Expect: Build succeeded
  </verify>
  <done>
    Full solution builds with NpcSpawner command.
    DAL interfaces are correctly used.
  </done>
</task>

</tasks>

<verification>
1. `NpcSpawner.cs` exists in `GameMechanics/`
2. Command has input properties: TemplateId, TableId, Name, Disposition, SessionNotes
3. Command has output properties: SpawnedCharacterId, Success, ErrorMessage
4. Execute method clones template and sets NPC flags correctly
5. Spawned NPC is attached to table via TableCharacter
6. Solution builds successfully
</verification>

<success_criteria>
- NpcSpawner creates full Character from template
- Spawned NPC has IsNpc=true, IsTemplate=false, IsPlayable=true
- Spawned NPC tracks SourceTemplateId and SourceTemplateName
- Spawned NPC is attached to active table
- All stats copied from template (attributes, skills, health, AP)
</success_criteria>

<output>
After completion, create `.planning/phases/25-npc-creation-dashboard/25-03-SUMMARY.md`
</output>
