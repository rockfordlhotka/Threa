---
phase: 29-batch-action-framework
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - GameMechanics/Batch/BatchActionService.cs
  - GameMechanics/Batch/BatchActionRequest.cs
  - GameMechanics/Batch/BatchActionResult.cs
  - GameMechanics/ServiceCollectionExtensions.cs
autonomous: true

must_haves:
  truths:
    - "BatchActionService can apply damage to multiple characters sequentially"
    - "BatchActionService can apply healing to multiple characters sequentially"
    - "Partial failures are captured with character-specific error messages"
    - "Single CharactersUpdatedMessage published after batch completes"
  artifacts:
    - path: "GameMechanics/Batch/BatchActionService.cs"
      provides: "Batch damage/healing orchestration service"
      contains: "ApplyDamageAsync"
    - path: "GameMechanics/Batch/BatchActionRequest.cs"
      provides: "Request DTO with character IDs, pool, amount, tableId"
      contains: "BatchActionRequest"
    - path: "GameMechanics/Batch/BatchActionResult.cs"
      provides: "Result with success/failure lists and summary"
      contains: "BatchActionResult"
  key_links:
    - from: "GameMechanics/Batch/BatchActionService.cs"
      to: "IDataPortal<CharacterEdit>"
      via: "DI injection for fetch/update"
      pattern: "IDataPortal.*CharacterEdit"
    - from: "GameMechanics/Batch/BatchActionService.cs"
      to: "ITimeEventPublisher"
      via: "DI injection for CharactersUpdatedMessage"
      pattern: "ITimeEventPublisher"
---

<objective>
Create BatchActionService backend following TimeAdvancementService sequential processing pattern

Purpose: Establish the backend service that processes batch damage/healing operations with proper error aggregation and single message notification
Output: BatchActionService class with ApplyDamageAsync and ApplyHealingAsync methods, plus supporting request/result DTOs
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-batch-action-framework/29-RESEARCH.md
@GameMechanics/Time/TimeAdvancementService.cs
@Threa/Threa.Client/Components/Shared/CharacterDetailGmActions.razor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BatchActionRequest and BatchActionResult classes</name>
  <files>
    GameMechanics/Batch/BatchActionRequest.cs
    GameMechanics/Batch/BatchActionResult.cs
  </files>
  <action>
Create two new files in GameMechanics/Batch/ directory:

**BatchActionRequest.cs:**
```csharp
namespace GameMechanics.Batch;

public class BatchActionRequest
{
    public Guid TableId { get; set; }
    public List<int> CharacterIds { get; set; } = new();
    public BatchActionType ActionType { get; set; }
    public string Pool { get; set; } = "FAT";  // "FAT" or "VIT"
    public int Amount { get; set; }
}

public enum BatchActionType { Damage, Healing }
```

**BatchActionResult.cs:**
```csharp
namespace GameMechanics.Batch;

public class BatchActionResult
{
    public BatchActionType ActionType { get; set; }
    public string Pool { get; set; } = "";
    public int Amount { get; set; }

    public List<int> SuccessIds { get; } = new();
    public List<string> SuccessNames { get; } = new();
    public List<int> FailedIds { get; } = new();
    public List<string> Errors { get; } = new();

    public int TotalCount => SuccessIds.Count + FailedIds.Count;
    public bool HasFailures => FailedIds.Count > 0;
    public bool AllSucceeded => FailedIds.Count == 0 && SuccessIds.Count > 0;

    public string Summary => HasFailures
        ? $"Applied {Amount} {Pool} {ActionType.ToString().ToLower()} to {SuccessIds.Count} of {TotalCount} characters"
        : $"Applied {Amount} {Pool} {ActionType.ToString().ToLower()} to {SuccessIds.Count} character(s)";
}
```
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj --no-restore</verify>
  <done>BatchActionRequest and BatchActionResult classes compile without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create BatchActionService with sequential processing</name>
  <files>GameMechanics/Batch/BatchActionService.cs</files>
  <action>
Create BatchActionService.cs following TimeAdvancementService pattern:

```csharp
using Csla;
using GameMechanics.Messaging;

namespace GameMechanics.Batch;

/// <summary>
/// Service for applying batch actions to multiple characters.
/// Follows TimeAdvancementService pattern: sequential processing, error aggregation, single notification.
/// </summary>
public class BatchActionService
{
    private readonly IDataPortal<CharacterEdit> _characterPortal;
    private readonly ITimeEventPublisher _timeEventPublisher;

    public BatchActionService(
        IDataPortal<CharacterEdit> characterPortal,
        ITimeEventPublisher timeEventPublisher)
    {
        _characterPortal = characterPortal;
        _timeEventPublisher = timeEventPublisher;
    }

    /// <summary>
    /// Applies damage to multiple characters' pending damage pools.
    /// </summary>
    public async Task<BatchActionResult> ApplyDamageAsync(BatchActionRequest request)
    {
        return await ProcessBatchAsync(request with { ActionType = BatchActionType.Damage });
    }

    /// <summary>
    /// Applies healing to multiple characters' pending healing pools.
    /// </summary>
    public async Task<BatchActionResult> ApplyHealingAsync(BatchActionRequest request)
    {
        return await ProcessBatchAsync(request with { ActionType = BatchActionType.Healing });
    }

    private async Task<BatchActionResult> ProcessBatchAsync(BatchActionRequest request)
    {
        var result = new BatchActionResult
        {
            ActionType = request.ActionType,
            Pool = request.Pool,
            Amount = request.Amount
        };

        // Sequential processing - CSLA business objects are NOT thread-safe
        foreach (var characterId in request.CharacterIds)
        {
            try
            {
                var character = await _characterPortal.FetchAsync(characterId);

                if (request.ActionType == BatchActionType.Damage)
                {
                    if (request.Pool == "FAT")
                        character.Fatigue.PendingDamage += request.Amount;
                    else
                        character.Vitality.PendingDamage += request.Amount;
                }
                else // Healing
                {
                    if (request.Pool == "FAT")
                        character.Fatigue.PendingHealing += request.Amount;
                    else
                        character.Vitality.PendingHealing += request.Amount;
                }

                await _characterPortal.UpdateAsync(character);
                result.SuccessIds.Add(characterId);
                result.SuccessNames.Add(character.Name);
            }
            catch (Exception ex)
            {
                result.FailedIds.Add(characterId);
                result.Errors.Add($"Character {characterId}: {ex.Message}");
            }
        }

        // Single notification after all updates complete (prevents N refresh cycles)
        if (result.SuccessIds.Count > 0)
        {
            await _timeEventPublisher.PublishCharactersUpdatedAsync(
                new CharactersUpdatedMessage
                {
                    TableId = request.TableId,
                    CharacterIds = result.SuccessIds,
                    EventType = TimeEventType.EndOfRound,
                    SourceId = "BatchActionService"
                });
        }

        return result;
    }
}
```

Key patterns from TimeAdvancementService:
- Sequential foreach loop (NOT Task.WhenAll - CSLA not thread-safe)
- Try/catch per character for error isolation
- Error aggregation in result lists
- Single CharactersUpdatedMessage after batch completes
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj --no-restore</verify>
  <done>BatchActionService compiles with ApplyDamageAsync and ApplyHealingAsync methods</done>
</task>

<task type="auto">
  <name>Task 3: Register BatchActionService in DI</name>
  <files>GameMechanics/ServiceCollectionExtensions.cs</files>
  <action>
Add BatchActionService registration to ServiceCollectionExtensions.cs:

1. Add using statement at top: `using GameMechanics.Batch;`

2. In AddGameMechanicsServices method, add:
   `services.AddScoped<BatchActionService>();`

Place near other service registrations (after TimeAdvancementService if present).
  </action>
  <verify>dotnet build GameMechanics/GameMechanics.csproj --no-restore && grep -n "BatchActionService" GameMechanics/ServiceCollectionExtensions.cs</verify>
  <done>BatchActionService registered in DI container, visible in ServiceCollectionExtensions.cs</done>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` - Full solution builds
2. Verify BatchActionService is properly injectable by checking ServiceCollectionExtensions.cs
3. Verify request/result classes have all required properties
</verification>

<success_criteria>
- BatchActionService class exists with ApplyDamageAsync and ApplyHealingAsync methods
- BatchActionRequest has TableId, CharacterIds, ActionType, Pool, Amount properties
- BatchActionResult has SuccessIds, FailedIds, Errors lists and Summary property
- Service registered in DI container
- Full solution compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/29-batch-action-framework/29-01-SUMMARY.md`
</output>
