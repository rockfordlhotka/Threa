---
phase: 26-visibility-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - GameMechanics/GamePlay/TableCharacterInfo.cs
  - Threa.Dal/Dto/Character.cs
  - GameMechanics/CharacterEdit.cs
  - Threa.Dal/ICharacterDal.cs
  - Threa.Dal.MockDb/MockCharacterDal.cs
  - Threa.Dal.Sqlite/SqliteCharacterDal.cs
autonomous: true

must_haves:
  truths:
    - "TableCharacterInfo includes VisibleToPlayers property"
    - "Character DTO and CharacterEdit support IsArchived flag"
    - "DAL can query archived NPCs"
  artifacts:
    - path: "GameMechanics/GamePlay/TableCharacterInfo.cs"
      provides: "VisibleToPlayers property for dashboard filtering"
      contains: "VisibleToPlayers"
    - path: "Threa.Dal/Dto/Character.cs"
      provides: "IsArchived property for soft-delete pattern"
      contains: "IsArchived"
    - path: "GameMechanics/CharacterEdit.cs"
      provides: "IsArchived CSLA property"
      contains: "IsArchivedProperty"
    - path: "Threa.Dal/ICharacterDal.cs"
      provides: "GetArchivedNpcsAsync method"
      contains: "GetArchivedNpcsAsync"
  key_links:
    - from: "GameMechanics/GamePlay/TableCharacterInfo.cs"
      to: "Threa.Dal/Dto/Character.cs"
      via: "Fetch method populates VisibleToPlayers"
      pattern: "VisibleToPlayers = character\\.VisibleToPlayers"
---

<objective>
Extend data model to support NPC visibility tracking and archive functionality.

Purpose: Phase 26 requires TableCharacterInfo to include VisibleToPlayers for dashboard filtering (hidden vs visible NPCs) and IsArchived for soft-delete/archive pattern. These properties enable all subsequent visibility and lifecycle features.

Output: Extended DTOs, business objects, and DAL methods ready for UI integration.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/26-visibility-lifecycle/26-CONTEXT.md
@.planning/phases/26-visibility-lifecycle/26-RESEARCH.md

@GameMechanics/GamePlay/TableCharacterInfo.cs
@Threa.Dal/Dto/Character.cs
@GameMechanics/CharacterEdit.cs
@Threa.Dal/ICharacterDal.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add VisibleToPlayers to TableCharacterInfo</name>
  <files>GameMechanics/GamePlay/TableCharacterInfo.cs</files>
  <action>
Add VisibleToPlayers property to TableCharacterInfo:

1. Add CSLA property registration after existing NPC properties (around line 243):
```csharp
public static readonly PropertyInfo<bool> VisibleToPlayersProperty = RegisterProperty<bool>(nameof(VisibleToPlayers));
/// <summary>
/// Whether this NPC is visible to players (false = hidden for surprise).
/// Always true for PCs.
/// </summary>
public bool VisibleToPlayers
{
    get => GetProperty(VisibleToPlayersProperty);
    private set => LoadProperty(VisibleToPlayersProperty, value);
}
```

2. In the Fetch method (around line 326), add after SourceTemplateName assignment:
```csharp
VisibleToPlayers = character.VisibleToPlayers;
```

This enables GmTable to filter NPCs into Hidden vs disposition groups.
  </action>
  <verify>Build solution: `dotnet build Threa.sln` - no errors</verify>
  <done>TableCharacterInfo.VisibleToPlayers property exists and is populated from Character DTO in Fetch method</done>
</task>

<task type="auto">
  <name>Task 2: Add IsArchived to Character DTO and CharacterEdit</name>
  <files>
    Threa.Dal/Dto/Character.cs
    GameMechanics/CharacterEdit.cs
  </files>
  <action>
1. In Threa.Dal/Dto/Character.cs, add IsArchived property after SourceTemplateName (around line 117):
```csharp
/// <summary>
/// Whether this character is archived (dismissed but not deleted).
/// Archived characters don't appear in active lists but can be restored.
/// </summary>
public bool IsArchived { get; set; }
```

2. In GameMechanics/CharacterEdit.cs, add CSLA property after VisibleToPlayers property (around line 385):
```csharp
public static readonly PropertyInfo<bool> IsArchivedProperty = RegisterProperty<bool>(nameof(IsArchived));
[Display(Name = "Is Archived")]
public bool IsArchived
{
    get => GetProperty(IsArchivedProperty);
    set => SetProperty(IsArchivedProperty, value);
}
```

3. In CharacterEdit DataMapper operations, ensure IsArchived is mapped (if using AutoMapper or manual mapping, add to the mapping).

Note: The existing Dapper-based DAL uses direct property assignment, so no additional mapping configuration needed if the column exists in the database.
  </action>
  <verify>Build solution: `dotnet build Threa.sln` - no errors</verify>
  <done>IsArchived property exists on both Character DTO and CharacterEdit with proper CSLA registration</done>
</task>

<task type="auto">
  <name>Task 3: Add GetArchivedNpcsAsync to DAL</name>
  <files>
    Threa.Dal/ICharacterDal.cs
    Threa.Dal.MockDb/MockCharacterDal.cs
    Threa.Dal.Sqlite/SqliteCharacterDal.cs
  </files>
  <action>
1. In Threa.Dal/ICharacterDal.cs, add method signature:
```csharp
/// <summary>
/// Gets archived NPCs for the archive browser.
/// </summary>
Task<List<Character>> GetArchivedNpcsAsync();
```

2. In Threa.Dal.MockDb/MockCharacterDal.cs, implement:
```csharp
public Task<List<Character>> GetArchivedNpcsAsync()
{
    var archived = _characters.Values
        .Where(c => c.IsNpc && !c.IsTemplate && c.IsArchived)
        .ToList();
    return Task.FromResult(archived);
}
```

3. In Threa.Dal.Sqlite/SqliteCharacterDal.cs, implement using JSON storage pattern (similar to GetNpcTemplatesAsync):
```csharp
public async Task<List<Character>> GetArchivedNpcsAsync()
{
    var all = await GetAllCharactersAsync();
    return all.Where(c => c.IsNpc && !c.IsTemplate && c.IsArchived).ToList();
}
```

The Sqlite implementation loads all characters then filters in memory, matching the existing pattern for GetNpcTemplatesAsync. This is acceptable for small-to-medium datasets typical in TTRPG games.
  </action>
  <verify>Build solution: `dotnet build Threa.sln` - no errors. Both DAL implementations compile and match interface.</verify>
  <done>GetArchivedNpcsAsync method defined in interface and implemented in both MockDb and Sqlite DAL</done>
</task>

</tasks>

<verification>
1. Solution builds without errors
2. TableCharacterInfo has VisibleToPlayers property
3. Character DTO has IsArchived property
4. CharacterEdit has IsArchived CSLA property
5. ICharacterDal has GetArchivedNpcsAsync method
6. Both DAL implementations compile
</verification>

<success_criteria>
- `dotnet build Threa.sln` succeeds with no errors
- TableCharacterInfo.VisibleToPlayers is populated from Character.VisibleToPlayers in Fetch
- IsArchived property chain complete: DTO -> CharacterEdit -> DAL query
- DAL implementations return NPCs where IsNpc=true, IsTemplate=false, IsArchived=true
</success_criteria>

<output>
After completion, create `.planning/phases/26-visibility-lifecycle/26-01-SUMMARY.md`
</output>
