---
phase: 06-item-bonuses-and-combat
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - GameMechanics/Combat/WeaponSelector.cs
  - GameMechanics/Combat/EquipmentLocationMapper.cs
  - GameMechanics/Items/ArmorInfoFactory.cs
  - Threa/Threa.Client/Components/Pages/GamePlay/TabCombat.razor
  - Threa/Threa.Client/Components/Pages/GamePlay/AttackMode.razor
  - Threa/Threa.Client/Components/Pages/GamePlay/DamageResolution.razor
autonomous: false

must_haves:
  truths:
    - "Melee mode shows only melee weapons from equipped items"
    - "Ranged mode shows only ranged weapons from equipped items"
    - "Attack resolution uses equipped weapon's SV/AV modifiers"
    - "Damage resolution uses equipped armor for absorption"
    - "Armor covers correct hit locations based on equipment slot"
  artifacts:
    - path: "GameMechanics/Combat/WeaponSelector.cs"
      provides: "Filters weapons by melee/ranged mode"
      exports: ["GetMeleeWeapons", "GetRangedWeapons"]
    - path: "GameMechanics/Combat/EquipmentLocationMapper.cs"
      provides: "Maps EquipmentSlot to HitLocation coverage"
      exports: ["GetLocationsForSlot"]
    - path: "GameMechanics/Items/ArmorInfoFactory.cs"
      provides: "Creates ArmorInfo from EquippedItemInfo"
      exports: ["CreateArmorInfo"]
  key_links:
    - from: "TabCombat"
      to: "WeaponSelector.GetMeleeWeapons"
      via: "method call in LoadEquipmentAndSkills"
      pattern: "WeaponSelector.*GetMeleeWeapons"
    - from: "DamageResolution"
      to: "ArmorInfoFactory.CreateArmorInfo"
      via: "method call for armor lookup"
      pattern: "ArmorInfoFactory.*CreateArmorInfo"
---

<objective>
Integrate equipped weapons and armor into the combat system.

Purpose: Combat must use equipped weapon properties (damage class, SV/AV modifiers) and equipped armor for damage absorption. This connects inventory to the existing combat resolvers.

Output: WeaponSelector, EquipmentLocationMapper, ArmorInfoFactory, and updated combat UI components.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-item-bonuses-and-combat/06-CONTEXT.md
@.planning/phases/06-item-bonuses-and-combat/06-RESEARCH.md

# Depends on Plan 01 for EquippedItemInfo
@.planning/phases/06-item-bonuses-and-combat/06-01-SUMMARY.md

# Existing combat code to integrate with
@GameMechanics/Combat/ArmorInfo.cs
@GameMechanics/Combat/DamageResolver.cs
@GameMechanics/Combat/AttackResolver.cs
@Threa/Threa.Client/Components/Pages/GamePlay/TabCombat.razor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WeaponSelector and EquipmentLocationMapper</name>
  <files>
    GameMechanics/Combat/WeaponSelector.cs
    GameMechanics/Combat/EquipmentLocationMapper.cs
  </files>
  <action>
**WeaponSelector.cs:**
```csharp
using GameMechanics.Items;
using Threa.Dal.Dto;

namespace GameMechanics.Combat;

/// <summary>
/// Filters equipped weapons by combat mode (melee/ranged).
/// Per CONTEXT.md: "Combat mode automatically filters to show only equipped weapons valid for that mode"
/// </summary>
public static class WeaponSelector
{
    /// <summary>
    /// Gets melee weapons from equipped items.
    /// Melee = weapon in MainHand/OffHand/TwoHand with no Range property.
    /// </summary>
    public static IEnumerable<EquippedItemInfo> GetMeleeWeapons(
        IEnumerable<EquippedItemInfo> equippedItems)
    {
        return equippedItems.Where(i =>
            i.Template.ItemType == ItemType.Weapon &&
            IsWeaponSlot(i.Item.EquippedSlot) &&
            !i.Template.Range.HasValue);
    }

    /// <summary>
    /// Gets ranged weapons from equipped items.
    /// Ranged = weapon in MainHand/OffHand/TwoHand with Range property.
    /// </summary>
    public static IEnumerable<EquippedItemInfo> GetRangedWeapons(
        IEnumerable<EquippedItemInfo> equippedItems)
    {
        return equippedItems.Where(i =>
            i.Template.ItemType == ItemType.Weapon &&
            IsWeaponSlot(i.Item.EquippedSlot) &&
            i.Template.Range.HasValue);
    }

    private static bool IsWeaponSlot(EquipmentSlot slot) =>
        slot == EquipmentSlot.MainHand ||
        slot == EquipmentSlot.OffHand ||
        slot == EquipmentSlot.TwoHand;
}
```

**EquipmentLocationMapper.cs:**
```csharp
using Threa.Dal.Dto;

namespace GameMechanics.Combat;

/// <summary>
/// Maps equipment slots to the hit locations they cover.
/// Per COMBAT_SYSTEM.md: Different armor slots cover different body locations.
/// </summary>
public static class EquipmentLocationMapper
{
    private static readonly Dictionary<EquipmentSlot, HitLocation[]> _slotToLocations = new()
    {
        [EquipmentSlot.Head] = [HitLocation.Head],
        [EquipmentSlot.Face] = [HitLocation.Head],
        [EquipmentSlot.Ears] = [HitLocation.Head],
        [EquipmentSlot.Neck] = [HitLocation.Head, HitLocation.Torso],
        [EquipmentSlot.Shoulders] = [HitLocation.Torso, HitLocation.LeftArm, HitLocation.RightArm],
        [EquipmentSlot.Back] = [HitLocation.Torso],
        [EquipmentSlot.Chest] = [HitLocation.Torso],
        [EquipmentSlot.Waist] = [HitLocation.Torso, HitLocation.LeftLeg, HitLocation.RightLeg],
        [EquipmentSlot.ArmLeft] = [HitLocation.LeftArm],
        [EquipmentSlot.ArmRight] = [HitLocation.RightArm],
        [EquipmentSlot.WristLeft] = [HitLocation.LeftArm],
        [EquipmentSlot.WristRight] = [HitLocation.RightArm],
        [EquipmentSlot.HandLeft] = [HitLocation.LeftArm],
        [EquipmentSlot.HandRight] = [HitLocation.RightArm],
        [EquipmentSlot.Legs] = [HitLocation.LeftLeg, HitLocation.RightLeg],
        [EquipmentSlot.AnkleLeft] = [HitLocation.LeftLeg],
        [EquipmentSlot.AnkleRight] = [HitLocation.RightLeg],
        [EquipmentSlot.FootLeft] = [HitLocation.LeftLeg],
        [EquipmentSlot.FootRight] = [HitLocation.RightLeg]
    };

    /// <summary>
    /// Gets the hit locations covered by an equipment slot.
    /// </summary>
    public static HitLocation[] GetLocationsForSlot(EquipmentSlot slot)
    {
        return _slotToLocations.TryGetValue(slot, out var locations) ? locations : [];
    }

    /// <summary>
    /// Gets all equipment slots that cover a specific hit location.
    /// </summary>
    public static EquipmentSlot[] GetSlotsForLocation(HitLocation location)
    {
        return _slotToLocations
            .Where(kvp => kvp.Value.Contains(location))
            .Select(kvp => kvp.Key)
            .ToArray();
    }
}
```
  </action>
  <verify>
`dotnet build GameMechanics/GameMechanics.csproj` compiles without errors.
  </verify>
  <done>
WeaponSelector and EquipmentLocationMapper classes exist with static methods for filtering weapons and mapping armor coverage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ArmorInfoFactory</name>
  <files>GameMechanics/Items/ArmorInfoFactory.cs</files>
  <action>
Create factory to convert EquippedItemInfo to ArmorInfo for DamageResolver:

```csharp
using System.Text.Json;
using GameMechanics.Combat;
using Threa.Dal.Dto;

namespace GameMechanics.Items;

/// <summary>
/// Creates ArmorInfo objects from equipped armor items.
/// </summary>
public static class ArmorInfoFactory
{
    /// <summary>
    /// Creates an ArmorInfo from an equipped armor item.
    /// </summary>
    public static ArmorInfo CreateArmorInfo(EquippedItemInfo item)
    {
        // Parse ArmorAbsorption JSON
        var absorption = new Dictionary<DamageType, int>();
        if (!string.IsNullOrEmpty(item.Template.ArmorAbsorption))
        {
            try
            {
                // ArmorAbsorption is stored as JSON like: {"Cutting":5,"Piercing":3}
                var parsed = JsonSerializer.Deserialize<Dictionary<string, int>>(item.Template.ArmorAbsorption);
                if (parsed != null)
                {
                    foreach (var kvp in parsed)
                    {
                        if (Enum.TryParse<DamageType>(kvp.Key, true, out var damageType))
                        {
                            absorption[damageType] = kvp.Value;
                        }
                    }
                }
            }
            catch (JsonException)
            {
                // Invalid JSON - use empty absorption
            }
        }

        return new ArmorInfo
        {
            ItemId = item.Item.Id.ToString(),
            Name = item.Template.Name,
            CoveredLocations = EquipmentLocationMapper.GetLocationsForSlot(item.Item.EquippedSlot),
            DamageClass = item.Template.DamageClass,
            Absorption = absorption,
            CurrentDurability = item.Item.CurrentDurability ?? item.Template.MaxDurability ?? 100,
            MaxDurability = item.Template.MaxDurability ?? 100,
            LayerOrder = GetLayerOrder(item.Item.EquippedSlot)
        };
    }

    /// <summary>
    /// Gets all armor pieces from equipped items.
    /// </summary>
    public static List<ArmorInfo> GetArmorPieces(IEnumerable<EquippedItemInfo> equippedItems)
    {
        return equippedItems
            .Where(i => i.Template.ItemType == ItemType.Armor)
            .Select(CreateArmorInfo)
            .ToList();
    }

    /// <summary>
    /// Gets armor pieces that cover a specific hit location.
    /// </summary>
    public static List<ArmorInfo> GetArmorForLocation(
        IEnumerable<EquippedItemInfo> equippedItems,
        HitLocation location)
    {
        return equippedItems
            .Where(i => i.Template.ItemType == ItemType.Armor)
            .Where(i => EquipmentLocationMapper.GetLocationsForSlot(i.Item.EquippedSlot)
                .Contains(location))
            .Select(CreateArmorInfo)
            .OrderBy(a => a.LayerOrder)
            .ToList();
    }

    private static int GetLayerOrder(EquipmentSlot slot) => slot switch
    {
        // Outer layers (absorb first)
        EquipmentSlot.Back => 1,
        EquipmentSlot.Shoulders => 2,
        EquipmentSlot.Chest => 3,
        // Inner layers
        _ => 10
    };
}
```
  </action>
  <verify>
`dotnet build GameMechanics/GameMechanics.csproj` compiles without errors.
  </verify>
  <done>
ArmorInfoFactory exists with CreateArmorInfo, GetArmorPieces, and GetArmorForLocation methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update combat UI to use weapon/armor from equipped items</name>
  <files>
    Threa/Threa.Client/Components/Pages/GamePlay/TabCombat.razor
    Threa/Threa.Client/Components/Pages/GamePlay/AttackMode.razor
    Threa/Threa.Client/Components/Pages/GamePlay/DamageResolution.razor
  </files>
  <action>
**TabCombat.razor updates:**

1. Add using statements:
```csharp
@using GameMechanics.Items
```

2. Convert equipped items to EquippedItemInfo in LoadEquipmentAndSkills:
```csharp
// After loading equippedItems from DAL
var equippedItemInfos = equippedItems
    .Where(i => i.Template != null)
    .Select(i => new EquippedItemInfo { Item = i, Template = i.Template! })
    .ToList();
```

3. Update melee weapon detection using WeaponSelector:
```csharp
var meleeWeapons = WeaponSelector.GetMeleeWeapons(equippedItemInfos).ToList();
hasWeaponEquipped = meleeWeapons.Any();
```

4. Pass weapon info to AttackMode with SV/AV modifiers from template:
```csharp
// When creating attack, include weapon's modifiers
var selectedWeapon = meleeWeapons.FirstOrDefault();
var weaponAVModifier = selectedWeapon?.Template.AVModifier ?? 0;
var weaponSVModifier = selectedWeapon?.Template.SVModifier ?? 0;
var weaponDamageClass = selectedWeapon?.Template.DamageClass ?? 1;
```

**AttackMode.razor updates:**

1. Accept weapon properties as parameters:
```csharp
[Parameter] public int WeaponAVModifier { get; set; }
[Parameter] public int WeaponSVModifier { get; set; }
[Parameter] public int WeaponDamageClass { get; set; }
```

2. Apply weapon modifiers to attack:
```csharp
// In attack resolution
var attackAS = skill.AbilityScore + WeaponAVModifier;
// SVModifier is applied to final SV, not AS
```

**DamageResolution.razor updates:**

1. Add using statements and inject DAL if needed
2. Load armor from equipped items:
```csharp
var equippedItemInfos = EquippedItems
    .Where(i => i.Template != null)
    .Select(i => new EquippedItemInfo { Item = i, Template = i.Template! })
    .ToList();

var armorPieces = ArmorInfoFactory.GetArmorForLocation(equippedItemInfos, hitLocation);
```

3. Pass armor pieces to DamageResolver via DamageRequest.ArmorPieces

Per CONTEXT.md: "Combat results show detailed damage breakdown: '15 damage dealt -> 5 absorbed by armor -> 10 damage taken'"
  </action>
  <verify>
`dotnet build Threa.sln` compiles without errors.
  </verify>
  <done>
Combat UI uses WeaponSelector to filter weapons by mode, AttackMode uses weapon's AV/SV modifiers, DamageResolution uses ArmorInfoFactory for armor lookup.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Combat integration with equipped weapons and armor:
1. Melee mode shows only melee weapons
2. Attack uses weapon's AV/SV modifiers
3. Damage resolution uses equipped armor for absorption
  </what-built>
  <how-to-verify>
1. Run the app: `dotnet run --project Threa/Threa`
2. Navigate to Play page with a character who has equipped items
3. **Test weapon filtering:**
   - Equip a melee weapon (sword) and ranged weapon (bow)
   - Go to Combat tab, click Attack - should see melee weapon skill
   - Click Ranged Attack - should see ranged weapon
4. **Test attack modifiers:**
   - Select an attack skill
   - Verify the AS shown includes weapon's AV modifier
   - (May need to check item template for expected value)
5. **Test armor absorption:**
   - Have character take damage
   - Verify damage resolution shows armor absorption
   - Check that correct armor is used based on hit location
  </how-to-verify>
  <resume-signal>Type "approved" if combat integration works correctly, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` - Solution builds without errors
2. Manual test: Melee mode shows only melee weapons
3. Manual test: Ranged mode shows only ranged weapons
4. Manual test: Attack uses weapon's AV modifier
5. Manual test: Damage resolution uses equipped armor
6. Manual test: Armor coverage matches equipment slot
</verification>

<success_criteria>
- BONUS-07: Combat system uses equipped weapon properties (damage class, SV/AV modifiers) in attack resolution
- BONUS-08: Equipped armor provides absorption values for damage resolution
- BONUS-09: Equipped ranged weapons appear in ranged attack mode weapon selection
- BONUS-10: Equipped melee weapons appear in melee attack mode weapon selection
</success_criteria>

<output>
After completion, create `.planning/phases/06-item-bonuses-and-combat/06-03-SUMMARY.md`
</output>
