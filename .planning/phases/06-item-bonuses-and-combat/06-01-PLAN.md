---
phase: 06-item-bonuses-and-combat
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - GameMechanics/Items/ItemBonusCalculator.cs
  - GameMechanics/Items/EquippedItemInfo.cs
  - GameMechanics/Items/AttributeBonusBreakdown.cs
  - GameMechanics.Test/ItemBonusCalculatorTests.cs
autonomous: true

must_haves:
  truths:
    - "ItemBonusCalculator computes attribute bonuses from equipped items"
    - "ItemBonusCalculator computes skill bonuses from equipped items"
    - "Flat bonuses are summed additively"
    - "Percentage bonuses are ignored per CONTEXT.md"
    - "All equipped items contribute bonuses regardless of curse status"
  artifacts:
    - path: "GameMechanics/Items/ItemBonusCalculator.cs"
      provides: "Stateless calculator for item bonuses"
      exports: ["GetAttributeBonus", "GetSkillBonus", "GetAttributeBreakdown"]
    - path: "GameMechanics/Items/EquippedItemInfo.cs"
      provides: "Value object with CharacterItem + ItemTemplate"
      exports: ["EquippedItemInfo"]
    - path: "GameMechanics/Items/AttributeBonusBreakdown.cs"
      provides: "Breakdown showing base + item + effect"
      exports: ["AttributeBonusBreakdown"]
    - path: "GameMechanics.Test/ItemBonusCalculatorTests.cs"
      provides: "Unit tests for bonus calculation"
      min_lines: 80
  key_links:
    - from: "ItemBonusCalculator"
      to: "EquippedItemInfo.Template.AttributeModifiers"
      via: "LINQ Where filter"
      pattern: "AttributeModifiers.*Where"
    - from: "ItemBonusCalculator"
      to: "EquippedItemInfo.Template.SkillBonuses"
      via: "LINQ Where filter"
      pattern: "SkillBonuses.*Where"
---

<objective>
Create the ItemBonusCalculator service that computes bonuses from equipped items.

Purpose: This is the foundation for Phase 6 - all stat bonuses and combat integration depend on being able to calculate equipped item bonuses. Following the existing EffectCalculator pattern ensures consistency.

Output: ItemBonusCalculator.cs, EquippedItemInfo.cs, AttributeBonusBreakdown.cs, and unit tests.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-item-bonuses-and-combat/06-CONTEXT.md
@.planning/phases/06-item-bonuses-and-combat/06-RESEARCH.md

# Existing pattern to follow
@GameMechanics/Effects/EffectCalculator.cs

# DTOs with bonus structures
@Threa.Dal/Dto/ItemTemplate.cs
@Threa.Dal/Dto/ItemSkillBonus.cs
@Threa.Dal/Dto/ItemAttributeModifier.cs
@Threa.Dal/Dto/BonusType.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EquippedItemInfo and AttributeBonusBreakdown classes</name>
  <files>
    GameMechanics/Items/EquippedItemInfo.cs
    GameMechanics/Items/AttributeBonusBreakdown.cs
  </files>
  <action>
Create value objects to support bonus calculation:

**EquippedItemInfo.cs:**
- Record or class with `CharacterItem Item` and `ItemTemplate Template` properties
- Convenience bool properties: `IsWeapon`, `IsArmor`, `IsMelee`, `IsRanged`
- IsMelee = ItemType.Weapon AND Range is null
- IsRanged = ItemType.Weapon AND Range.HasValue

**AttributeBonusBreakdown.cs:**
- Class with properties: `string AttributeName`, `int BaseValue`, `int ItemBonus`, `int EffectBonus`
- Computed `Total` property = BaseValue + ItemBonus + EffectBonus
- `FormattedString` property returns: "{Name} {Total} ({BaseValue} base{+ ItemBonus items}{+ EffectBonus effects})"
  - Only show non-zero components
  - Example: "STR 12 (10 base + 2 items)" or "DEX 8 (10 base - 2 effects)"

Place in GameMechanics/Items/ folder (create if needed).
  </action>
  <verify>
`dotnet build GameMechanics/GameMechanics.csproj` compiles without errors.
  </verify>
  <done>
EquippedItemInfo and AttributeBonusBreakdown classes exist with all specified properties and computed values.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ItemBonusCalculator service</name>
  <files>GameMechanics/Items/ItemBonusCalculator.cs</files>
  <action>
Create stateless calculator following EffectCalculator pattern:

**Class structure:**
```csharp
public class ItemBonusCalculator
{
    /// <summary>
    /// Calculates total attribute modifier from equipped items.
    /// Per CONTEXT.md: Flat bonuses only, all bonuses stack additively.
    /// </summary>
    public int GetAttributeBonus(
        IEnumerable<EquippedItemInfo> equippedItems,
        string attributeName)

    /// <summary>
    /// Calculates total skill bonus from equipped items.
    /// Per CONTEXT.md: Flat bonuses only, all bonuses stack additively.
    /// </summary>
    public int GetSkillBonus(
        IEnumerable<EquippedItemInfo> equippedItems,
        string skillName)

    /// <summary>
    /// Gets itemized breakdown of attribute bonuses from each item.
    /// </summary>
    public List<(string ItemName, int Bonus)> GetAttributeBonusBreakdown(
        IEnumerable<EquippedItemInfo> equippedItems,
        string attributeName)

    /// <summary>
    /// Gets itemized breakdown of skill bonuses from each item.
    /// </summary>
    public List<(string ItemName, int Bonus)> GetSkillBonusBreakdown(
        IEnumerable<EquippedItemInfo> equippedItems,
        string skillName)
}
```

**Implementation rules:**
1. Filter Template.AttributeModifiers/SkillBonuses by name (case-insensitive)
2. Only include FlatBonus type (BonusType.FlatBonus == 0)
3. Skip PercentageBonus per CONTEXT.md decision
4. Sum all matching bonuses (positive and negative algebraically)
5. Include ALL equipped items regardless of curse status
6. Handle null Template gracefully (skip item)
7. Handle empty collections (return 0)
  </action>
  <verify>
`dotnet build GameMechanics/GameMechanics.csproj` compiles without errors.
  </verify>
  <done>
ItemBonusCalculator class exists with GetAttributeBonus, GetSkillBonus, and breakdown methods that correctly sum flat bonuses.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for ItemBonusCalculator</name>
  <files>GameMechanics.Test/ItemBonusCalculatorTests.cs</files>
  <action>
Create unit tests following existing test patterns (see ItemTemplateTests.cs):

**Test cases:**

1. `GetAttributeBonus_NoItems_ReturnsZero` - Empty collection returns 0
2. `GetAttributeBonus_SingleItemWithBonus_ReturnsBonus` - One item with +2 STR returns 2
3. `GetAttributeBonus_MultipleItems_SumsAdditively` - Two items with +2 STR each returns 4
4. `GetAttributeBonus_MixedPositiveNegative_SumsAlgebraically` - +3 and -1 returns 2
5. `GetAttributeBonus_PercentageBonus_IsIgnored` - Item with PercentageBonus type is skipped
6. `GetAttributeBonus_WrongAttribute_ReturnsZero` - STR bonus doesn't affect DEX query
7. `GetAttributeBonus_CaseInsensitive` - "str" matches "STR" bonus

8. `GetSkillBonus_NoItems_ReturnsZero`
9. `GetSkillBonus_SingleItemWithBonus_ReturnsBonus`
10. `GetSkillBonus_MultipleItems_SumsAdditively`

11. `GetAttributeBonusBreakdown_ReturnsPerItemBreakdown` - Returns list of (ItemName, Bonus) tuples

**Test setup pattern:**
- Create mock EquippedItemInfo objects with manually constructed ItemTemplate objects
- Set Template.AttributeModifiers and Template.SkillBonuses lists directly
- No DAL injection needed (pure calculation tests)
  </action>
  <verify>
`dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "FullyQualifiedName~ItemBonusCalculator"` - All tests pass.
  </verify>
  <done>
At least 11 unit tests pass covering attribute bonuses, skill bonuses, stacking, percentage filtering, and breakdown methods.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` - Solution builds without errors
2. `dotnet test GameMechanics.Test/GameMechanics.Test.csproj --filter "ItemBonusCalculator"` - All tests pass
3. Code review: ItemBonusCalculator follows EffectCalculator pattern (stateless, no dependencies)
</verification>

<success_criteria>
- ItemBonusCalculator computes flat attribute bonuses from equipped items correctly
- ItemBonusCalculator computes flat skill bonuses from equipped items correctly
- Percentage bonuses are ignored per CONTEXT.md
- Multiple bonuses stack additively (no caps)
- Cursed items still contribute bonuses
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-item-bonuses-and-combat/06-01-SUMMARY.md`
</output>
