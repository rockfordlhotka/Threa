---
phase: 06-item-bonuses-and-combat
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - GameMechanics/CharacterEdit.cs
  - Threa.Dal/ICharacterItemDal.cs
  - Threa.Dal.MockDb/MockCharacterItemDal.cs
  - Threa.Dal.Sqlite/CharacterItemDal.cs
  - Threa/Threa.Client/Components/Pages/GamePlay/Play.razor
  - Threa/Threa.Client/Components/Pages/GamePlay/TabStatus.razor
autonomous: true

must_haves:
  truths:
    - "Equipped items with attribute bonuses increase character stats in the UI"
    - "Equipped items with skill bonuses increase skill Ability Scores"
    - "Stat display shows breakdown with base value and item bonus components"
    - "Positive bonuses display in green, negative bonuses display in red"
    - "Unequipping an item removes its bonuses from all stat displays"
  artifacts:
    - path: "GameMechanics/CharacterEdit.cs"
      provides: "GetEffectiveAttribute with item bonuses, GetAttributeBreakdown, GetSkillBonus methods"
      contains: "ItemBonusCalculator"
    - path: "Threa.Dal/ICharacterItemDal.cs"
      provides: "GetEquippedItemsWithTemplatesAsync method"
      exports: ["GetEquippedItemsWithTemplatesAsync"]
    - path: "Threa/Threa.Client/Components/Pages/GamePlay/TabStatus.razor"
      provides: "Stat display with inline breakdown"
      contains: "AttributeBonusBreakdown"
  key_links:
    - from: "CharacterEdit.GetEffectiveAttribute"
      to: "ItemBonusCalculator.GetAttributeBonus"
      via: "method call"
      pattern: "ItemBonusCalculator.*GetAttributeBonus"
    - from: "CharacterEdit"
      to: "ItemBonusCalculator.GetSkillBonus"
      via: "method call for Ability Score"
      pattern: "ItemBonusCalculator.*GetSkillBonus"
    - from: "Play.razor"
      to: "CharacterEdit.SetEquippedItems"
      via: "call after character fetch"
      pattern: "SetEquippedItems"
    - from: "TabStatus"
      to: "GetAttributeBreakdown"
      via: "component call"
      pattern: "GetAttributeBreakdown"
---

<objective>
Integrate ItemBonusCalculator into CharacterEdit and update UI to show stat breakdowns.

Purpose: Players need to see how their equipped items affect their stats. This connects the bonus calculator to the character model and provides visual feedback per CONTEXT.md decisions.

Output: Modified CharacterEdit with item bonus integration, DAL method for equipped items with templates, and updated Play page stats display.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-item-bonuses-and-combat/06-CONTEXT.md
@.planning/phases/06-item-bonuses-and-combat/06-RESEARCH.md

# Depends on Plan 01 output
@.planning/phases/06-item-bonuses-and-combat/06-01-SUMMARY.md

# Files to modify
@GameMechanics/CharacterEdit.cs
@Threa.Dal/ICharacterItemDal.cs
@Threa/Threa.Client/Components/Pages/GamePlay/Play.razor
@Threa/Threa.Client/Components/Pages/GamePlay/TabStatus.razor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GetEquippedItemsWithTemplatesAsync to DAL</name>
  <files>
    Threa.Dal/ICharacterItemDal.cs
    Threa.Dal.MockDb/MockCharacterItemDal.cs
    Threa.Dal.Sqlite/CharacterItemDal.cs
  </files>
  <action>
Add DAL method that returns equipped items with their templates loaded:

**ICharacterItemDal.cs - Add method:**
```csharp
/// <summary>
/// Gets equipped items for a character with their templates populated.
/// </summary>
Task<List<CharacterItem>> GetEquippedItemsWithTemplatesAsync(int characterId);
```

**MockCharacterItemDal.cs - Implement:**
```csharp
public async Task<List<CharacterItem>> GetEquippedItemsWithTemplatesAsync(int characterId)
{
    var items = await GetEquippedItemsAsync(characterId);
    foreach (var item in items)
    {
        if (item.Template == null)
        {
            item.Template = _templates.FirstOrDefault(t => t.Id == item.TemplateId);
        }
    }
    return items;
}
```

**CharacterItemDal.cs (Sqlite) - Implement:**
Similar pattern - fetch equipped items, then load templates for each.
Use existing GetItemTemplateAsync or batch load templates.
  </action>
  <verify>
`dotnet build Threa.sln` compiles without errors.
  </verify>
  <done>
GetEquippedItemsWithTemplatesAsync exists in interface and both DAL implementations, returns items with Template property populated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ItemBonusCalculator into CharacterEdit</name>
  <files>GameMechanics/CharacterEdit.cs</files>
  <action>
Modify CharacterEdit to include item bonuses in stat calculations:

**Add using statement:**
```csharp
using GameMechanics.Items;
```

**Add static calculator instance:**
```csharp
private static readonly ItemBonusCalculator _itemBonusCalculator = new();
```

**Add equipped items property (loaded separately, not CSLA-managed):**
```csharp
// Non-CSLA property for equipped items (loaded on demand for calculations)
private List<EquippedItemInfo>? _equippedItems;

/// <summary>
/// Sets equipped items for bonus calculations. Call this after fetching character.
/// </summary>
public void SetEquippedItems(IEnumerable<CharacterItem> items)
{
    _equippedItems = items
        .Where(i => i.Template != null)
        .Select(i => new EquippedItemInfo { Item = i, Template = i.Template! })
        .ToList();
}
```

**Modify GetEffectiveAttribute to include item bonuses:**
```csharp
public int GetEffectiveAttribute(string attributeName)
{
    var baseValue = GetAttribute(attributeName);

    // Layer 1: Item bonuses (per CONTEXT.md layered calculation)
    var itemBonus = _equippedItems != null
        ? _itemBonusCalculator.GetAttributeBonus(_equippedItems, attributeName)
        : 0;

    // Layer 2: Effect modifiers (existing)
    var effectModifier = Effects.GetAttributeModifier(attributeName, baseValue + itemBonus);

    return baseValue + itemBonus + effectModifier;
}
```

**Add breakdown method for attributes:**
```csharp
/// <summary>
/// Gets detailed breakdown of attribute value including item bonuses.
/// </summary>
public AttributeBonusBreakdown GetAttributeBreakdown(string attributeName)
{
    var baseValue = GetAttribute(attributeName);
    var itemBonus = _equippedItems != null
        ? _itemBonusCalculator.GetAttributeBonus(_equippedItems, attributeName)
        : 0;
    var effectBonus = Effects.GetAttributeModifier(attributeName, baseValue + itemBonus);

    return new AttributeBonusBreakdown
    {
        AttributeName = attributeName,
        BaseValue = baseValue,
        ItemBonus = itemBonus,
        EffectBonus = effectBonus
    };
}

/// <summary>
/// Gets detailed breakdown of item bonuses for an attribute.
/// </summary>
public List<(string ItemName, int Bonus)> GetAttributeItemBreakdown(string attributeName)
{
    return _equippedItems != null
        ? _itemBonusCalculator.GetAttributeBonusBreakdown(_equippedItems, attributeName)
        : new List<(string, int)>();
}
```

**Add skill bonus method for Ability Score calculations (BONUS-01 requirement):**
```csharp
/// <summary>
/// Gets the item skill bonus for a specific skill.
/// Used when calculating Ability Scores: AS = Attribute + SkillLevel + ItemSkillBonus - 5 + Modifiers
/// </summary>
public int GetSkillItemBonus(string skillName)
{
    return _equippedItems != null
        ? _itemBonusCalculator.GetSkillBonus(_equippedItems, skillName)
        : 0;
}

/// <summary>
/// Gets detailed breakdown of skill bonuses from each equipped item.
/// </summary>
public List<(string ItemName, int Bonus)> GetSkillItemBreakdown(string skillName)
{
    return _equippedItems != null
        ? _itemBonusCalculator.GetSkillBonusBreakdown(_equippedItems, skillName)
        : new List<(string, int)>();
}
```

**Note on Ability Score integration:**
The GetSkillItemBonus method provides skill bonuses from items. The ActionResolver or SkillEdit.AbilityScore property should use this when calculating final AS. The existing AbilityScore calculation in GameMechanics/Actions/AbilityScore.cs uses:
- `BaseAS = AttributeValue + SkillLevel + StandardOffset`

Item skill bonuses should be added as modifiers. The ActionResolver.BuildAbilityScore can call character.GetSkillItemBonus(skillName) and add it to the AbilityScore.Modifiers stack, similar to how wound penalties are added.
  </action>
  <verify>
`dotnet build GameMechanics/GameMechanics.csproj` compiles without errors.
  </verify>
  <done>
CharacterEdit.GetEffectiveAttribute includes item bonuses, GetAttributeBreakdown method exists, GetSkillItemBonus and GetSkillItemBreakdown methods exist for skill bonus integration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Play page to load equipped items and display stat breakdowns</name>
  <files>
    Threa/Threa.Client/Components/Pages/GamePlay/Play.razor
    Threa/Threa.Client/Components/Pages/GamePlay/TabStatus.razor
  </files>
  <action>
**Part A: Play.razor - Load equipped items after character fetch**

1. Add inject for ICharacterItemDal at the top with other @inject statements:
```razor
@inject ICharacterItemDal CharacterItemDal
```

2. Create a helper method to load and set equipped items:
```csharp
private async Task LoadEquippedItemsAsync()
{
    if (character == null) return;
    var equippedItems = await CharacterItemDal.GetEquippedItemsWithTemplatesAsync(character.Id);
    character.SetEquippedItems(equippedItems);
}
```

3. Call LoadEquippedItemsAsync in THREE locations where character is loaded:

**Location 1 - SelectCharacterAsync method (around line 523):**
After `character = await characterPortal.FetchAsync(characterId);` add:
```csharp
character = await characterPortal.FetchAsync(characterId);
await LoadEquippedItemsAsync(); // <-- Add this line
```

**Location 2 - PlayWithoutTable method (around line 851):**
After `character = await characterPortal.FetchAsync(characterToAttach.Id);` add:
```csharp
character = await characterPortal.FetchAsync(characterToAttach.Id);
await LoadEquippedItemsAsync(); // <-- Add this line
```

**Location 3 - ConfirmTableSelection method (around line 880):**
After `character = await characterPortal.FetchAsync(characterToAttach.Id);` add:
```csharp
character = await characterPortal.FetchAsync(characterToAttach.Id);
await LoadEquippedItemsAsync(); // <-- Add this line
```

**Part B: TabStatus.razor - Display attribute breakdown**

Add an Attributes section to show stats with item bonus breakdown. Insert after the "Quick Status" card (around line 91):

```razor
<!-- Attributes with Item Bonuses -->
<div class="card mt-3">
    <div class="card-header">
        <strong><i class="bi bi-bar-chart"></i> Attributes</strong>
    </div>
    <div class="card-body">
        @foreach (var attr in Character?.AttributeList ?? Enumerable.Empty<GameMechanics.AttributeEdit>())
        {
            var breakdown = Character?.GetAttributeBreakdown(attr.Name);
            if (breakdown != null)
            {
                <div class="d-flex justify-content-between align-items-center py-1 border-bottom">
                    <span class="fw-bold">@attr.Name</span>
                    <div class="d-flex align-items-center gap-2">
                        <span class="@GetTotalBonusClass(breakdown)" style="font-size: 1.1rem;">
                            @breakdown.Total
                        </span>
                        <small class="text-muted">
                            (@breakdown.BaseValue base
                            @if (breakdown.ItemBonus != 0)
                            {
                                <span class="@(breakdown.ItemBonus > 0 ? "text-success" : "text-danger")">
                                    @(breakdown.ItemBonus > 0 ? "+" : "")@breakdown.ItemBonus items
                                </span>
                            }
                            @if (breakdown.EffectBonus != 0)
                            {
                                <span class="@(breakdown.EffectBonus > 0 ? "text-success" : "text-danger")">
                                    @(breakdown.EffectBonus > 0 ? "+" : "")@breakdown.EffectBonus effects
                                </span>
                            })
                        </small>
                    </div>
                </div>
            }
        }
    </div>
</div>
```

Add the helper method to the @code block:
```csharp
private string GetTotalBonusClass(GameMechanics.Items.AttributeBonusBreakdown breakdown)
{
    var totalBonus = breakdown.ItemBonus + breakdown.EffectBonus;
    if (totalBonus > 0) return "text-success";
    if (totalBonus < 0) return "text-danger";
    return "";
}
```

Add using statement at top of file:
```razor
@using GameMechanics.Items
```
  </action>
  <verify>
1. `dotnet build Threa.sln` compiles without errors.
2. Run the app and navigate to Play page - select a character
3. Check TabStatus tab - attributes should show breakdown with base value
4. If character has equipped items with attribute modifiers, bonuses should display in green (positive) or red (negative)
5. Verify code exists: grep for "LoadEquippedItemsAsync" in Play.razor - should find 4 occurrences (1 definition + 3 calls)
  </verify>
  <done>
Play page loads equipped items and calls SetEquippedItems on character in all three character-loading paths. TabStatus shows attribute breakdown with color-coded item and effect bonuses.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` - Solution builds without errors
2. Manual test: Equip an item with attribute modifier, verify stat display shows bonus
3. Manual test: Unequip item, verify bonus disappears from display
4. Manual test: Equip item with negative modifier, verify shows in red
5. Code verification: grep "SetEquippedItems" in Play.razor returns matches
6. Code verification: grep "GetSkillItemBonus" in CharacterEdit.cs returns match
</verification>

<success_criteria>
- BONUS-01: Equipped items with skill bonuses increase character Ability Scores (GetSkillItemBonus method available)
- BONUS-02: Equipped items with attribute modifiers increase base attributes
- BONUS-03: Attribute modifiers cascade to all skills using that attribute (via GetEffectiveAttribute)
- BONUS-04: Multiple items with same skill bonus stack additively
- BONUS-05: Multiple items with same attribute modifier stack additively
- BONUS-06: When item is unequipped, bonuses are removed from character calculations
- UI shows inline stat breakdown per CONTEXT.md decision
</success_criteria>

<output>
After completion, create `.planning/phases/06-item-bonuses-and-combat/06-02-SUMMARY.md`
</output>
