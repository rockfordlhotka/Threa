---
phase: 06-item-bonuses-and-combat
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - GameMechanics/CharacterEdit.cs
  - Threa.Dal/ICharacterItemDal.cs
  - Threa.Dal.MockDb/MockCharacterItemDal.cs
  - Threa.Dal.Sqlite/CharacterItemDal.cs
  - Threa/Threa.Client/Components/Pages/GamePlay/TabPlayStats.razor
autonomous: true

must_haves:
  truths:
    - "CharacterEdit.GetEffectiveAttribute includes item bonuses"
    - "CharacterEdit.GetAttributeBreakdown returns base/item/effect values"
    - "UI displays stat breakdown with item bonus component"
    - "Positive bonuses show in green, negative in red"
    - "Unequipping removes bonuses from calculations"
  artifacts:
    - path: "GameMechanics/CharacterEdit.cs"
      provides: "GetEffectiveAttribute with item bonuses, GetAttributeBreakdown method"
      contains: "ItemBonusCalculator"
    - path: "Threa.Dal/ICharacterItemDal.cs"
      provides: "GetEquippedItemsWithTemplatesAsync method"
      exports: ["GetEquippedItemsWithTemplatesAsync"]
    - path: "Threa/Threa.Client/Components/Pages/GamePlay/TabPlayStats.razor"
      provides: "Stat display with inline breakdown"
      contains: "AttributeBonusBreakdown"
  key_links:
    - from: "CharacterEdit.GetEffectiveAttribute"
      to: "ItemBonusCalculator.GetAttributeBonus"
      via: "method call"
      pattern: "ItemBonusCalculator.*GetAttributeBonus"
    - from: "TabPlayStats"
      to: "GetAttributeBreakdown"
      via: "component call"
      pattern: "GetAttributeBreakdown"
---

<objective>
Integrate ItemBonusCalculator into CharacterEdit and update UI to show stat breakdowns.

Purpose: Players need to see how their equipped items affect their stats. This connects the bonus calculator to the character model and provides visual feedback per CONTEXT.md decisions.

Output: Modified CharacterEdit with item bonus integration, DAL method for equipped items with templates, and updated Play page stats display.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-item-bonuses-and-combat/06-CONTEXT.md
@.planning/phases/06-item-bonuses-and-combat/06-RESEARCH.md

# Depends on Plan 01 output
@.planning/phases/06-item-bonuses-and-combat/06-01-SUMMARY.md

# Files to modify
@GameMechanics/CharacterEdit.cs
@Threa.Dal/ICharacterItemDal.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GetEquippedItemsWithTemplatesAsync to DAL</name>
  <files>
    Threa.Dal/ICharacterItemDal.cs
    Threa.Dal.MockDb/MockCharacterItemDal.cs
    Threa.Dal.Sqlite/CharacterItemDal.cs
  </files>
  <action>
Add DAL method that returns equipped items with their templates loaded:

**ICharacterItemDal.cs - Add method:**
```csharp
/// <summary>
/// Gets equipped items for a character with their templates populated.
/// </summary>
Task<List<CharacterItem>> GetEquippedItemsWithTemplatesAsync(int characterId);
```

**MockCharacterItemDal.cs - Implement:**
```csharp
public async Task<List<CharacterItem>> GetEquippedItemsWithTemplatesAsync(int characterId)
{
    var items = await GetEquippedItemsAsync(characterId);
    foreach (var item in items)
    {
        if (item.Template == null)
        {
            item.Template = _templates.FirstOrDefault(t => t.Id == item.TemplateId);
        }
    }
    return items;
}
```

**CharacterItemDal.cs (Sqlite) - Implement:**
Similar pattern - fetch equipped items, then load templates for each.
Use existing GetItemTemplateAsync or batch load templates.
  </action>
  <verify>
`dotnet build Threa.sln` compiles without errors.
  </verify>
  <done>
GetEquippedItemsWithTemplatesAsync exists in interface and both DAL implementations, returns items with Template property populated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ItemBonusCalculator into CharacterEdit</name>
  <files>GameMechanics/CharacterEdit.cs</files>
  <action>
Modify CharacterEdit to include item bonuses in stat calculations:

**Add using statement:**
```csharp
using GameMechanics.Items;
```

**Add static calculator instance:**
```csharp
private static readonly ItemBonusCalculator _itemBonusCalculator = new();
```

**Add equipped items property (loaded separately, not CSLA-managed):**
```csharp
// Non-CSLA property for equipped items (loaded on demand for calculations)
private List<EquippedItemInfo>? _equippedItems;

/// <summary>
/// Sets equipped items for bonus calculations. Call this after fetching character.
/// </summary>
public void SetEquippedItems(IEnumerable<CharacterItem> items)
{
    _equippedItems = items
        .Where(i => i.Template != null)
        .Select(i => new EquippedItemInfo { Item = i, Template = i.Template! })
        .ToList();
}
```

**Modify GetEffectiveAttribute:**
```csharp
public int GetEffectiveAttribute(string attributeName)
{
    var baseValue = GetAttribute(attributeName);

    // Layer 1: Item bonuses (per CONTEXT.md layered calculation)
    var itemBonus = _equippedItems != null
        ? _itemBonusCalculator.GetAttributeBonus(_equippedItems, attributeName)
        : 0;

    // Layer 2: Effect modifiers (existing)
    var effectModifier = Effects.GetAttributeModifier(attributeName, baseValue + itemBonus);

    return baseValue + itemBonus + effectModifier;
}
```

**Add breakdown method:**
```csharp
/// <summary>
/// Gets detailed breakdown of attribute value including item bonuses.
/// </summary>
public AttributeBonusBreakdown GetAttributeBreakdown(string attributeName)
{
    var baseValue = GetAttribute(attributeName);
    var itemBonus = _equippedItems != null
        ? _itemBonusCalculator.GetAttributeBonus(_equippedItems, attributeName)
        : 0;
    var effectBonus = Effects.GetAttributeModifier(attributeName, baseValue + itemBonus);

    return new AttributeBonusBreakdown
    {
        AttributeName = attributeName,
        BaseValue = baseValue,
        ItemBonus = itemBonus,
        EffectBonus = effectBonus
    };
}

/// <summary>
/// Gets detailed breakdown of item bonuses for an attribute.
/// </summary>
public List<(string ItemName, int Bonus)> GetAttributeItemBreakdown(string attributeName)
{
    return _equippedItems != null
        ? _itemBonusCalculator.GetAttributeBonusBreakdown(_equippedItems, attributeName)
        : new List<(string, int)>();
}
```
  </action>
  <verify>
`dotnet build GameMechanics/GameMechanics.csproj` compiles without errors.
  </verify>
  <done>
CharacterEdit.GetEffectiveAttribute includes item bonuses, GetAttributeBreakdown and GetAttributeItemBreakdown methods exist.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Play page stats display with bonus breakdown</name>
  <files>Threa/Threa.Client/Components/Pages/GamePlay/TabPlayStats.razor</files>
  <action>
Update or create TabPlayStats component to show attribute breakdown:

**First check if component exists.** If not, look for where attributes are displayed on Play page and modify that.

**Display pattern per CONTEXT.md:**
```razor
@foreach (var attr in AttributeList)
{
    var breakdown = Character.GetAttributeBreakdown(attr.Name);
    <div class="stat-row">
        <span class="stat-name">@attr.Name</span>
        <span class="stat-value @GetBonusClass(breakdown)">
            @breakdown.Total
        </span>
        <small class="stat-breakdown text-muted">
            (@breakdown.BaseValue base
            @if (breakdown.ItemBonus != 0)
            {
                <span class="@(breakdown.ItemBonus > 0 ? "text-success" : "text-danger")">
                    @(breakdown.ItemBonus > 0 ? "+" : "")@breakdown.ItemBonus items
                </span>
            }
            @if (breakdown.EffectBonus != 0)
            {
                <span class="@(breakdown.EffectBonus > 0 ? "text-success" : "text-danger")">
                    @(breakdown.EffectBonus > 0 ? "+" : "")@breakdown.EffectBonus effects
                </span>
            })
        </small>
    </div>
}

@code {
    private string GetBonusClass(AttributeBonusBreakdown breakdown)
    {
        var totalBonus = breakdown.ItemBonus + breakdown.EffectBonus;
        if (totalBonus > 0) return "text-success";
        if (totalBonus < 0) return "text-danger";
        return "";
    }
}
```

**Load equipped items when character loads:**
Ensure the Play page calls `Character.SetEquippedItems()` after fetching equipped items via DAL.

**Look for existing OnInitializedAsync or OnParametersSetAsync** and add:
```csharp
var equippedItems = await CharacterItemDal.GetEquippedItemsWithTemplatesAsync(Character.Id);
Character.SetEquippedItems(equippedItems);
```
  </action>
  <verify>
`dotnet build Threa.sln` compiles without errors. Run the app and navigate to Play page - attributes should show breakdown.
  </verify>
  <done>
Play page attribute display shows inline breakdown with base value, item bonuses (green if positive, red if negative), and effect bonuses.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` - Solution builds without errors
2. Manual test: Equip an item with attribute modifier, verify stat display shows bonus
3. Manual test: Unequip item, verify bonus disappears from display
4. Manual test: Equip item with negative modifier, verify shows in red
</verification>

<success_criteria>
- BONUS-01: Equipped items with skill bonuses increase character Ability Scores
- BONUS-02: Equipped items with attribute modifiers increase base attributes
- BONUS-03: Attribute modifiers cascade to all skills using that attribute (via GetEffectiveAttribute)
- BONUS-04: Multiple items with same skill bonus stack additively
- BONUS-05: Multiple items with same attribute modifier stack additively
- BONUS-06: When item is unequipped, bonuses are removed from character calculations
- UI shows inline stat breakdown per CONTEXT.md decision
</success_criteria>

<output>
After completion, create `.planning/phases/06-item-bonuses-and-combat/06-02-SUMMARY.md`
</output>
