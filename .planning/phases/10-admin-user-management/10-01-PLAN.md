---
phase: 10-admin-user-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Threa.Dal/IPlayerDal.cs
  - Threa.Dal.MockDb/PlayerDal.cs
  - Threa.Dal.Sqlite/PlayerDal.cs
  - GameMechanics/Player/AdminUserEdit.cs
  - GameMechanics.Test/AdminUserEditTests.cs
autonomous: true

must_haves:
  truths:
    - "System can count enabled administrators in database"
    - "Disabling or demoting the last enabled admin is blocked with error"
    - "Non-last admins can be disabled or demoted without error"
  artifacts:
    - path: "Threa.Dal/IPlayerDal.cs"
      provides: "CountEnabledAdminsAsync method signature"
      contains: "CountEnabledAdminsAsync"
    - path: "Threa.Dal.MockDb/PlayerDal.cs"
      provides: "MockDb implementation of CountEnabledAdminsAsync"
      contains: "CountEnabledAdminsAsync"
    - path: "GameMechanics/Player/AdminUserEdit.cs"
      provides: "LastAdminProtectionRule business rule"
      contains: "LastAdminProtectionRule"
    - path: "GameMechanics.Test/AdminUserEditTests.cs"
      provides: "Unit tests for last-admin protection"
      min_lines: 40
  key_links:
    - from: "GameMechanics/Player/AdminUserEdit.cs"
      to: "IPlayerDal.CountEnabledAdminsAsync"
      via: "Business rule async validation"
      pattern: "CountEnabledAdminsAsync"
---

<objective>
Add last-admin protection to AdminUserEdit business object.

Purpose: Prevent administrators from accidentally leaving the system without any enabled admin, which would lock out all admin functionality.

Output: DAL method for counting enabled admins, CSLA async business rule that blocks save when last admin would be disabled/demoted, and unit tests proving protection works.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-admin-user-management/10-CONTEXT.md
@.planning/phases/10-admin-user-management/10-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CountEnabledAdminsAsync to DAL</name>
  <files>
    Threa.Dal/IPlayerDal.cs
    Threa.Dal.MockDb/PlayerDal.cs
    Threa.Dal.Sqlite/PlayerDal.cs
  </files>
  <action>
Add `CountEnabledAdminsAsync()` method to IPlayerDal interface and both implementations.

**IPlayerDal.cs:**
Add method signature:
```csharp
/// <summary>
/// Counts enabled users with Administrator role.
/// Used by last-admin protection rule.
/// </summary>
Task<int> CountEnabledAdminsAsync();
```

**MockDb/PlayerDal.cs:**
Add implementation:
```csharp
public Task<int> CountEnabledAdminsAsync()
{
    lock (MockDb.Players)
    {
        var count = MockDb.Players.Count(p =>
            p.IsEnabled &&
            p.Roles != null &&
            p.Roles.Split(',', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries)
                .Contains(GameMechanics.Player.Roles.Administrator, StringComparer.OrdinalIgnoreCase));
        return Task.FromResult(count);
    }
}
```

**Sqlite/PlayerDal.cs:**
Add implementation - query database counting users where IsEnabled=true AND Roles contains "Administrator". Use SQL pattern matching or fetch and filter in C# (consistent with existing PlayerDal patterns in that file).
  </action>
  <verify>
Build succeeds: `dotnet build Threa.sln`
  </verify>
  <done>
CountEnabledAdminsAsync exists in IPlayerDal and both implementations compile successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add LastAdminProtectionRule to AdminUserEdit</name>
  <files>
    GameMechanics/Player/AdminUserEdit.cs
    GameMechanics.Test/AdminUserEditTests.cs
  </files>
  <action>
Add async business rule to AdminUserEdit that prevents disabling or demoting the last enabled admin.

**AdminUserEdit.cs changes:**

1. Add using statements if needed:
```csharp
using Csla.Rules;
```

2. Add nested rule class inside AdminUserEdit (or as separate file if preferred):
```csharp
/// <summary>
/// Validates that disabling user or removing Admin role doesn't leave system without admins.
/// </summary>
private class LastAdminProtectionRule : BusinessRuleAsync
{
    public LastAdminProtectionRule(IPropertyInfo primaryProperty)
        : base(primaryProperty)
    {
        InputProperties.Add(IsEnabledProperty);
        InputProperties.Add(IsAdministratorProperty);
        IsAsync = true;
        ProvideTargetWhenAsync = true;
    }

    protected override async Task ExecuteAsync(IRuleContext context)
    {
        var target = (AdminUserEdit)context.Target!;
        var isEnabled = (bool)context.InputPropertyValues[IsEnabledProperty]!;
        var isAdmin = (bool)context.InputPropertyValues[IsAdministratorProperty]!;

        // Only check if this change would remove an enabled admin
        if (!isEnabled || !isAdmin)
        {
            var dal = ApplicationContext.CreateInstanceDI<IPlayerDal>();
            var enabledAdminCount = await dal.CountEnabledAdminsAsync();

            // Check if this user is currently an enabled admin in the database
            var currentUser = await dal.GetPlayerAsync(target.Id);
            if (currentUser != null)
            {
                var currentRoles = currentUser.Roles?.Split(',', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries)
                    ?? Array.Empty<string>();
                var wasEnabledAdmin = currentUser.IsEnabled &&
                    currentRoles.Contains(Roles.Administrator, StringComparer.OrdinalIgnoreCase);

                // If they were an enabled admin and this change would leave 0 enabled admins, block
                if (wasEnabledAdmin && enabledAdminCount <= 1)
                {
                    context.AddErrorResult("System must have at least one enabled administrator.");
                }
            }
        }
    }
}
```

3. Override AddBusinessRules to register the rule:
```csharp
protected override void AddBusinessRules()
{
    base.AddBusinessRules();
    BusinessRules.AddRule(new LastAdminProtectionRule(IdProperty));
}
```

**AdminUserEditTests.cs (new file):**

Create test class with [DoNotParallelize] attribute (shares MockDb state):

```csharp
using Csla;
using Csla.Configuration;
using GameMechanics.Player;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Threa.Dal;
using Threa.Dal.MockDb;

namespace GameMechanics.Test;

[TestClass]
[DoNotParallelize]
public class AdminUserEditTests
{
    private static IServiceProvider? _serviceProvider;
    private IDataPortal<AdminUserEdit>? _portal;

    [ClassInitialize]
    public static void ClassInitialize(TestContext context)
    {
        var services = new ServiceCollection();
        services.AddCsla(o => o.AddBlazorServerSupport());
        services.AddTransient<IPlayerDal, PlayerDal>();
        _serviceProvider = services.BuildServiceProvider();
    }

    [TestInitialize]
    public void TestInitialize()
    {
        _portal = _serviceProvider!.GetRequiredService<IDataPortal<AdminUserEdit>>();
        // Clear mock data and set up test users
        MockDb.Players.Clear();
    }

    [TestMethod]
    public async Task DisableLastAdmin_ShouldFail()
    {
        // Arrange: Create single admin user
        var dal = _serviceProvider!.GetRequiredService<IPlayerDal>();
        await dal.SavePlayerAsync(new Threa.Dal.Dto.Player
        {
            Email = "admin@test.com",
            Name = "Admin",
            Roles = "Administrator",
            IsEnabled = true,
            HashedPassword = "test",
            Salt = "salt"
        });

        var user = await _portal!.FetchAsync(0);
        user.IsEnabled = false;

        // Act & Assert
        Assert.IsFalse(user.IsSavable, "Should not be savable when disabling last admin");
        Assert.IsTrue(user.BrokenRulesCollection.Any(r => r.Description.Contains("at least one enabled administrator")));
    }

    [TestMethod]
    public async Task DemoteLastAdmin_ShouldFail()
    {
        // Arrange: Create single admin user
        var dal = _serviceProvider!.GetRequiredService<IPlayerDal>();
        await dal.SavePlayerAsync(new Threa.Dal.Dto.Player
        {
            Email = "admin@test.com",
            Name = "Admin",
            Roles = "Administrator",
            IsEnabled = true,
            HashedPassword = "test",
            Salt = "salt"
        });

        var user = await _portal!.FetchAsync(0);
        user.IsAdministrator = false;

        // Act & Assert
        Assert.IsFalse(user.IsSavable, "Should not be savable when demoting last admin");
    }

    [TestMethod]
    public async Task DisableNonLastAdmin_ShouldSucceed()
    {
        // Arrange: Create two admin users
        var dal = _serviceProvider!.GetRequiredService<IPlayerDal>();
        await dal.SavePlayerAsync(new Threa.Dal.Dto.Player
        {
            Email = "admin1@test.com",
            Name = "Admin 1",
            Roles = "Administrator",
            IsEnabled = true,
            HashedPassword = "test",
            Salt = "salt"
        });
        await dal.SavePlayerAsync(new Threa.Dal.Dto.Player
        {
            Email = "admin2@test.com",
            Name = "Admin 2",
            Roles = "Administrator",
            IsEnabled = true,
            HashedPassword = "test",
            Salt = "salt"
        });

        var user = await _portal!.FetchAsync(0);
        user.IsEnabled = false;

        // Act & Assert
        Assert.IsTrue(user.IsSavable, "Should be savable when other admins exist");
    }

    [TestMethod]
    public async Task DisableNonAdmin_ShouldAlwaysSucceed()
    {
        // Arrange: Create admin and regular user
        var dal = _serviceProvider!.GetRequiredService<IPlayerDal>();
        await dal.SavePlayerAsync(new Threa.Dal.Dto.Player
        {
            Email = "admin@test.com",
            Name = "Admin",
            Roles = "Administrator",
            IsEnabled = true,
            HashedPassword = "test",
            Salt = "salt"
        });
        await dal.SavePlayerAsync(new Threa.Dal.Dto.Player
        {
            Email = "user@test.com",
            Name = "User",
            Roles = "Player",
            IsEnabled = true,
            HashedPassword = "test",
            Salt = "salt"
        });

        var user = await _portal!.FetchAsync(1); // Regular user
        user.IsEnabled = false;

        // Act & Assert
        Assert.IsTrue(user.IsSavable, "Should be savable when disabling non-admin");
    }
}
```
  </action>
  <verify>
1. Build succeeds: `dotnet build Threa.sln`
2. Tests pass: `dotnet test GameMechanics.Test --filter "FullyQualifiedName~AdminUserEditTests"`
  </verify>
  <done>
- LastAdminProtectionRule added to AdminUserEdit
- Rule blocks save when last enabled admin would be disabled or demoted
- Rule allows save when other enabled admins exist
- 4 unit tests pass covering all scenarios
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` succeeds with no errors
2. `dotnet test GameMechanics.Test --filter "FullyQualifiedName~AdminUserEditTests"` shows all tests passing
3. Grep confirms CountEnabledAdminsAsync in IPlayerDal: `grep -r "CountEnabledAdminsAsync" Threa.Dal/`
4. Grep confirms LastAdminProtectionRule in AdminUserEdit: `grep -r "LastAdminProtectionRule" GameMechanics/`
</verification>

<success_criteria>
- CountEnabledAdminsAsync method exists in IPlayerDal and both implementations
- LastAdminProtectionRule business rule prevents disabling/demoting last admin
- 4+ unit tests validate the protection logic
- Build and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-admin-user-management/10-01-SUMMARY.md`
</output>
