---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - GameMechanics/Items/CharacterItemEdit.cs
  - GameMechanics/Items/CharacterItemInfo.cs
  - GameMechanics/Items/CharacterItemList.cs
  - GameMechanics.Test/CharacterItemTests.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "CharacterItemEdit can be created via data portal"
    - "CharacterItemEdit can be fetched by Guid Id"
    - "CharacterItemEdit can be saved (insert and update)"
    - "CharacterItemEdit can be deleted"
    - "CharacterItemList fetches items for a character"
    - "Unit tests verify CharacterItem CRUD operations"
  artifacts:
    - path: "GameMechanics/Items/CharacterItemEdit.cs"
      provides: "Edit business object for character items"
      exports: ["CharacterItemEdit"]
      min_lines: 150
    - path: "GameMechanics/Items/CharacterItemInfo.cs"
      provides: "Read-only info object for character items"
      exports: ["CharacterItemInfo"]
      min_lines: 50
    - path: "GameMechanics/Items/CharacterItemList.cs"
      provides: "Read-only list of character items"
      exports: ["CharacterItemList"]
      min_lines: 30
    - path: "GameMechanics.Test/CharacterItemTests.cs"
      provides: "Unit tests for CharacterItem business objects"
      min_lines: 80
  key_links:
    - from: "GameMechanics/Items/CharacterItemEdit.cs"
      to: "Threa.Dal/IItemDal.cs"
      via: "ICharacterItemDal injection"
      pattern: "ICharacterItemDal"
    - from: "GameMechanics/Items/CharacterItemList.cs"
      to: "GameMechanics/Items/CharacterItemInfo.cs"
      via: "IChildDataPortal<CharacterItemInfo>"
      pattern: "IChildDataPortal<CharacterItemInfo>"
---

<objective>
Create CharacterItemEdit, CharacterItemInfo, and CharacterItemList CSLA business objects with full data portal operations.

Purpose: CharacterItem represents actual item instances owned by characters. This business object layer is required for all inventory operations in subsequent phases.
Output: Three new business object files plus comprehensive unit tests.
</objective>

<execution_context>
@S:\src\rdl\threa\.claude\get-shit-done\workflows\execute-plan.md
@S:\src\rdl\threa\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@S:\src\rdl\threa\.planning\PROJECT.md
@S:\src\rdl\threa\.planning\ROADMAP.md
@S:\src\rdl\threa\.planning\STATE.md
@S:\src\rdl\threa\.planning\phases\01-foundation\01-CONTEXT.md
@S:\src\rdl\threa\.planning\phases\01-foundation\01-RESEARCH.md

<!-- Pattern reference files -->
@S:\src\rdl\threa\GameMechanics\Items\ItemTemplateEdit.cs
@S:\src\rdl\threa\GameMechanics\Items\ItemTemplateInfo.cs
@S:\src\rdl\threa\GameMechanics\Items\ItemTemplateList.cs
@S:\src\rdl\threa\GameMechanics.Test\CharacterSaveLoadTest.cs

<!-- DTO and DAL references -->
@S:\src\rdl\threa\Threa.Dal\Dto\CharacterItem.cs
@S:\src\rdl\threa\Threa.Dal\IItemDal.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CharacterItemEdit business object</name>
  <files>GameMechanics/Items/CharacterItemEdit.cs</files>
  <action>
Create CharacterItemEdit.cs following the exact patterns from ItemTemplateEdit.cs:

1. Class declaration:
   ```csharp
   [Serializable]
   public class CharacterItemEdit : BusinessBase<CharacterItemEdit>
   ```

2. Properties with PropertyInfo pattern (mirror CharacterItem DTO):
   - Id (Guid) - private setter, use LoadProperty
   - ItemTemplateId (int) - required
   - OwnerCharacterId (int) - set during Create, read-only after
   - ContainerItemId (Guid?) - nullable
   - EquippedSlot (EquipmentSlot) - default EquipmentSlot.None
   - IsEquipped (bool)
   - StackSize (int) - default 1
   - CurrentDurability (int?)
   - CustomName (string?)
   - CreatedAt (DateTime)
   - CustomProperties (string?)

3. Data portal operations following ItemTemplateEdit patterns:

   [Create]
   private async Task Create(int characterId, int templateId)
   - Set Id = Guid.NewGuid()
   - Set OwnerCharacterId = characterId
   - Set ItemTemplateId = templateId
   - Initialize defaults (StackSize = 1, IsEquipped = false, etc.)
   - Use BypassPropertyChecks, call BusinessRules.CheckRules()

   [Fetch]
   private async Task Fetch(Guid id, [Inject] ICharacterItemDal dal)
   - Call dal.GetItemAsync(id)
   - Throw if null
   - Call LoadFromDto(data)

   [Insert]
   private async Task Insert([Inject] ICharacterItemDal dal)
   - Map to CharacterItem DTO
   - Call dal.AddItemAsync(dto)

   [Update]
   private async Task Update([Inject] ICharacterItemDal dal)
   - Map to CharacterItem DTO (include Id)
   - Call dal.UpdateItemAsync(dto)

   [Delete]
   private async Task Delete(Guid id, [Inject] ICharacterItemDal dal)
   - Call dal.DeleteItemAsync(id)

4. AddBusinessRules():
   - ItemTemplateId required (> 0)
   - OwnerCharacterId required (> 0)
   - StackSize >= 1

5. Helper method:
   private void LoadFromDto(CharacterItem data)
   - Use BypassPropertyChecks
   - Map all properties from DTO
   - Call BusinessRules.CheckRules()

Use namespace: GameMechanics.Items
Add required usings: System, System.Threading.Tasks, Csla, Threa.Dal, Threa.Dal.Dto
  </action>
  <verify>
Build succeeds: `dotnet build S:\src\rdl\threa\GameMechanics\GameMechanics.csproj`
  </verify>
  <done>
CharacterItemEdit.cs exists with all properties, Create/Fetch/Insert/Update/Delete operations, and validation rules. File compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CharacterItemInfo and CharacterItemList</name>
  <files>GameMechanics/Items/CharacterItemInfo.cs, GameMechanics/Items/CharacterItemList.cs</files>
  <action>
Create two files following patterns from ItemTemplateInfo.cs and ItemTemplateList.cs:

**CharacterItemInfo.cs:**
1. Class declaration:
   ```csharp
   [Serializable]
   public class CharacterItemInfo : ReadOnlyBase<CharacterItemInfo>
   ```

2. Properties (read-only, same as CharacterItemEdit):
   - All properties from CharacterItemEdit
   - Use LoadProperty with private setters

3. [FetchChild] method:
   ```csharp
   [FetchChild]
   private void Fetch(CharacterItem dto)
   {
       LoadProperty(IdProperty, dto.Id);
       // ... load all properties
   }
   ```

**CharacterItemList.cs:**
1. Class declaration:
   ```csharp
   [Serializable]
   public class CharacterItemList : ReadOnlyListBase<CharacterItemList, CharacterItemInfo>
   ```

2. [Fetch] method with characterId parameter:
   ```csharp
   [Fetch]
   private async Task Fetch(int characterId,
       [Inject] ICharacterItemDal dal,
       [Inject] IChildDataPortal<CharacterItemInfo> childPortal)
   {
       var items = await dal.GetCharacterItemsAsync(characterId);
       using (LoadListMode)
       {
           foreach (var item in items)
           {
               Add(childPortal.FetchChild(item));
           }
       }
   }
   ```

Both files:
- Use namespace: GameMechanics.Items
- Add required usings: System, System.Threading.Tasks, Csla, Threa.Dal, Threa.Dal.Dto
  </action>
  <verify>
Build succeeds: `dotnet build S:\src\rdl\threa\GameMechanics\GameMechanics.csproj`
  </verify>
  <done>
CharacterItemInfo.cs and CharacterItemList.cs exist with all properties and data portal operations. Files compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for CharacterItem objects</name>
  <files>GameMechanics.Test/CharacterItemTests.cs</files>
  <action>
Create CharacterItemTests.cs following CharacterSaveLoadTest.cs patterns:

1. Test class setup:
   - [TestClass] attribute
   - InitServices() method using AddCsla() and AddMockDb()
   - Get IDataPortal<CharacterItemEdit> and IDataPortal<CharacterItemList>

2. CharacterItemEdit tests:
   - CharacterItemEdit_Create_InitializesWithCharacterAndTemplate: Create with characterId=1, templateId=10, verify properties
   - CharacterItemEdit_Create_GeneratesGuidId: Create item, verify Id is not Guid.Empty
   - CharacterItemEdit_Fetch_LoadsExistingItem: Fetch existing item from MockDb (use Guid "11111111-1111-1111-1111-111111111111"), verify properties
   - CharacterItemEdit_SaveAndFetch_PropertiesPersist: Create new item, save, fetch by Id, verify all properties match
   - CharacterItemEdit_Update_ChangesPersist: Fetch existing, modify CustomName, save, fetch again, verify change
   - CharacterItemEdit_Validation_RequiresTemplateId: Create with templateId=0, verify IsSavable is false

3. CharacterItemList tests:
   - CharacterItemList_Fetch_ReturnsCharacterItems: Fetch list for characterId=1, verify Count > 0
   - CharacterItemList_Fetch_ItemsHaveCorrectProperties: Fetch list, verify first item has expected template (Longsword)

Note: MockDb.CreateCharacterItems() has sample items for characterId=1 with templates 10 (Longsword), 20 (Leather Armor), 30 (Backpack), etc.

Use MSTest Assert methods, async/await pattern.
  </action>
  <verify>
All tests pass: `dotnet test S:\src\rdl\threa\GameMechanics.Test\GameMechanics.Test.csproj --filter "FullyQualifiedName~CharacterItemTests"`
  </verify>
  <done>
CharacterItemTests.cs exists with 8+ tests covering CharacterItemEdit CRUD, validation, and CharacterItemList fetch operations. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build S:\src\rdl\threa\Threa.sln` - Solution builds without errors
2. `dotnet test S:\src\rdl\threa\GameMechanics.Test\GameMechanics.Test.csproj --filter "FullyQualifiedName~CharacterItemTests"` - All CharacterItem tests pass
3. CharacterItemEdit.cs, CharacterItemInfo.cs, CharacterItemList.cs all exist in GameMechanics/Items/
</verification>

<success_criteria>
1. CharacterItemEdit has all properties matching CharacterItem DTO
2. CharacterItemEdit has Create, Fetch, Insert, Update, Delete operations
3. CharacterItemInfo is read-only with all properties
4. CharacterItemList fetches items by characterId
5. CharacterItemTests.cs has 8+ tests covering CRUD and validation
6. All tests pass
7. Solution builds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
