---
phase: 31-batch-effects
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - GameMechanics/Batch/BatchActionService.cs
  - Threa/Threa.Client/Components/Shared/BatchEffectRemoveModal.razor
  - Threa/Threa.Client/Components/Shared/SelectionBar.razor
autonomous: true

must_haves:
  truths:
    - "GM can open an effect remove modal from the SelectionBar showing a union list of all effect names across selected characters"
    - "GM can select multiple effect names to remove in one operation"
    - "BatchActionService.RemoveEffectsAsync removes matching effects using EffectList.RemoveEffect (with behavior callbacks)"
    - "Characters without matching effects are silently skipped (not counted in results)"
    - "Result summary shows 'Removed N effect(s) from M character(s)' format"
    - "Selection stays intact after batch effect remove"
  artifacts:
    - path: "GameMechanics/Batch/BatchActionService.cs"
      provides: "RemoveEffectsAsync method"
      contains: "RemoveEffectsAsync"
    - path: "Threa/Threa.Client/Components/Shared/BatchEffectRemoveModal.razor"
      provides: "Modal with checkbox list of union effect names from selected characters"
      contains: "BatchEffectRemoveModal"
    - path: "Threa/Threa.Client/Components/Shared/SelectionBar.razor"
      provides: "Remove Effects button that opens BatchEffectRemoveModal"
      contains: "OpenBatchEffectRemove"
  key_links:
    - from: "Threa/Threa.Client/Components/Shared/SelectionBar.razor"
      to: "BatchEffectRemoveModal"
      via: "DialogService.OpenAsync<BatchEffectRemoveModal>"
      pattern: "OpenAsync<BatchEffectRemoveModal>"
    - from: "Threa/Threa.Client/Components/Shared/SelectionBar.razor"
      to: "GameMechanics/Batch/BatchActionService.cs"
      via: "BatchActionService.RemoveEffectsAsync call"
      pattern: "RemoveEffectsAsync"
    - from: "GameMechanics/Batch/BatchActionService.cs"
      to: "GameMechanics/EffectList.cs"
      via: "character.Effects.RemoveEffect(effectId) with behavior callback"
      pattern: "RemoveEffect"
---

<objective>
Implement batch effect remove: backend service method, effect selection modal with union list, and SelectionBar wiring so GMs can remove effects from all selected characters at once.

Purpose: GMs need to efficiently strip effects from groups (e.g., "the Bless spell ends for everyone" or "clear all poison from the party after resting"). This eliminates per-character effect removal.
Output: RemoveEffectsAsync in BatchActionService, BatchEffectRemoveModal component with union effect name list, SelectionBar "Remove Effects" button.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-batch-effects/31-CONTEXT.md
@.planning/phases/31-batch-effects/31-RESEARCH.md
@.planning/phases/31-batch-effects/31-01-SUMMARY.md

Key source files:
@GameMechanics/Batch/BatchActionService.cs
@GameMechanics/Batch/BatchActionRequest.cs
@GameMechanics/Batch/BatchActionResult.cs
@GameMechanics/EffectList.cs
@GameMechanics/EffectRecord.cs
@Threa/Threa.Client/Components/Shared/SelectionBar.razor
@Threa/Threa.Client/Components/Pages/GamePlay/GmTable.razor
@Threa.Dal/Dto/EffectType.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RemoveEffectsAsync to BatchActionService</name>
  <files>
    GameMechanics/Batch/BatchActionService.cs
  </files>
  <action>
Add `RemoveEffectsAsync` method to `BatchActionService`. This method:

1. Creates a BatchActionResult with ActionType = EffectRemove
2. Iterates characters sequentially (same pattern as all other batch methods)
3. For each character, iterates the requested effect names to remove
4. Finds matching effects by name (excluding Wound type -- wounds have special lifecycle management)
5. Calls `character.Effects.RemoveEffect(effect.Id)` (NOT direct list Remove -- this calls behavior.OnRemove)
6. Only calls UpdateAsync if at least one effect was removed from that character
7. Characters with zero matching effects are silently skipped (not counted in results, not an error)
8. Tracks totalEffectsRemoved across all characters
9. Publishes single CharactersUpdatedMessage after batch completes

```csharp
/// <summary>
/// Removes effects by name from multiple characters.
/// Characters without matching effects are silently skipped.
/// Uses EffectList.RemoveEffect for proper behavior callbacks.
/// </summary>
public async Task<BatchActionResult> RemoveEffectsAsync(BatchActionRequest request)
{
    var result = new BatchActionResult
    {
        ActionType = BatchActionType.EffectRemove
    };

    int totalEffectsRemoved = 0;

    foreach (var characterId in request.CharacterIds)
    {
        try
        {
            var character = await _characterPortal.FetchAsync(characterId);
            int removedFromThis = 0;

            foreach (var effectName in request.EffectNamesToRemove)
            {
                // Find matching effects by name, excluding wounds
                var matching = character.Effects
                    .Where(e => e.Name == effectName && e.EffectType != Threa.Dal.Dto.EffectType.Wound)
                    .ToList();

                foreach (var effect in matching)
                {
                    character.Effects.RemoveEffect(effect.Id);
                    removedFromThis++;
                }
            }

            // Only save and count if effects were actually removed
            if (removedFromThis > 0)
            {
                await _characterPortal.UpdateAsync(character);
                result.SuccessIds.Add(characterId);
                result.SuccessNames.Add(character.Name);
                totalEffectsRemoved += removedFromThis;
            }
            // Characters with no matching effects are silently skipped
        }
        catch (Exception ex)
        {
            result.FailedIds.Add(characterId);
            result.Errors.Add($"Character {characterId}: {ex.Message}");
        }
    }

    result.TotalEffectsRemoved = totalEffectsRemoved;

    // Single notification after batch completes
    if (result.SuccessIds.Count > 0)
    {
        await _timeEventPublisher.PublishCharactersUpdatedAsync(
            new CharactersUpdatedMessage
            {
                TableId = request.TableId,
                CharacterIds = result.SuccessIds,
                EventType = TimeEventType.EndOfRound,
                SourceId = "BatchActionService"
            });
    }

    return result;
}
```

Update the class-level XML doc to mention effect add/remove.
  </action>
  <verify>`dotnet build GameMechanics/GameMechanics.csproj` passes. BatchActionService has RemoveEffectsAsync method. The method uses RemoveEffect(effectId) not direct list removal.</verify>
  <done>BatchActionService.RemoveEffectsAsync removes matching effects by name using proper RemoveEffect calls, silently skips characters without matches, tracks total effects removed, and publishes single notification.</done>
</task>

<task type="auto">
  <name>Task 2: Create BatchEffectRemoveModal and wire SelectionBar</name>
  <files>
    Threa/Threa.Client/Components/Shared/BatchEffectRemoveModal.razor
    Threa/Threa.Client/Components/Shared/SelectionBar.razor
  </files>
  <action>
1. Create `BatchEffectRemoveModal.razor` in `Threa/Threa.Client/Components/Shared/`. This modal:
   - Accepts `[Parameter] public List<EffectNameInfo> EffectNames { get; set; }` -- the pre-computed union list
   - Shows a checkbox list of effect names, each with an icon for the effect type and a count of how many characters have it
   - Supports multi-select -- GM can check multiple effect names
   - Has "Select All" and "Clear" links at the top of the list
   - Confirm button text: "Remove from N Character(s)" (using a SelectedCount parameter)
   - Confirm button disabled when no effects are checked
   - On confirm: `DialogService.Close(selectedNames.ToList())` returns `List<string>`
   - On cancel: `DialogService.Close(null)`
   - If the union list is empty (no effects found on any selected character), show a message: "No removable effects found on selected characters." with only a Close button

   Create a helper record `EffectNameInfo` in the same file or in a separate file. Since it's small, define it in `GameMechanics/Batch/EffectNameInfo.cs`:
   ```csharp
   // Actually, put this in the razor file @code block as a simple class since it's UI-specific
   ```
   Better: put it in `GameMechanics/Batch/` as a simple record since SelectionBar needs to create it:

   Create `GameMechanics/Batch/EffectNameInfo.cs`:
   ```csharp
   using Threa.Dal.Dto;

   namespace GameMechanics.Batch;

   /// <summary>
   /// Represents a unique effect name found across selected characters for the batch remove modal.
   /// </summary>
   public class EffectNameInfo
   {
       public string Name { get; set; } = "";
       public EffectType EffectType { get; set; }
       public int CharacterCount { get; set; }
   }
   ```

   The modal markup should follow existing modal patterns (p-3 wrapper, form structure, d-flex footer with Cancel/Confirm):
   ```html
   <div class="p-3">
       @if (EffectNames == null || EffectNames.Count == 0)
       {
           <div class="alert alert-info mb-3">
               <i class="bi bi-info-circle me-1"></i>
               No removable effects found on selected characters.
           </div>
           <div class="d-flex justify-content-end">
               <button type="button" class="btn btn-secondary" @onclick="Cancel">Close</button>
           </div>
       }
       else
       {
           <div class="mb-2 d-flex justify-content-between align-items-center">
               <small class="text-muted">Select effects to remove:</small>
               <div>
                   <button type="button" class="btn btn-link btn-sm p-0 me-2" @onclick="SelectAll">Select All</button>
                   <button type="button" class="btn btn-link btn-sm p-0" @onclick="ClearSelection">Clear</button>
               </div>
           </div>
           <div class="list-group mb-3" style="max-height: 300px; overflow-y: auto;">
               @foreach (var effectInfo in EffectNames)
               {
                   <label class="list-group-item d-flex align-items-center gap-2">
                       <input type="checkbox" class="form-check-input mt-0"
                              checked="@selectedNames.Contains(effectInfo.Name)"
                              @onchange="() => ToggleSelection(effectInfo.Name)" />
                       <i class="bi @GetEffectTypeIcon(effectInfo.EffectType)"></i>
                       <span class="flex-grow-1">@effectInfo.Name</span>
                       <span class="badge bg-secondary">@effectInfo.CharacterCount</span>
                   </label>
               }
           </div>
           <div class="d-flex justify-content-end gap-2">
               <button type="button" class="btn btn-secondary" @onclick="Cancel">Cancel</button>
               <button type="button" class="btn btn-warning" @onclick="Confirm" disabled="@(selectedNames.Count == 0)">
                   <i class="bi bi-x-circle me-1"></i>Remove @selectedNames.Count Effect(s)
               </button>
           </div>
       }
   </div>
   ```

   The @code block needs:
   - Parameters: `EffectNames`, `SelectedCount`
   - `selectedNames` HashSet<string>
   - `ToggleSelection(string name)` method
   - `SelectAll()` / `ClearSelection()` methods
   - `GetEffectTypeIcon(EffectType type)` -- map effect types to Bootstrap icons (reuse the same mapping as EffectFormModal: Buff -> bi-arrow-up-circle, Debuff -> bi-arrow-down-circle, Condition -> bi-exclamation-circle, Poison -> bi-droplet, Disease -> bi-virus, etc.)
   - `Cancel()` / `Confirm()` methods

2. In `SelectionBar.razor`, add a "Remove Effects" button next to the "Add Effect" button:
   ```html
   <button class="btn btn-sm btn-outline-warning" @onclick="OpenBatchEffectRemove">
       <i class="bi bi-x-circle me-1"></i>Remove Effects
   </button>
   ```

3. In `SelectionBar.razor` @code, add the helper method to build the union effect name list by fetching each selected character:
   ```csharp
   private async Task<List<EffectNameInfo>> GetUnionEffectNamesAsync()
   {
       var effectNames = new Dictionary<string, EffectNameInfo>();

       foreach (var characterId in SelectedCharacterIds)
       {
           try
           {
               var character = await characterPortal.FetchAsync(characterId);
               foreach (var effect in character.Effects
                   .Where(e => e.EffectType != Threa.Dal.Dto.EffectType.Wound && e.IsActive))
               {
                   if (!effectNames.ContainsKey(effect.Name))
                   {
                       effectNames[effect.Name] = new EffectNameInfo
                       {
                           Name = effect.Name,
                           EffectType = effect.EffectType,
                           CharacterCount = 0
                       };
                   }
                   effectNames[effect.Name].CharacterCount++;
               }
           }
           catch { /* skip inaccessible characters */ }
       }

       return effectNames.Values
           .OrderBy(e => e.EffectType)
           .ThenBy(e => e.Name)
           .ToList();
   }
   ```

   This requires `IDataPortal<CharacterEdit>` injection in SelectionBar. Add:
   ```csharp
   @inject IDataPortal<CharacterEdit> characterPortal
   ```
   And add `@using GameMechanics` and `@using Threa.Dal.Dto` if not already present.

4. In `SelectionBar.razor` @code, add the `OpenBatchEffectRemove` method:
   ```csharp
   private async Task OpenBatchEffectRemove()
   {
       var effectNames = await GetUnionEffectNamesAsync();

       var result = await DialogService.OpenAsync<BatchEffectRemoveModal>(
           "Remove Effects from Selected Characters",
           new Dictionary<string, object>
           {
               { "EffectNames", effectNames },
               { "SelectedCount", SelectedCount }
           },
           new DialogOptions { Width = "500px", CloseDialogOnOverlayClick = true });

       if (result is List<string> namesToRemove && namesToRemove.Count > 0)
       {
           await ExecuteBatchEffectRemove(namesToRemove);
       }
   }
   ```

5. In `SelectionBar.razor` @code, add the `ExecuteBatchEffectRemove` method:
   ```csharp
   private async Task ExecuteBatchEffectRemove(List<string> effectNamesToRemove)
   {
       var request = new BatchActionRequest
       {
           TableId = TableId,
           CharacterIds = SelectedCharacterIds.ToList(),
           ActionType = BatchActionType.EffectRemove,
           EffectNamesToRemove = effectNamesToRemove
       };

       var batchResult = await BatchActionService.RemoveEffectsAsync(request);
       await HandleBatchResult(batchResult);
   }
   ```

Note: The GmTable EffectRemove case was already handled in Plan 31-01 (combined with EffectAdd in the same switch case). No GmTable changes needed here.
  </action>
  <verify>`dotnet build Threa.sln` compiles successfully (excluding file-lock on running host). SelectionBar has "Remove Effects" button. BatchEffectRemoveModal.razor exists with checkbox list. EffectNameInfo.cs exists in GameMechanics/Batch/.</verify>
  <done>BatchEffectRemoveModal shows union list of effect names with checkboxes and character counts. SelectionBar has "Remove Effects" button that fetches union list, opens modal, and calls RemoveEffectsAsync. Characters without matching effects silently skipped. Selection stays intact after remove.</done>
</task>

</tasks>

<verification>
1. `dotnet build GameMechanics/GameMechanics.csproj` -- 0 errors
2. `dotnet build Threa.sln` -- compiles (excluding file-lock on running host)
3. `dotnet test GameMechanics.Test/GameMechanics.Test.csproj` -- all existing tests pass
4. BatchActionService has RemoveEffectsAsync that uses RemoveEffect(effectId) with behavior callbacks
5. RemoveEffectsAsync silently skips characters without matching effects (no UpdateAsync, no error)
6. RemoveEffectsAsync tracks TotalEffectsRemoved across all characters
7. BatchActionResult.Summary returns "Removed N effect(s) from M character(s)" for EffectRemove
8. BatchEffectRemoveModal shows checkbox list sorted by type then name with character counts
9. SelectionBar has "Remove Effects" button that builds union list and opens modal
10. Selection stays intact after batch effect remove (handled by GmTable EffectRemove case from 31-01)
</verification>

<success_criteria>
- GM can click "Remove Effects" in SelectionBar to open BatchEffectRemoveModal
- Modal shows all unique effect names (excluding wounds) across selected characters with checkboxes
- GM can select multiple effects and confirm to remove them from all selected characters
- Characters without the selected effects are silently skipped
- Result summary shows "Removed N effect(s) from M character(s)"
- Selection stays intact after batch effect remove
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/31-batch-effects/31-02-SUMMARY.md`
</output>
