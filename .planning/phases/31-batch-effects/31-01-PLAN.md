---
phase: 31-batch-effects
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - GameMechanics/Batch/BatchActionRequest.cs
  - GameMechanics/Batch/BatchActionResult.cs
  - GameMechanics/Batch/BatchActionService.cs
  - GameMechanics/Batch/BatchEffectConfig.cs
  - Threa/Threa.Client/Components/Shared/BatchEffectAddModal.razor
  - Threa/Threa.Client/Components/Shared/SelectionBar.razor
  - Threa/Threa.Client/Components/Pages/GamePlay/GmTable.razor
autonomous: true

must_haves:
  truths:
    - "GM can open an effect add modal from the SelectionBar and choose 'From Template' or 'Custom Effect'"
    - "BatchActionService.AddEffectAsync creates an EffectRecord for each selected character with shared game time"
    - "BatchActionResult.Summary produces 'Added {EffectName} to N character(s)' format for EffectAdd actions"
    - "Selection stays intact after batch effect add completes"
    - "Stacking logic is deferred to EffectList.AddEffect (no special batch override)"
  artifacts:
    - path: "GameMechanics/Batch/BatchActionRequest.cs"
      provides: "EffectAdd enum value and effect-specific fields (EffectName, EffectType, etc.)"
      contains: "EffectAdd"
    - path: "GameMechanics/Batch/BatchActionResult.cs"
      provides: "EffectAdd summary case and EffectName property"
      contains: "EffectAdd"
    - path: "GameMechanics/Batch/BatchActionService.cs"
      provides: "AddEffectAsync method with IChildDataPortal<EffectRecord> injection"
      contains: "AddEffectAsync"
    - path: "GameMechanics/Batch/BatchEffectConfig.cs"
      provides: "Record type returned by BatchEffectAddModal with effect configuration"
      contains: "BatchEffectConfig"
    - path: "Threa/Threa.Client/Components/Shared/BatchEffectAddModal.razor"
      provides: "Modal with template picker and custom effect form for batch add"
      contains: "BatchEffectAddModal"
    - path: "Threa/Threa.Client/Components/Shared/SelectionBar.razor"
      provides: "Add Effect button that opens BatchEffectAddModal"
      contains: "OpenBatchEffectAdd"
  key_links:
    - from: "Threa/Threa.Client/Components/Shared/SelectionBar.razor"
      to: "BatchEffectAddModal"
      via: "DialogService.OpenAsync<BatchEffectAddModal>"
      pattern: "OpenAsync<BatchEffectAddModal>"
    - from: "Threa/Threa.Client/Components/Shared/SelectionBar.razor"
      to: "GameMechanics/Batch/BatchActionService.cs"
      via: "BatchActionService.AddEffectAsync call"
      pattern: "AddEffectAsync"
    - from: "GameMechanics/Batch/BatchActionService.cs"
      to: "GameMechanics/EffectRecord.cs"
      via: "IChildDataPortal<EffectRecord>.CreateChildAsync"
      pattern: "IChildDataPortal<EffectRecord>"
    - from: "GameMechanics/Batch/BatchActionService.cs"
      to: "GameMechanics/EffectList.cs"
      via: "character.Effects.AddEffect(effect)"
      pattern: "AddEffect"
---

<objective>
Implement batch effect add: backend service method, effect configuration modal, and SelectionBar wiring so GMs can add an effect to all selected characters at once.

Purpose: GMs frequently need to apply the same buff/debuff/condition to multiple characters (e.g., "everyone in the blast radius gets Burning"). This eliminates repetitive per-character effect application.
Output: AddEffectAsync in BatchActionService, BatchEffectAddModal component, SelectionBar "Add Effect" button, GmTable EffectAdd case in HandleBatchActionCompleted.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-batch-effects/31-CONTEXT.md
@.planning/phases/31-batch-effects/31-RESEARCH.md

Key source files:
@GameMechanics/Batch/BatchActionService.cs
@GameMechanics/Batch/BatchActionRequest.cs
@GameMechanics/Batch/BatchActionResult.cs
@GameMechanics/Batch/BatchInputResult.cs
@GameMechanics/EffectRecord.cs
@GameMechanics/EffectList.cs
@GameMechanics/Effects/EffectState.cs
@Threa/Threa.Client/Components/Shared/SelectionBar.razor
@Threa/Threa.Client/Components/Shared/EffectFormModal.razor
@Threa/Threa.Client/Components/Shared/EffectTemplatePickerModal.razor
@Threa/Threa.Client/Components/Shared/BatchDamageHealingModal.razor
@Threa/Threa.Client/Components/Pages/GamePlay/GmTable.razor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend batch DTOs and add AddEffectAsync to BatchActionService</name>
  <files>
    GameMechanics/Batch/BatchActionRequest.cs
    GameMechanics/Batch/BatchActionResult.cs
    GameMechanics/Batch/BatchActionService.cs
    GameMechanics/Batch/BatchEffectConfig.cs
  </files>
  <action>
1. In `BatchActionRequest.cs`, add two new enum values to `BatchActionType`:
```csharp
/// <summary>Add an effect to selected characters.</summary>
EffectAdd,

/// <summary>Remove effect(s) from selected characters.</summary>
EffectRemove
```

2. In `BatchActionRequest.cs`, add effect-specific properties to the record:
```csharp
/// <summary>
/// For EffectAdd: the effect name to apply.
/// </summary>
public string? EffectName { get; set; }

/// <summary>
/// For EffectAdd: the effect type.
/// </summary>
public EffectType? EffectType { get; set; }

/// <summary>
/// For EffectAdd: the effect description.
/// </summary>
public string? EffectDescription { get; set; }

/// <summary>
/// For EffectAdd: duration in seconds (null = permanent).
/// </summary>
public long? DurationSeconds { get; set; }

/// <summary>
/// For EffectAdd: duration in rounds for legacy EffectRecord creation.
/// </summary>
public int? DurationRounds { get; set; }

/// <summary>
/// For EffectAdd: serialized EffectState JSON (modifiers, DoT, etc.).
/// </summary>
public string? BehaviorStateJson { get; set; }

/// <summary>
/// For EffectRemove: list of effect names to remove.
/// </summary>
public List<string> EffectNamesToRemove { get; set; } = new();
```
Add `using Threa.Dal.Dto;` for the EffectType import.

3. In `BatchActionResult.cs`, add an `EffectName` property and a `TotalEffectsRemoved` property:
```csharp
/// <summary>
/// For effect add operations: the name of the effect applied.
/// </summary>
public string? EffectName { get; set; }

/// <summary>
/// For effect remove operations: total count of effects removed across all characters.
/// </summary>
public int TotalEffectsRemoved { get; set; }
```

4. In `BatchActionResult.cs`, extend the Summary switch expression with EffectAdd and EffectRemove cases. Insert them BEFORE the default `_` case:
```csharp
BatchActionType.EffectAdd => HasFailures
    ? $"Added {EffectName} to {SuccessIds.Count} of {TotalCount} character(s)"
    : $"Added {EffectName} to {SuccessIds.Count} character(s)",
BatchActionType.EffectRemove => HasFailures
    ? $"Removed {TotalEffectsRemoved} effect(s) from {SuccessIds.Count} of {TotalCount} character(s)"
    : $"Removed {TotalEffectsRemoved} effect(s) from {SuccessIds.Count} character(s)",
```

5. Create `GameMechanics/Batch/BatchEffectConfig.cs` -- a record type returned by BatchEffectAddModal:
```csharp
using Threa.Dal.Dto;

namespace GameMechanics.Batch;

/// <summary>
/// Effect configuration captured by BatchEffectAddModal for batch application.
/// </summary>
public record BatchEffectConfig
{
    public string EffectName { get; init; } = "";
    public EffectType EffectType { get; init; }
    public string? Description { get; init; }
    public long? DurationSeconds { get; init; }
    public int? DurationRounds { get; init; }
    public string? BehaviorStateJson { get; init; }
}
```

6. In `BatchActionService.cs`, add `IChildDataPortal<EffectRecord>` as a constructor dependency:
```csharp
private readonly IChildDataPortal<EffectRecord> _effectPortal;
```
Add it to the constructor parameters and assign it. Add `using GameMechanics.Effects;` if not already present for EffectState (though it may not be needed since we use BehaviorState string directly).

7. Add `AddEffectAsync` method to `BatchActionService`:
```csharp
/// <summary>
/// Adds an effect to multiple characters. All characters get the same effect configuration
/// with a shared game timestamp captured from the first character.
/// </summary>
public async Task<BatchActionResult> AddEffectAsync(BatchActionRequest request)
{
    var result = new BatchActionResult
    {
        ActionType = BatchActionType.EffectAdd,
        EffectName = request.EffectName
    };

    // CONTEXT decision: capture game time once before loop
    long? sharedGameTime = null;

    foreach (var characterId in request.CharacterIds)
    {
        try
        {
            var character = await _characterPortal.FetchAsync(characterId);

            // Capture game time from first character
            sharedGameTime ??= character.CurrentGameTimeSeconds;

            var effect = await _effectPortal.CreateChildAsync(
                request.EffectType!.Value,
                request.EffectName!,
                (string?)null,  // no location for batch effects
                request.DurationRounds,
                request.BehaviorStateJson
            );

            // Apply shared timestamp
            if (sharedGameTime > 0)
            {
                effect.CreatedAtEpochSeconds = sharedGameTime.Value;
                if (request.DurationSeconds.HasValue)
                {
                    effect.ExpiresAtEpochSeconds = sharedGameTime.Value + request.DurationSeconds.Value;
                }
            }

            effect.Description = request.EffectDescription;
            effect.Source = "GM (Batch)";

            // Defer to EffectList.AddEffect stacking logic
            character.Effects.AddEffect(effect);

            await _characterPortal.UpdateAsync(character);
            result.SuccessIds.Add(characterId);
            result.SuccessNames.Add(character.Name);
        }
        catch (Exception ex)
        {
            result.FailedIds.Add(characterId);
            result.Errors.Add($"Character {characterId}: {ex.Message}");
        }
    }

    // Single notification after batch completes
    if (result.SuccessIds.Count > 0)
    {
        await _timeEventPublisher.PublishCharactersUpdatedAsync(
            new CharactersUpdatedMessage
            {
                TableId = request.TableId,
                CharacterIds = result.SuccessIds,
                EventType = TimeEventType.EndOfRound,
                SourceId = "BatchActionService"
            });
    }

    return result;
}
```

8. Update the BatchActionService class-level XML doc comment to mention effect operations.
  </action>
  <verify>`dotnet build GameMechanics/GameMechanics.csproj` passes with 0 errors. BatchActionType has 6 values (Damage, Healing, Visibility, Dismiss, EffectAdd, EffectRemove). BatchActionService has AddEffectAsync method. BatchEffectConfig.cs exists.</verify>
  <done>BatchActionService.AddEffectAsync creates effects for each character with shared game time. BatchActionRequest has effect-specific fields. BatchActionResult.Summary handles EffectAdd format. BatchEffectConfig record exists for modal communication.</done>
</task>

<task type="auto">
  <name>Task 2: Create BatchEffectAddModal and wire SelectionBar + GmTable</name>
  <files>
    Threa/Threa.Client/Components/Shared/BatchEffectAddModal.razor
    Threa/Threa.Client/Components/Shared/SelectionBar.razor
    Threa/Threa.Client/Components/Pages/GamePlay/GmTable.razor
  </files>
  <action>
1. Create `BatchEffectAddModal.razor` in `Threa/Threa.Client/Components/Shared/`. This modal provides two entry paths for effect creation:
   - "From Template" button opens EffectTemplatePickerModal, then pre-fills the form
   - "Custom Effect" starts with a blank form

   The modal should contain a simplified version of the effect creation form (reuse the same field structure as EffectFormModal but WITHOUT character-specific logic). Key fields:
   - Effect Name (text input, required, min 2 chars)
   - Effect Type (select dropdown with all EffectType values EXCEPT Wound)
   - Description (textarea)
   - Duration Type (Permanent/Rounds/Turns/Minutes/Hours/Days select)
   - Duration Value (numeric, shown when not Permanent)
   - Template section: "Choose from Templates..." button that opens EffectTemplatePickerModal, and "Save as Template" button
   - Modifiers section: AS modifier, attribute modifiers (add/remove), skill modifiers (add/remove)
   - Over-time effects: FAT/VIT damage per tick, FAT/VIT healing per tick

   Use the same layout patterns as EffectFormModal (row/col grid, form labels, validation styling). The modal has:
   - `[Parameter] public int SelectedCount { get; set; }` for the confirm button text
   - Inject: `DialogService`, `IEffectTemplateDal`
   - Form validation: IsFormValid checks effectName length >= 2
   - GetDurationSeconds() method (same logic as EffectFormModal)
   - BuildEffectState() method (same logic as EffectFormModal)
   - Confirm button text: "Add to N Character(s)"
   - On confirm, create a `BatchEffectConfig` and close dialog: `DialogService.Close(config)`
   - On cancel: `DialogService.Close(null)`
   - Template picker: reuse `EffectTemplatePickerModal` via `DialogService.OpenAsync<EffectTemplatePickerModal>`
   - Template application: same `ApplyTemplate` logic as EffectFormModal
   - Save as template: same logic as EffectFormModal (call IEffectTemplateDal.InsertAsync)

   The AvailableEffectTypes list should exclude Wound:
   ```csharp
   private static readonly EffectType[] AvailableEffectTypes = Enum.GetValues<EffectType>()
       .Where(t => t != EffectType.Wound).ToArray();
   ```

   When confirming, build the BatchEffectConfig:
   ```csharp
   private void Confirm()
   {
       if (!IsFormValid) return;
       var state = BuildEffectState();
       var durationSeconds = GetDurationSeconds();
       var config = new BatchEffectConfig
       {
           EffectName = effectName,
           EffectType = selectedEffectType,
           Description = description,
           DurationSeconds = durationSeconds,
           DurationRounds = durationSeconds.HasValue ? (int?)(durationSeconds.Value / 3) : null,
           BehaviorStateJson = state.Serialize()
       };
       DialogService.Close(config);
   }
   ```

2. In `SelectionBar.razor`, add an "Add Effect" button in the action buttons area, between the Heal button and the visibility button. Place it after the Heal button with a pipe separator:
   ```html
   <span class="text-muted">|</span>
   <button class="btn btn-sm btn-outline-primary" @onclick="OpenBatchEffectAdd">
       <i class="bi bi-stars me-1"></i>Add Effect
   </button>
   ```

3. In `SelectionBar.razor` @code, add the `OpenBatchEffectAdd` method:
   ```csharp
   private async Task OpenBatchEffectAdd()
   {
       var result = await DialogService.OpenAsync<BatchEffectAddModal>(
           "Add Effect to Selected Characters",
           new Dictionary<string, object>
           {
               { "SelectedCount", SelectedCount }
           },
           new DialogOptions { Width = "600px", CloseDialogOnOverlayClick = true });

       if (result is BatchEffectConfig config)
       {
           await ExecuteBatchEffectAdd(config);
       }
   }
   ```

4. In `SelectionBar.razor` @code, add the `ExecuteBatchEffectAdd` method:
   ```csharp
   private async Task ExecuteBatchEffectAdd(BatchEffectConfig config)
   {
       var request = new BatchActionRequest
       {
           TableId = TableId,
           CharacterIds = SelectedCharacterIds.ToList(),
           ActionType = BatchActionType.EffectAdd,
           EffectName = config.EffectName,
           EffectType = config.EffectType,
           EffectDescription = config.Description,
           DurationSeconds = config.DurationSeconds,
           DurationRounds = config.DurationRounds,
           BehaviorStateJson = config.BehaviorStateJson
       };

       var batchResult = await BatchActionService.AddEffectAsync(request);
       await HandleBatchResult(batchResult);
   }
   ```

5. In `GmTable.razor`, update `HandleBatchActionCompleted` to handle the EffectAdd case. Add a case BEFORE the default that keeps selection intact (per CONTEXT decision):
   ```csharp
   case BatchActionType.EffectAdd:
   case BatchActionType.EffectRemove:
       // Effects: keep selection intact (GM may want to apply multiple effects)
       break;
   ```
  </action>
  <verify>`dotnet build Threa.sln` compiles successfully (excluding file-lock on running host). SelectionBar has "Add Effect" button. BatchEffectAddModal.razor exists and has template picker + form fields. GmTable HandleBatchActionCompleted has EffectAdd case.</verify>
  <done>BatchEffectAddModal provides template picker and custom effect form. SelectionBar has "Add Effect" button that opens the modal and calls AddEffectAsync. GmTable keeps selection intact after effect add. Full batch effect add flow works end-to-end.</done>
</task>

</tasks>

<verification>
1. `dotnet build GameMechanics/GameMechanics.csproj` -- 0 errors
2. `dotnet build Threa.sln` -- compiles (excluding file-lock on running host)
3. `dotnet test GameMechanics.Test/GameMechanics.Test.csproj` -- all existing tests pass
4. BatchActionType enum has 6 values: Damage, Healing, Visibility, Dismiss, EffectAdd, EffectRemove
5. BatchActionService has AddEffectAsync that creates EffectRecord per character with shared game time
6. BatchActionResult.Summary returns "Added {name} to N character(s)" for EffectAdd
7. BatchEffectAddModal has template picker, effect form, and returns BatchEffectConfig
8. SelectionBar has "Add Effect" button between Heal and visibility buttons
9. GmTable HandleBatchActionCompleted keeps selection intact for EffectAdd
</verification>

<success_criteria>
- GM can click "Add Effect" in SelectionBar to open BatchEffectAddModal
- Modal offers "From Template" (EffectTemplatePickerModal) and custom form entry
- Confirming the modal calls BatchActionService.AddEffectAsync with effect configuration
- Each selected character gets the effect with shared CreatedAt/ExpiresAt timestamps
- Stacking is handled by existing EffectList.AddEffect logic
- Result summary shows "Added {EffectName} to N character(s)"
- Selection stays intact after batch effect add
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/31-batch-effects/31-01-SUMMARY.md`
</output>
