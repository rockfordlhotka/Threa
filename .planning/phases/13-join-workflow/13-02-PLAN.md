---
phase: 13-join-workflow
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - GameMechanics/GamePlay/JoinRequestSubmitter.cs
  - GameMechanics/GamePlay/JoinRequestProcessor.cs
  - GameMechanics/GamePlay/JoinRequestInfo.cs
  - GameMechanics/GamePlay/JoinRequestList.cs
  - GameMechanics/GamePlay/PendingRequestCountFetcher.cs
autonomous: true

must_haves:
  truths:
    - "JoinRequestSubmitter validates character ownership, playability, and single-campaign constraint"
    - "JoinRequestSubmitter creates pending request and returns request ID on success"
    - "JoinRequestProcessor approves request AND attaches character to table in one operation"
    - "JoinRequestProcessor denies request by deleting it (per CONTEXT.md)"
    - "JoinRequestList can fetch by player ID or by table ID"
    - "PendingRequestCountFetcher returns count per table for badge display"
  artifacts:
    - path: "GameMechanics/GamePlay/JoinRequestSubmitter.cs"
      provides: "Command to submit join request"
      contains: "class JoinRequestSubmitter : CommandBase"
    - path: "GameMechanics/GamePlay/JoinRequestProcessor.cs"
      provides: "Command to approve/deny requests"
      contains: "class JoinRequestProcessor : CommandBase"
    - path: "GameMechanics/GamePlay/JoinRequestInfo.cs"
      provides: "Read-only info for display"
      contains: "class JoinRequestInfo : ReadOnlyBase"
    - path: "GameMechanics/GamePlay/JoinRequestList.cs"
      provides: "List of requests"
      contains: "class JoinRequestList : ReadOnlyListBase"
  key_links:
    - from: "JoinRequestSubmitter"
      to: "IJoinRequestDal.SaveRequestAsync"
      via: "data portal inject"
      pattern: "IJoinRequestDal"
    - from: "JoinRequestProcessor"
      to: "ITableDal.AddCharacterToTableAsync"
      via: "approval triggers attachment"
      pattern: "AddCharacterToTableAsync"
---

<objective>
Create the CSLA business logic layer for the join workflow: commands for submitting and processing join requests, read-only objects for displaying request information, and a count fetcher for badge display.

Purpose: Implement the state machine and validation logic that ensures characters can only be in one campaign, requests are properly validated, and approvals trigger actual table membership.

Output: JoinRequestSubmitter, JoinRequestProcessor, JoinRequestInfo, JoinRequestList, PendingRequestCountFetcher CSLA objects.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-join-workflow/13-CONTEXT.md
@.planning/phases/13-join-workflow/13-RESEARCH.md

Reference 13-01 for data layer:
@.planning/phases/13-join-workflow/13-01-SUMMARY.md (will exist when this runs)

Key existing patterns:
@GameMechanics/GamePlay/TableCharacterAttacher.cs
@GameMechanics/Player/CharacterList.cs
@GameMechanics/Player/CharacterInfo.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JoinRequestSubmitter command</name>
  <files>
    GameMechanics/GamePlay/JoinRequestSubmitter.cs
  </files>
  <action>
Create JoinRequestSubmitter.cs following TableCharacterAttacher.cs pattern:

```csharp
[Serializable]
public class JoinRequestSubmitter : CommandBase<JoinRequestSubmitter>
{
    // Properties for results
    public static readonly PropertyInfo<bool> SuccessProperty = RegisterProperty<bool>(nameof(Success));
    public bool Success { get => ReadProperty(SuccessProperty); private set => LoadProperty(SuccessProperty, value); }

    public static readonly PropertyInfo<string?> ErrorMessageProperty = RegisterProperty<string?>(nameof(ErrorMessage));
    public string? ErrorMessage { get => ReadProperty(ErrorMessageProperty); private set => LoadProperty(ErrorMessageProperty, value); }

    public static readonly PropertyInfo<Guid?> RequestIdProperty = RegisterProperty<Guid?>(nameof(RequestId));
    public Guid? RequestId { get => ReadProperty(RequestIdProperty); private set => LoadProperty(RequestIdProperty, value); }

    [Execute]
    private async Task ExecuteAsync(
        int characterId,
        Guid tableId,
        int playerId,
        [Inject] IJoinRequestDal joinRequestDal,
        [Inject] ICharacterDal characterDal,
        [Inject] ITableDal tableDal)
    {
        try
        {
            // 1. Validate character exists and belongs to player
            var character = await characterDal.GetCharacterAsync(characterId);
            if (character == null)
            {
                SetError("Character not found.");
                return;
            }
            if (character.PlayerId != playerId)
            {
                SetError("You do not own this character.");
                return;
            }
            if (!character.IsPlayable)
            {
                SetError("This character is not activated for play.");
                return;
            }

            // 2. Validate table exists
            GameTable table;
            try
            {
                table = await tableDal.GetTableAsync(tableId);
            }
            catch (NotFoundException)
            {
                SetError("Campaign not found.");
                return;
            }

            // 3. Check character not already in another campaign (JOIN-09)
            var existingTable = await tableDal.GetTableForCharacterAsync(characterId);
            if (existingTable != null)
            {
                SetError($"{character.Name} is already active in {existingTable.Name}. Leave that campaign first.");
                return;
            }

            // 4. Check for existing pending request (prevent duplicates)
            var existingRequest = await joinRequestDal.GetPendingRequestAsync(characterId, tableId);
            if (existingRequest != null)
            {
                SetError("You already have a pending request for this campaign.");
                return;
            }

            // 5. Create the join request
            var request = joinRequestDal.GetBlank();
            request.CharacterId = characterId;
            request.TableId = tableId;
            request.PlayerId = playerId;
            request.Status = JoinRequestStatus.Pending;
            request.RequestedAt = DateTime.UtcNow;

            var saved = await joinRequestDal.SaveRequestAsync(request);

            LoadProperty(SuccessProperty, true);
            LoadProperty(RequestIdProperty, saved.Id);
        }
        catch (Exception ex)
        {
            SetError($"Failed to submit join request: {ex.Message}");
        }
    }

    private void SetError(string message)
    {
        LoadProperty(SuccessProperty, false);
        LoadProperty(ErrorMessageProperty, message);
    }
}
```

Add required usings: Csla, System, System.Threading.Tasks, Threa.Dal, Threa.Dal.Dto
  </action>
  <verify>
`dotnet build GameMechanics/GameMechanics.csproj` succeeds
  </verify>
  <done>
JoinRequestSubmitter command validates character ownership, playability, single-campaign constraint, and duplicate request prevention. Creates pending request on success and returns request ID.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create JoinRequestProcessor command for approve/deny</name>
  <files>
    GameMechanics/GamePlay/JoinRequestProcessor.cs
  </files>
  <action>
Create JoinRequestProcessor.cs following TableCharacterAttacher.cs pattern:

```csharp
[Serializable]
public class JoinRequestProcessor : CommandBase<JoinRequestProcessor>
{
    public static readonly PropertyInfo<bool> SuccessProperty = RegisterProperty<bool>(nameof(Success));
    public bool Success { get => ReadProperty(SuccessProperty); private set => LoadProperty(SuccessProperty, value); }

    public static readonly PropertyInfo<string?> ErrorMessageProperty = RegisterProperty<string?>(nameof(ErrorMessage));
    public string? ErrorMessage { get => ReadProperty(ErrorMessageProperty); private set => LoadProperty(ErrorMessageProperty, value); }

    public static readonly PropertyInfo<string?> CharacterNameProperty = RegisterProperty<string?>(nameof(CharacterName));
    public string? CharacterName { get => ReadProperty(CharacterNameProperty); private set => LoadProperty(CharacterNameProperty, value); }

    [Execute]
    private async Task ExecuteAsync(
        Guid requestId,
        bool approve,
        int gameMasterId,
        [Inject] IJoinRequestDal joinRequestDal,
        [Inject] ITableDal tableDal,
        [Inject] ICharacterDal characterDal)
    {
        try
        {
            // 1. Get the request
            var request = await joinRequestDal.GetRequestAsync(requestId);
            if (request == null)
            {
                SetError("Join request not found.");
                return;
            }

            if (request.Status != JoinRequestStatus.Pending)
            {
                SetError("This request has already been processed.");
                return;
            }

            // 2. Verify GM owns the table
            var table = await tableDal.GetTableAsync(request.TableId);
            if (table.GameMasterId != gameMasterId)
            {
                SetError("You are not the Game Master of this campaign.");
                return;
            }

            // 3. Get character name for response
            var character = await characterDal.GetCharacterAsync(request.CharacterId);
            LoadProperty(CharacterNameProperty, character?.Name);

            if (approve)
            {
                // 4a. Approve: verify character still valid, then attach to table
                if (character == null)
                {
                    SetError("Character no longer exists.");
                    await joinRequestDal.DeleteRequestAsync(requestId);
                    return;
                }

                // Double-check character isn't already in another campaign
                var existingTable = await tableDal.GetTableForCharacterAsync(request.CharacterId);
                if (existingTable != null)
                {
                    SetError($"{character.Name} joined another campaign while request was pending.");
                    await joinRequestDal.DeleteRequestAsync(requestId);
                    return;
                }

                // Attach character to table
                var tableCharacter = new TableCharacter
                {
                    TableId = request.TableId,
                    CharacterId = request.CharacterId,
                    PlayerId = request.PlayerId,
                    JoinedAt = DateTime.UtcNow,
                    ConnectionStatus = ConnectionStatus.Disconnected,
                    LastActivity = DateTime.UtcNow
                };
                await tableDal.AddCharacterToTableAsync(tableCharacter);

                // Update request status
                request.Status = JoinRequestStatus.Approved;
                request.ProcessedAt = DateTime.UtcNow;
                await joinRequestDal.SaveRequestAsync(request);
            }
            else
            {
                // 4b. Deny: delete the request (per CONTEXT.md - immediate deletion)
                await joinRequestDal.DeleteRequestAsync(requestId);
            }

            LoadProperty(SuccessProperty, true);
        }
        catch (Exception ex)
        {
            SetError($"Failed to process request: {ex.Message}");
        }
    }

    private void SetError(string message)
    {
        LoadProperty(SuccessProperty, false);
        LoadProperty(ErrorMessageProperty, message);
    }
}
```
  </action>
  <verify>
`dotnet build GameMechanics/GameMechanics.csproj` succeeds
  </verify>
  <done>
JoinRequestProcessor validates GM ownership, handles approval (attaches character to table, updates status) and denial (deletes request). Returns character name for notification message.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create JoinRequestInfo, JoinRequestList, and PendingRequestCountFetcher</name>
  <files>
    GameMechanics/GamePlay/JoinRequestInfo.cs
    GameMechanics/GamePlay/JoinRequestList.cs
    GameMechanics/GamePlay/PendingRequestCountFetcher.cs
  </files>
  <action>
Create JoinRequestInfo.cs (follow CharacterInfo.cs pattern):

```csharp
[Serializable]
public class JoinRequestInfo : ReadOnlyBase<JoinRequestInfo>
{
    public static readonly PropertyInfo<Guid> IdProperty = RegisterProperty<Guid>(nameof(Id));
    public Guid Id { get => GetProperty(IdProperty); private set => LoadProperty(IdProperty, value); }

    public static readonly PropertyInfo<int> CharacterIdProperty = RegisterProperty<int>(nameof(CharacterId));
    public int CharacterId { get => GetProperty(CharacterIdProperty); private set => LoadProperty(CharacterIdProperty, value); }

    public static readonly PropertyInfo<string> CharacterNameProperty = RegisterProperty<string>(nameof(CharacterName));
    public string CharacterName { get => GetProperty(CharacterNameProperty); private set => LoadProperty(CharacterNameProperty, value); }

    public static readonly PropertyInfo<string> SpeciesProperty = RegisterProperty<string>(nameof(Species));
    public string Species { get => GetProperty(SpeciesProperty); private set => LoadProperty(SpeciesProperty, value); }

    public static readonly PropertyInfo<Guid> TableIdProperty = RegisterProperty<Guid>(nameof(TableId));
    public Guid TableId { get => GetProperty(TableIdProperty); private set => LoadProperty(TableIdProperty, value); }

    public static readonly PropertyInfo<string> TableNameProperty = RegisterProperty<string>(nameof(TableName));
    public string TableName { get => GetProperty(TableNameProperty); private set => LoadProperty(TableNameProperty, value); }

    public static readonly PropertyInfo<int> PlayerIdProperty = RegisterProperty<int>(nameof(PlayerId));
    public int PlayerId { get => GetProperty(PlayerIdProperty); private set => LoadProperty(PlayerIdProperty, value); }

    public static readonly PropertyInfo<JoinRequestStatus> StatusProperty = RegisterProperty<JoinRequestStatus>(nameof(Status));
    public JoinRequestStatus Status { get => GetProperty(StatusProperty); private set => LoadProperty(StatusProperty, value); }

    public static readonly PropertyInfo<DateTime> RequestedAtProperty = RegisterProperty<DateTime>(nameof(RequestedAt));
    public DateTime RequestedAt { get => GetProperty(RequestedAtProperty); private set => LoadProperty(RequestedAtProperty, value); }

    [FetchChild]
    private void Fetch(JoinRequest request, Character? character, GameTable? table)
    {
        Id = request.Id;
        CharacterId = request.CharacterId;
        CharacterName = character?.Name ?? "Unknown";
        Species = character?.Species ?? "";
        TableId = request.TableId;
        TableName = table?.Name ?? "Unknown";
        PlayerId = request.PlayerId;
        Status = request.Status;
        RequestedAt = request.RequestedAt;
    }
}
```

Create JoinRequestList.cs (follow CharacterList.cs pattern):

```csharp
[Serializable]
public class JoinRequestList : ReadOnlyListBase<JoinRequestList, JoinRequestInfo>
{
    /// <summary>
    /// Fetch all non-denied requests for a player.
    /// </summary>
    [Fetch]
    private async Task FetchForPlayer(
        int playerId,
        [Inject] IJoinRequestDal joinRequestDal,
        [Inject] ICharacterDal characterDal,
        [Inject] ITableDal tableDal,
        [Inject] IChildDataPortal<JoinRequestInfo> portal)
    {
        var requests = await joinRequestDal.GetRequestsByPlayerAsync(playerId);
        using (LoadListMode)
        {
            foreach (var request in requests)
            {
                var character = await characterDal.GetCharacterAsync(request.CharacterId);
                GameTable? table = null;
                try { table = await tableDal.GetTableAsync(request.TableId); } catch { }
                Add(portal.FetchChild(request, character, table));
            }
        }
    }

    /// <summary>
    /// Fetch pending requests for a table (GM view).
    /// </summary>
    [Fetch]
    private async Task FetchForTable(
        Guid tableId,
        [Inject] IJoinRequestDal joinRequestDal,
        [Inject] ICharacterDal characterDal,
        [Inject] ITableDal tableDal,
        [Inject] IChildDataPortal<JoinRequestInfo> portal)
    {
        var requests = await joinRequestDal.GetPendingRequestsForTableAsync(tableId);
        var table = await tableDal.GetTableAsync(tableId);
        using (LoadListMode)
        {
            foreach (var request in requests)
            {
                var character = await characterDal.GetCharacterAsync(request.CharacterId);
                Add(portal.FetchChild(request, character, table));
            }
        }
    }
}
```

Create PendingRequestCountFetcher.cs (simple command to get count):

```csharp
[Serializable]
public class PendingRequestCountFetcher : CommandBase<PendingRequestCountFetcher>
{
    public static readonly PropertyInfo<int> CountProperty = RegisterProperty<int>(nameof(Count));
    public int Count { get => ReadProperty(CountProperty); private set => LoadProperty(CountProperty, value); }

    [Execute]
    private async Task ExecuteAsync(
        Guid tableId,
        [Inject] IJoinRequestDal joinRequestDal)
    {
        var count = await joinRequestDal.GetPendingCountForTableAsync(tableId);
        LoadProperty(CountProperty, count);
    }
}
```
  </action>
  <verify>
`dotnet build GameMechanics/GameMechanics.csproj` succeeds
  </verify>
  <done>
JoinRequestInfo displays request with character name, species, table name, and status. JoinRequestList can fetch by player (for pending requests view) or by table (for GM review). PendingRequestCountFetcher returns count for badge display.
  </done>
</task>

</tasks>

<verification>
- `dotnet build GameMechanics/GameMechanics.csproj` completes without errors
- JoinRequestSubmitter validates all constraints per CONTEXT.md
- JoinRequestProcessor handles approve (attach) and deny (delete)
- JoinRequestInfo has all display properties
- JoinRequestList has both Fetch overloads
- PendingRequestCountFetcher returns integer count
</verification>

<success_criteria>
- Commands properly validate GM ownership and character constraints
- Approval atomically updates request status AND attaches character to table
- Denial deletes request (no "denied" status shown to player)
- List objects can be fetched from UI via data portal
- Count fetcher can be called to get badge numbers
</success_criteria>

<output>
After completion, create `.planning/phases/13-join-workflow/13-02-SUMMARY.md`
</output>
