---
phase: 11-user-profiles
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Threa.Dal/Dto/Player.cs
  - Threa.Dal/IPlayerDal.cs
  - Threa.Dal.MockDb/PlayerDal.cs
  - Threa.Dal.SqlLite/PlayerDal.cs
  - GameMechanics/GameMechanics.csproj
  - GameMechanics/Player/PlayerEdit.cs
  - GameMechanics/Player/ProfileInfo.cs
  - GameMechanics/Player/NoProfanityRule.cs
autonomous: true

must_haves:
  truths:
    - "Player DTO has ContactEmail and UseGravatar fields"
    - "PlayerEdit business object exposes editable ContactEmail and UseGravatar"
    - "ProfileInfo read-only business object fetches public profile data"
    - "Display name validation rejects profanity"
    - "Display name validation enforces 1-50 character limit"
  artifacts:
    - path: "Threa.Dal/Dto/Player.cs"
      provides: "ContactEmail and UseGravatar fields"
      contains: "ContactEmail"
    - path: "GameMechanics/Player/PlayerEdit.cs"
      provides: "Editable profile properties"
      contains: "UseGravatarProperty"
    - path: "GameMechanics/Player/ProfileInfo.cs"
      provides: "Read-only profile for public viewing"
      exports: ["ProfileInfo"]
    - path: "GameMechanics/Player/NoProfanityRule.cs"
      provides: "CSLA business rule for profanity validation"
      exports: ["NoProfanityRule"]
  key_links:
    - from: "GameMechanics/Player/PlayerEdit.cs"
      to: "GameMechanics/Player/NoProfanityRule.cs"
      via: "BusinessRules.AddRule"
      pattern: "NoProfanityRule"
    - from: "GameMechanics/Player/ProfileInfo.cs"
      to: "Threa.Dal/IPlayerDal.cs"
      via: "Fetch operation"
      pattern: "GetPlayerAsync"
---

<objective>
Extend the data layer and business objects to support user profile features including display name validation with profanity filtering, optional contact email for Gravatar, Gravatar opt-out toggle, and a read-only profile object for viewing other users.

Purpose: Establishes the data foundation for profile editing and public profile viewing. All profile UI features depend on these business objects and DTO fields.

Output: Extended Player DTO, enhanced PlayerEdit BO with profanity validation, new ProfileInfo BO for read-only public profile access.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-user-profiles/11-CONTEXT.md
@.planning/phases/11-user-profiles/11-RESEARCH.md

Key patterns from existing code:
- Threa.Dal/Dto/Player.cs - Current DTO structure
- GameMechanics/Player/PlayerEdit.cs - Current BO pattern
- GameMechanics/Player/AdminUserEdit.cs - Async business rule patterns (LastAdminProtectionRule)
- GameMechanics/Player/AdminUserInfo.cs - ReadOnlyBase pattern for read-only objects
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DTO and DAL for profile fields</name>
  <files>
    - Threa.Dal/Dto/Player.cs
    - Threa.Dal.MockDb/PlayerDal.cs
    - Threa.Dal.SqlLite/PlayerDal.cs
  </files>
  <action>
Add two new fields to Player DTO:

```csharp
// In Player.cs - add after existing fields
public string ContactEmail { get; set; } = string.Empty;  // For Gravatar (separate from Email which stores username)
public bool UseGravatar { get; set; } = true;  // Default to using Gravatar when ContactEmail provided
```

Update MockDb PlayerDal.SavePlayerAsync to persist and load these new fields:
- In the insert block where new Player is created, add: `ContactEmail = obj.ContactEmail, UseGravatar = obj.UseGravatar`
- In the update block, add: `existingPlayer.ContactEmail = obj.ContactEmail; existingPlayer.UseGravatar = obj.UseGravatar;`

SQLite PlayerDal stores Player as JSON, so it will automatically serialize the new fields. No changes needed to SQLite DAL.

Note: The existing `Email` field stores the username (legacy naming noted in codebase). `ContactEmail` is the new field for actual email address used for Gravatar.
  </action>
  <verify>
    - Build succeeds: `dotnet build Threa.sln`
    - DTO has both new fields with correct defaults
  </verify>
  <done>
    - Player DTO has ContactEmail (string, empty default) and UseGravatar (bool, true default)
    - MockDb DAL persists and loads both fields
    - SQLite DAL works with new fields via JSON serialization
  </done>
</task>

<task type="auto">
  <name>Task 2: Add profanity filter package and create NoProfanityRule</name>
  <files>
    - GameMechanics/GameMechanics.csproj
    - GameMechanics/Player/NoProfanityRule.cs
  </files>
  <action>
Add Profanity.Detector package to GameMechanics project:
```bash
dotnet add GameMechanics/GameMechanics.csproj package Profanity.Detector --version 0.1.8
```

Create NoProfanityRule.cs in GameMechanics/Player/:

```csharp
using Csla.Rules;
using Profanity.Detector;

namespace GameMechanics.Player;

/// <summary>
/// CSLA business rule that validates a string property contains no profanity.
/// Uses Profanity.Detector library which handles the Scunthorpe problem (false positives).
/// </summary>
public class NoProfanityRule : BusinessRule
{
    private readonly ProfanityFilter _filter;

    public NoProfanityRule(IPropertyInfo primaryProperty)
        : base(primaryProperty)
    {
        _filter = new ProfanityFilter();
    }

    protected override void Execute(IRuleContext context)
    {
        var value = (string?)context.InputPropertyValues[PrimaryProperty];
        if (!string.IsNullOrWhiteSpace(value))
        {
            if (_filter.ContainsProfanity(value))
            {
                context.AddErrorResult("Display name contains inappropriate content");
            }
        }
    }
}
```

The Profanity.Detector library:
- Handles the Scunthorpe problem (legitimate names with embedded words)
- Has comprehensive maintained word list
- Is .NET Standard 2.0 compatible
  </action>
  <verify>
    - Package added: `dotnet list GameMechanics/GameMechanics.csproj package | grep -i profanity`
    - Build succeeds: `dotnet build GameMechanics/GameMechanics.csproj`
  </verify>
  <done>
    - Profanity.Detector 0.1.8 installed in GameMechanics project
    - NoProfanityRule.cs created following CSLA BusinessRule pattern
    - Rule checks for profanity and adds error result if found
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance PlayerEdit with profile fields and validation</name>
  <files>
    - GameMechanics/Player/PlayerEdit.cs
  </files>
  <action>
Enhance PlayerEdit.cs:

1. Add two new properties after ImageUrl:

```csharp
public static readonly PropertyInfo<string> ContactEmailProperty = RegisterProperty<string>(nameof(ContactEmail));
public string ContactEmail
{
    get => GetProperty(ContactEmailProperty);
    set => SetProperty(ContactEmailProperty, value);
}

public static readonly PropertyInfo<bool> UseGravatarProperty = RegisterProperty<bool>(nameof(UseGravatar));
public bool UseGravatar
{
    get => GetProperty(UseGravatarProperty);
    set => SetProperty(UseGravatarProperty, value);
}
```

2. Add AddBusinessRules override for validation:

```csharp
protected override void AddBusinessRules()
{
    base.AddBusinessRules();

    // Display name validation
    BusinessRules.AddRule(new Csla.Rules.CommonRules.Required(NameProperty)
        { MessageText = "Display name is required" });
    BusinessRules.AddRule(new Csla.Rules.CommonRules.MinLength(NameProperty, 1)
        { MessageText = "Display name is required" });
    BusinessRules.AddRule(new Csla.Rules.CommonRules.MaxLength(NameProperty, 50)
        { MessageText = "Display name cannot exceed 50 characters" });
    BusinessRules.AddRule(new NoProfanityRule(NameProperty));
}
```

3. Update LoadProperties to load new fields:
```csharp
ContactEmail = data.ContactEmail;
UseGravatar = data.UseGravatar;
```

4. Update SaveAsync DTO construction to include new fields:
```csharp
ContactEmail = ContactEmail,
UseGravatar = UseGravatar
```

Note: The existing `Email` property remains read-only (private set via LoadProperty) since it contains the username. Only `ContactEmail` is editable.
  </action>
  <verify>
    - Build succeeds: `dotnet build GameMechanics/GameMechanics.csproj`
    - Tests pass: `dotnet test GameMechanics.Test/GameMechanics.Test.csproj`
  </verify>
  <done>
    - PlayerEdit has ContactEmail and UseGravatar editable properties
    - Name property has validation rules: required, 1-50 chars, no profanity
    - LoadProperties and SaveAsync handle new fields
  </done>
</task>

<task type="auto">
  <name>Task 4: Create ProfileInfo read-only business object</name>
  <files>
    - GameMechanics/Player/ProfileInfo.cs
    - Threa.Dal/IPlayerDal.cs
  </files>
  <action>
Create ProfileInfo.cs - a read-only CSLA object for viewing public profile data.

Follow the AdminUserInfo pattern (ReadOnlyBase<T> with [Fetch] operation):

```csharp
using System;
using System.Threading.Tasks;
using Csla;
using Threa.Dal;

namespace GameMechanics.Player;

/// <summary>
/// Read-only profile info for viewing any user's public profile.
/// Exposes only public-safe fields: Id, Name (display name), ContactEmail, UseGravatar.
/// </summary>
[Serializable]
public class ProfileInfo : ReadOnlyBase<ProfileInfo>
{
    public static readonly PropertyInfo<int> IdProperty = RegisterProperty<int>(nameof(Id));
    public int Id
    {
        get => GetProperty(IdProperty);
        private set => LoadProperty(IdProperty, value);
    }

    public static readonly PropertyInfo<string> NameProperty = RegisterProperty<string>(nameof(Name));
    public string Name
    {
        get => GetProperty(NameProperty);
        private set => LoadProperty(NameProperty, value);
    }

    public static readonly PropertyInfo<string> ContactEmailProperty = RegisterProperty<string>(nameof(ContactEmail));
    public string ContactEmail
    {
        get => GetProperty(ContactEmailProperty);
        private set => LoadProperty(ContactEmailProperty, value);
    }

    public static readonly PropertyInfo<bool> UseGravatarProperty = RegisterProperty<bool>(nameof(UseGravatar));
    public bool UseGravatar
    {
        get => GetProperty(UseGravatarProperty);
        private set => LoadProperty(UseGravatarProperty, value);
    }

    [Fetch]
    private async Task FetchAsync(int id, [Inject] IPlayerDal dal)
    {
        var data = await dal.GetPlayerAsync(id)
            ?? throw new InvalidOperationException($"Player {id} not found");

        Id = data.Id;
        Name = data.Name;
        ContactEmail = data.ContactEmail;
        UseGravatar = data.UseGravatar;
    }
}
```

Note: IPlayerDal already has GetPlayerAsync(int id) method, so no DAL changes needed. The ProfileInfo fetch uses the existing method.
  </action>
  <verify>
    - Build succeeds: `dotnet build GameMechanics/GameMechanics.csproj`
    - ProfileInfo.cs exists with Id, Name, ContactEmail, UseGravatar properties
    - ProfileInfo has [Fetch] attribute with async fetch operation
  </verify>
  <done>
    - ProfileInfo read-only business object created
    - Exposes public profile data: Id, Name, ContactEmail, UseGravatar
    - Uses existing IPlayerDal.GetPlayerAsync for data retrieval
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `dotnet build Threa.sln` succeeds with no errors
2. `dotnet test GameMechanics.Test/GameMechanics.Test.csproj` passes all existing tests
3. Player DTO has ContactEmail and UseGravatar fields
4. PlayerEdit exposes editable ContactEmail and UseGravatar
5. ProfileInfo read-only object can fetch public profile by player id
6. Display name validation rejects names >50 chars and profanity
</verification>

<success_criteria>
- Data layer extended with ContactEmail and UseGravatar fields
- PlayerEdit enhanced with profile properties and validation rules
- ProfileInfo read-only object created for public profile viewing
- Profanity.Detector package installed for display name validation
- All existing tests continue to pass
- Build succeeds with no warnings related to new code
</success_criteria>

<output>
After completion, create `.planning/phases/11-user-profiles/11-01-SUMMARY.md`
</output>
