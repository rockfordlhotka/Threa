---
phase: 04-gameplay-inventory-core
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - Threa/Threa.Client/Components/Pages/GamePlay/TabPlayInventory.razor
autonomous: false

must_haves:
  truths:
    - "Player can select an item by clicking its tile"
    - "Player can equip selected item by clicking an equipment slot"
    - "Player can unequip item by clicking a filled slot (with no item selected)"
    - "Cursed items cannot be unequipped (shows error message)"
    - "Auto-swap happens when equipping to filled slot (old item unequipped)"
    - "Player can drop selected item via button with confirmation"
    - "Stackable items prompt for quantity when dropping"
  artifacts:
    - path: "Threa/Threa.Client/Components/Pages/GamePlay/TabPlayInventory.razor"
      provides: "Complete inventory management with equip/unequip/drop"
      contains: "ItemManagementService"
  key_links:
    - from: "TabPlayInventory.razor"
      to: "ItemManagementService.EquipItemAsync"
      via: "equip button click"
      pattern: "itemService\\.EquipItemAsync"
    - from: "TabPlayInventory.razor"
      to: "ItemManagementService.UnequipItemAsync"
      via: "slot click unequip"
      pattern: "itemService\\.UnequipItemAsync"
    - from: "TabPlayInventory.razor"
      to: "ItemManagementService.RemoveItemFromInventoryAsync"
      via: "drop button"
      pattern: "itemService\\.RemoveItemFromInventoryAsync"
---

<objective>
Add item selection, equip/unequip functionality, and drop action to the Play page inventory tab.

Purpose: Players need to manage their equipment during gameplay - selecting items, equipping them to slots, unequipping, and dropping items they no longer need. This implements the two-step equip flow and curse-aware operations.

Output: Complete TabPlayInventory.razor with full item management capabilities including selection state, equip/unequip via ItemManagementService, and drop with confirmation dialogs.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-gameplay-inventory-core/04-CONTEXT.md
@.planning/phases/04-gameplay-inventory-core/04-RESEARCH.md
@.planning/phases/04-gameplay-inventory-core/04-01-SUMMARY.md

# Existing code
@Threa/Threa.Client/Components/Pages/GamePlay/TabPlayInventory.razor
@GameMechanics/Items/ItemManagementService.cs
@Threa.Dal/Dto/EquipmentSlotExtensions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Item Selection and Equip/Unequip Functionality</name>
  <files>Threa/Threa.Client/Components/Pages/GamePlay/TabPlayInventory.razor</files>
  <action>
Add selection state and equip/unequip operations:

1. Add selection state fields:
   ```csharp
   private Guid? selectedItemId;
   private CharacterItem? selectedItem;
   private string? errorMessage;
   private string? successMessage;
   ```

2. Add SelectItem method for inventory tile clicks:
   ```csharp
   private void SelectItem(CharacterItem item)
   {
       // Toggle selection
       if (selectedItemId == item.Id)
       {
           selectedItemId = null;
           selectedItem = null;
       }
       else
       {
           selectedItemId = item.Id;
           selectedItem = item;
       }
       ClearMessages();
   }

   private void ClearMessages()
   {
       errorMessage = null;
       successMessage = null;
   }
   ```

3. Update inventory tile div to:
   - Add @onclick="() => SelectItem(item)"
   - Add class "selected" when selectedItemId == item.Id
   - Add CSS for selected state:
     ```css
     .inventory-tile.selected {
         border-color: var(--bs-primary);
         border-width: 2px;
         background: rgba(var(--bs-primary-rgb), 0.1);
     }
     ```

4. Add OnEquipmentSlotClick handler:
   ```csharp
   private async Task OnEquipmentSlotClick(EquipmentSlot slot)
   {
       ClearMessages();

       // If no item selected, check if we should unequip
       if (selectedItem == null)
       {
           var equippedItem = GetEquippedItem(slot);
           if (equippedItem != null)
           {
               await UnequipItem(equippedItem.Id);
           }
           return;
       }

       // Check slot compatibility (use template.EquipmentSlot)
       var template = GetTemplate(selectedItem.ItemTemplateId);
       if (template != null && !IsSlotCompatible(template.EquipmentSlot, slot))
       {
           errorMessage = $"This item cannot be equipped in the {slot.GetDisplayName()} slot.";
           return;
       }

       // Check if target slot has a cursed item (auto-swap would fail)
       var existingItem = GetEquippedItem(slot);
       if (existingItem != null && !itemService.CanUnequipItem(Character!, existingItem.Id))
       {
           errorMessage = $"Cannot swap: {GetItemName(existingItem)} is cursed and cannot be unequipped.";
           return;
       }

       // Equip the item (service handles auto-swap)
       var result = await itemService.EquipItemAsync(Character!, selectedItem.Id, slot);
       if (!result.Success)
       {
           errorMessage = result.ErrorMessage;
           return;
       }

       successMessage = $"Equipped {GetItemName(selectedItem)} to {slot.GetDisplayName()}.";
       selectedItem = null;
       selectedItemId = null;
       await LoadItemsAsync();
       await NotifyCharacterChanged();
   }
   ```

5. Add UnequipItem method:
   ```csharp
   private async Task UnequipItem(Guid itemId)
   {
       var result = await itemService.UnequipItemAsync(Character!, itemId);
       if (!result.Success)
       {
           errorMessage = result.ErrorMessage;  // Will show curse blocking message
           return;
       }

       var itemName = GetItemName(inventoryItems?.FirstOrDefault(i => i.Id == itemId));
       successMessage = $"Unequipped {itemName}.";
       await LoadItemsAsync();
       await NotifyCharacterChanged();
   }
   ```

6. Add helper methods:
   ```csharp
   private ItemTemplate? GetTemplate(int templateId)
   {
       return templateCache?.GetValueOrDefault(templateId);
   }

   private string GetItemName(CharacterItem? item)
   {
       if (item == null) return "item";
       return item.CustomName ?? GetTemplate(item.ItemTemplateId)?.Name ?? "item";
   }

   private static bool IsSlotCompatible(EquipmentSlot itemSlot, EquipmentSlot targetSlot)
   {
       // Weapons can go in MainHand, OffHand, or TwoHand
       if (itemSlot == EquipmentSlot.MainHand || itemSlot == EquipmentSlot.OffHand || itemSlot == EquipmentSlot.TwoHand)
       {
           return targetSlot == EquipmentSlot.MainHand ||
                  targetSlot == EquipmentSlot.OffHand ||
                  targetSlot == EquipmentSlot.TwoHand;
       }
       // Rings can go in any finger slot
       if (itemSlot.IsFingerSlot())
       {
           return targetSlot.IsFingerSlot();
       }
       // EquipmentSlot.None means item can go anywhere appropriate
       if (itemSlot == EquipmentSlot.None)
       {
           return true;
       }
       // Otherwise must match
       return itemSlot == targetSlot;
   }
   ```

7. Add NotifyCharacterChanged callback:
   ```csharp
   [Parameter]
   public EventCallback OnCharacterChanged { get; set; }

   private async Task NotifyCharacterChanged()
   {
       if (OnCharacterChanged.HasDelegate)
       {
           await OnCharacterChanged.InvokeAsync();
       }
   }
   ```

8. Update equipment slot markup to be clickable:
   - Add @onclick="() => OnEquipmentSlotClick(slot)" to each slot div
   - Add CSS class "clickable" and cursor: pointer
   - Add visual feedback when slot is a valid target for selected item
   ```css
   .equipment-slot.clickable {
       cursor: pointer;
   }
   .equipment-slot.clickable:hover {
       background: #f0f0f0;
   }
   .equipment-slot.valid-target {
       background: rgba(var(--bs-success-rgb), 0.1);
       border-color: var(--bs-success);
   }
   ```

9. Add message display area at top of component:
   ```razor
   @if (!string.IsNullOrEmpty(errorMessage))
   {
       <div class="alert alert-danger alert-dismissible fade show" role="alert">
           @errorMessage
           <button type="button" class="btn-close" @onclick="() => errorMessage = null"></button>
       </div>
   }
   @if (!string.IsNullOrEmpty(successMessage))
   {
       <div class="alert alert-success alert-dismissible fade show" role="alert">
           @successMessage
           <button type="button" class="btn-close" @onclick="() => successMessage = null"></button>
       </div>
   }
   ```

10. Add IsValidTarget helper for visual feedback on slots:
    ```csharp
    private bool IsValidTarget(EquipmentSlot slot)
    {
        if (selectedItem == null) return false;
        var template = GetTemplate(selectedItem.ItemTemplateId);
        if (template == null) return false;
        return IsSlotCompatible(template.EquipmentSlot, slot);
    }
    ```
  </action>
  <verify>
Build succeeds: `dotnet build Threa.sln`
Test manually:
1. Click item tile - should highlight as selected
2. Click same tile again - should deselect
3. With item selected, click valid equipment slot - item should equip
4. With equipped item, click its slot (no selection) - item should unequip
5. Try to unequip cursed item (if test data has one) - should show error
  </verify>
  <done>
Item selection works with toggle behavior. Clicking equipment slot with item selected equips the item. Clicking occupied slot with no selection unequips. Error messages display for invalid operations and curse blocking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Drop Action with Confirmation Dialogs</name>
  <files>Threa/Threa.Client/Components/Pages/GamePlay/TabPlayInventory.razor</files>
  <action>
Add drop functionality with confirmation:

1. Add Radzen DialogService injection:
   ```razor
   @inject DialogService DialogService
   ```

2. Add action buttons section below the inventory grid (or in a toolbar area):
   ```razor
   <div class="inventory-actions mt-3 p-2 border-top">
       <button class="btn btn-outline-danger"
               disabled="@(selectedItem == null)"
               @onclick="ConfirmDropItem">
           <i class="bi bi-trash"></i> Drop
       </button>
       @if (selectedItem != null)
       {
           <span class="ms-3 text-muted">
               Selected: <strong>@GetItemName(selectedItem)</strong>
               @if (selectedItem.IsEquipped)
               {
                   <span class="badge bg-success ms-1">Equipped</span>
               }
           </span>
       }
   </div>
   ```

3. Add ConfirmDropItem method:
   ```csharp
   private async Task ConfirmDropItem()
   {
       if (selectedItem == null) return;
       ClearMessages();

       var itemName = GetItemName(selectedItem);
       var template = GetTemplate(selectedItem.ItemTemplateId);

       // Check if item can be dropped (curse check)
       if (!itemService.CanDropItem(Character!, selectedItem.Id))
       {
           errorMessage = itemService.GetDropBlockReason(Character!, selectedItem.Id)
               ?? "This item cannot be dropped.";
           return;
       }

       // For stackable items with quantity > 1, show quantity dialog
       if (template?.IsStackable == true && selectedItem.StackSize > 1)
       {
           await ShowDropQuantityDialog();
           return;
       }

       // Single item or non-stackable - simple confirmation
       var confirmed = await DialogService.Confirm(
           $"Are you sure you want to drop {itemName}? This cannot be undone.",
           "Drop Item",
           new ConfirmOptions
           {
               OkButtonText = "Drop",
               CancelButtonText = "Cancel"
           });

       if (confirmed == true)
       {
           await DropItem(selectedItem.Id);
       }
   }
   ```

4. Add ShowDropQuantityDialog method:
   ```csharp
   private int dropQuantity = 1;
   private bool showDropQuantityDialog = false;

   private async Task ShowDropQuantityDialog()
   {
       dropQuantity = selectedItem!.StackSize;  // Default to all
       showDropQuantityDialog = true;
       StateHasChanged();
   }

   private async Task ConfirmDropQuantity()
   {
       if (selectedItem == null || dropQuantity <= 0) return;

       showDropQuantityDialog = false;

       if (dropQuantity >= selectedItem.StackSize)
       {
           // Drop entire stack
           await DropItem(selectedItem.Id);
       }
       else
       {
           // Reduce quantity (update item, don't delete)
           await DropPartialStack(selectedItem.Id, dropQuantity);
       }
   }

   private void CancelDropQuantity()
   {
       showDropQuantityDialog = false;
       dropQuantity = 1;
   }
   ```

5. Add drop quantity dialog markup (simple modal):
   ```razor
   @if (showDropQuantityDialog && selectedItem != null)
   {
       <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5);">
           <div class="modal-dialog modal-sm">
               <div class="modal-content">
                   <div class="modal-header">
                       <h5 class="modal-title">Drop @GetItemName(selectedItem)</h5>
                       <button type="button" class="btn-close" @onclick="CancelDropQuantity"></button>
                   </div>
                   <div class="modal-body">
                       <p>How many do you want to drop?</p>
                       <div class="mb-3">
                           <label class="form-label">Quantity (max: @selectedItem.StackSize)</label>
                           <input type="number" class="form-control"
                                  @bind="dropQuantity"
                                  min="1"
                                  max="@selectedItem.StackSize" />
                       </div>
                   </div>
                   <div class="modal-footer">
                       <button type="button" class="btn btn-secondary" @onclick="CancelDropQuantity">Cancel</button>
                       <button type="button" class="btn btn-danger" @onclick="ConfirmDropQuantity">
                           Drop @dropQuantity
                       </button>
                   </div>
               </div>
           </div>
       </div>
   }
   ```

6. Add DropItem method:
   ```csharp
   private async Task DropItem(Guid itemId)
   {
       var item = inventoryItems?.FirstOrDefault(i => i.Id == itemId);
       var itemName = GetItemName(item);

       var result = await itemService.RemoveItemFromInventoryAsync(Character!, itemId);
       if (!result.Success)
       {
           errorMessage = result.ErrorMessage;
           return;
       }

       successMessage = $"Dropped {itemName}.";
       selectedItem = null;
       selectedItemId = null;
       await LoadItemsAsync();
       await NotifyCharacterChanged();
   }
   ```

7. Add DropPartialStack method:
   ```csharp
   private async Task DropPartialStack(Guid itemId, int quantity)
   {
       var item = inventoryItems?.FirstOrDefault(i => i.Id == itemId);
       if (item == null) return;

       var itemName = GetItemName(item);

       // Update the item's stack size
       item.StackSize -= quantity;
       await itemDal.UpdateItemAsync(item);

       successMessage = $"Dropped {quantity}x {itemName}.";
       selectedItem = null;
       selectedItemId = null;
       await LoadItemsAsync();
       await NotifyCharacterChanged();
   }
   ```

8. Add CSS for action buttons area:
   ```css
   .inventory-actions {
       background: var(--color-bg-tertiary, #f8f9fa);
       border-radius: 0 0 4px 4px;
   }
   ```

9. CRITICAL: Per CONTEXT.md, "Drop and Destroy are the same action - items removed permanently (no recovery)"
   - Only show "Drop" button (not separate Destroy)
   - The action is permanent

10. Per CONTEXT.md, cursed items block both unequip AND drop
    - If item is equipped, RemoveItemFromInventoryAsync checks both unequip curse and drop curse
    - The service handles this, just display the error message
  </action>
  <verify>
Build succeeds: `dotnet build Threa.sln`
Test manually:
1. Select a non-stackable item, click Drop - confirmation dialog appears
2. Confirm drop - item removed from inventory
3. Select stackable item with quantity > 1 - quantity dialog appears
4. Set quantity less than total - partial drop works
5. Set quantity equal to total - entire item removed
6. Try to drop cursed item - error message appears
  </verify>
  <done>
Drop button enabled when item selected. Confirmation dialog for single items. Quantity prompt for stackable items. Partial stack drop reduces quantity. Full stack drop removes item. Curse blocking shows error message.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete inventory management on Play page: grid display, equipment slots, selection, equip, unequip, and drop with confirmation</what-built>
  <how-to-verify>
1. Start the app: `dotnet run --project Threa/Threa`
2. Navigate to http://localhost:5181/play
3. Select a character that has items in inventory
4. Click "Inventory" tab

Test inventory display:
- Verify items show as grid tiles with icons and names
- Verify equipped items have green border and "E" badge
- Verify equipment slots panel shows all slots by category
- Verify equipped items show in both grid AND slot panel

Test equip flow:
- Click an unequipped item tile - should highlight with blue border
- Click a valid equipment slot - item should equip
- Verify item now shows "E" badge and appears in slot
- Verify success message appears

Test unequip flow:
- With no item selected, click an occupied equipment slot
- Item should unequip (no badge, slot shows "Empty")
- Verify success message

Test auto-swap:
- Equip item A to Main Hand
- Select item B (another weapon)
- Click Main Hand slot
- Item B should equip, Item A should unequip automatically

Test drop:
- Select an item, click "Drop" button
- Confirm dialog should appear
- Click "Drop" to confirm
- Item should be removed from inventory

Test stackable drop:
- If you have stackable items (ammo, potions)
- Select one with quantity > 1
- Click Drop - quantity dialog should appear
- Drop partial amount - quantity should reduce
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Run `dotnet build Threa.sln` - must succeed
2. Run app and test complete equip/unequip/drop flow
3. Verify cursed items cannot be unequipped or dropped (if test data includes cursed items)
4. Verify auto-swap works correctly
5. Verify partial stack drop for stackable items
6. Verify UI feedback (messages, selection state, badges)
</verification>

<success_criteria>
- INV-09 satisfied: Player can equip item from inventory to appropriate equipment slot
- INV-10 satisfied: Player can unequip item from equipment slot back to inventory
- INV-11 satisfied: Player can drop item from inventory (permanently removes from character)
- INV-12 satisfied: Player can destroy item (same as drop per CONTEXT.md)
- Two-step equip flow works as specified
- Cursed items properly blocked
- Confirmation dialogs appear for drop action
- Quantity prompt for stackable items
</success_criteria>

<output>
After completion, create `.planning/phases/04-gameplay-inventory-core/04-02-SUMMARY.md`
</output>
