---
phase: 21-stat-editing
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - Threa/Threa.Client/Components/Shared/CharacterDetailSheet.razor
  - Threa/Threa.Client/Components/Shared/CharacterDetailModal.razor
autonomous: true

must_haves:
  truths:
    - "GM can view and modify skill levels for all character skills"
    - "GM sees inline validation warnings for skill levels outside typical range"
    - "GM cannot save if any skill level is below minimum (0)"
    - "AP Max updates when skill levels change"
    - "Changes trigger real-time dashboard updates"
  artifacts:
    - path: "Threa/Threa.Client/Components/Shared/CharacterDetailSheet.razor"
      provides: "Skill editing with validation, unified save"
      contains: "skill.Level"
    - path: "Threa/Threa.Client/Components/Shared/CharacterDetailModal.razor"
      provides: "Edit mode coordination between tabs"
      contains: "isEditMode"
  key_links:
    - from: "CharacterDetailSheet.razor"
      to: "CharacterEdit.Skills"
      via: "binding to skill.Level"
      pattern: "@bind=\"skill.Level\""
    - from: "CharacterDetailModal.razor"
      to: "CharacterDetailSheet.razor"
      via: "IsEditMode parameter"
      pattern: "IsEditMode="
    - from: "CharacterDetailModal.razor"
      to: "CharacterDetailGmActions.razor"
      via: "OnEditStatsRequested callback"
      pattern: "OnEditStatsRequested="
---

<objective>
Add skill level editing to CharacterDetailSheet alongside attribute editing, and wire CharacterDetailModal for edit mode coordination.

Purpose: Enable GM to modify character skill levels through the same edit mode, with AP Max recalculation and validation. Complete the stat editing phase by providing unified attribute + skill editing in a single edit session, with the "Edit Stats" button from GM Actions tab switching to Sheet tab and entering edit mode.

Output: CharacterDetailSheet with skill editing in the Skills card, AP Max preview during editing, validation for skill levels, combined save that persists all stat changes, and CharacterDetailModal wiring for edit mode coordination.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v1.3-ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-stat-editing/21-CONTEXT.md
@.planning/phases/21-stat-editing/21-RESEARCH.md
@.planning/phases/21-stat-editing/21-01-SUMMARY.md

Key existing files (modified by Plan 01):
@Threa/Threa.Client/Components/Shared/CharacterDetailSheet.razor (now has edit mode infrastructure from Plan 01)
@Threa/Threa.Client/Components/Shared/CharacterDetailGmActions.razor (now has OnEditStatsRequested callback from Plan 01)
@Threa/Threa.Client/Components/Shared/CharacterDetailModal.razor (needs wiring)
@GameMechanics/SkillEdit.cs (Level property, TotalSkillLevels)
@GameMechanics/SkillEditList.cs (TotalSkillLevels calculation)
@GameMechanics/ActionPoints.cs (CalculateMax uses TotalSkillLevels / 10)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add skill editing to CharacterDetailSheet</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailSheet.razor</files>
  <action>
Add skill level editing to the Skills card in CharacterDetailSheet. Plan 01 has already created the edit mode infrastructure (IsEditMode, editingCharacter, isProcessing, errorMessage, etc.).

1. Replace the Skills card (right column) with edit-aware version:
```razor
<!-- Right Column: Skills -->
<div class="col-md-4">
    <div class="card" style="max-height: 500px; overflow-y: auto;">
        <div class="card-header d-flex justify-content-between align-items-center">
            <strong>Skills</strong>
            @if (!IsEditMode)
            {
                <button class="btn btn-sm btn-outline-primary" @onclick="EnterEditMode">
                    <i class="bi bi-pencil"></i>
                </button>
            }
        </div>
        <div class="card-body">
            @if (IsEditMode && editingCharacter != null)
            {
                <!-- AP Max preview -->
                <div class="alert alert-info py-1 mb-2 small">
                    <strong>AP Max:</strong> @editingCharacter.ActionPoints.Max
                    <span class="text-muted">(Total Levels: @editingCharacter.Skills.TotalSkillLevels)</span>
                </div>

                @foreach (var skillGroup in editingCharacter.Skills.GroupBy(s => s.PrimaryAttribute).OrderBy(g => g.Key))
                {
                    <h6 class="text-muted small mt-2 mb-1">@skillGroup.Key</h6>
                    @foreach (var skill in skillGroup.OrderBy(s => s.Name))
                    {
                        <div class="row mb-1 align-items-center">
                            <div class="col-7">
                                <span class="small">@skill.Name</span>
                            </div>
                            <div class="col-5">
                                <input type="number"
                                       class="form-control form-control-sm @GetSkillValidationClass(skill.Level)"
                                       @bind="skill.Level"
                                       @bind:event="onchange"
                                       min="0" />
                            </div>
                        </div>
                        @if (skill.Level < 0)
                        {
                            <div class="text-danger small mb-1"><i class="bi bi-x-circle me-1"></i>Minimum level is 0</div>
                        }
                        else if (skill.Level > 10)
                        {
                            <div class="text-warning small mb-1"><i class="bi bi-exclamation-triangle me-1"></i>Above typical max (10)</div>
                        }
                    }
                }
            }
            else
            {
                @foreach (var skillGroup in (Character?.Skills ?? Enumerable.Empty<SkillEdit>()).GroupBy(s => s.PrimaryAttribute).OrderBy(g => g.Key))
                {
                    <h6 class="text-muted small mt-2">@skillGroup.Key</h6>
                    @foreach (var skill in skillGroup.OrderBy(s => s.Name))
                    {
                        @if (skill.Level > 0)
                        {
                            <div class="d-flex justify-content-between small">
                                <span>@skill.Name</span>
                                <span>@skill.Level</span>
                            </div>
                        }
                    }
                }
            }
        </div>
    </div>
</div>
```

2. Add skill validation helper method:
```csharp
private string GetSkillValidationClass(int level)
{
    if (level < 0) return "is-invalid";
    if (level > 10) return "border-warning";
    return "";
}
```

3. Update CanSave() to include skill validation (rename to CanSaveAll if needed):
```csharp
private bool CanSaveAll()
{
    if (editingCharacter == null) return false;

    // Validate attributes
    if (editingCharacter.AttributeList.Any(a => a.BaseValue < 1))
        return false;

    // Validate skills
    if (editingCharacter.Skills.Any(s => s.Level < 0))
        return false;

    return true;
}
```

4. Update SaveAttributeChanges() to SaveAllChanges() to handle both attributes and skills:
```csharp
private async Task SaveAllChanges()
{
    if (editingCharacter == null || !CanSaveAll()) return;
    isProcessing = true;
    errorMessage = null;

    try
    {
        // Cap health pools at new max if needed (attributes may have changed)
        if (editingCharacter.Fatigue.Value > editingCharacter.Fatigue.BaseValue)
            editingCharacter.Fatigue.Value = editingCharacter.Fatigue.BaseValue;
        if (editingCharacter.Vitality.Value > editingCharacter.Vitality.BaseValue)
            editingCharacter.Vitality.Value = editingCharacter.Vitality.BaseValue;

        // Cap AP at new max if needed (skills may have changed AP max)
        if (editingCharacter.ActionPoints.Available > editingCharacter.ActionPoints.Max)
            editingCharacter.ActionPoints.Available = editingCharacter.ActionPoints.Max;

        await characterPortal.UpdateAsync(editingCharacter);

        // Publish update for real-time dashboard refresh
        await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
        {
            CharacterId = CharacterId,
            UpdateType = CharacterUpdateType.StatsChanged,
            CampaignId = TableId.ToString(),
            SourceId = "GM",
            Description = "Stats modified"
        });

        successMessage = "Stats saved successfully";
        await OnCharacterUpdated.InvokeAsync();

        // Exit edit mode after successful save
        editingCharacter = null;
        IsEditMode = false;
        await IsEditModeChanged.InvokeAsync(false);
    }
    catch (Exception ex)
    {
        errorMessage = $"Failed to save: {ex.Message}";
    }
    finally
    {
        isProcessing = false;
    }
}
```

5. Update the Attributes card Save button to call SaveAllChanges instead of SaveAttributeChanges, and use CanSaveAll:
```razor
<button class="btn btn-primary btn-sm flex-grow-1"
        @onclick="SaveAllChanges"
        disabled="@(!CanSaveAll() || isProcessing)">
    <i class="bi bi-check-lg me-1"></i>Save All
</button>
```

Note: Remove or keep the old CanSave/SaveAttributeChanges methods as needed - only SaveAllChanges/CanSaveAll should be used.
  </action>
  <verify>
Build compiles. Run app, open GM dashboard, click character, go to Sheet tab:
1. Pencil button visible on Skills card header
2. Click pencil: inputs appear for ALL skills (not just leveled ones)
3. AP Max preview shows at top of skills list with total levels
4. Change a skill level: AP Max preview updates (business rules fire on change)
5. Set skill level to -1: red validation, Save disabled
6. Set skill level to 12: yellow warning, Save still enabled
7. Save persists all changes (both attributes and skills if edited)
8. Dashboard updates in real-time after save
  </verify>
  <done>GM can edit skill levels with AP Max preview. Validation blocks save for invalid values. Combined save handles both attribute and skill changes. Real-time updates publish on save.</done>
</task>

<task type="auto">
  <name>Task 2: Wire CharacterDetailModal to support edit mode coordination</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailModal.razor</files>
  <action>
Update CharacterDetailModal to pass required parameters to CharacterDetailSheet and coordinate edit mode. Plan 01 has already added CharacterId, TableId, IsEditMode, IsEditModeChanged, and OnCharacterUpdated parameters to CharacterDetailSheet, and OnEditStatsRequested to CharacterDetailGmActions.

1. Add edit mode state tracking:
```csharp
private bool isEditMode;
```

2. Update CharacterDetailSheet usage to pass required parameters:
```razor
<!-- In the tabs switch/case for "Character Sheet" -->
<CharacterDetailSheet Character="@character"
                       CharacterId="@CharacterId"
                       TableId="@TableId"
                       IsEditMode="@isEditMode"
                       IsEditModeChanged="@((bool val) => { isEditMode = val; StateHasChanged(); })"
                       OnCharacterUpdated="@HandleCharacterUpdated" />
```

3. Wire up OnEditStatsRequested on CharacterDetailGmActions:
```razor
<CharacterDetailGmActions Character="@character"
                          CharacterId="@CharacterId"
                          TableId="@TableId"
                          OnCharacterRemoved="@HandleCharacterRemoved"
                          OnCharacterUpdated="@HandleCharacterUpdated"
                          OnEditStatsRequested="@SwitchToSheetAndEdit" />
```

4. Add method to switch tab and trigger edit mode:
```csharp
private void SwitchToSheetAndEdit()
{
    selectedTab = "Character Sheet";
    isEditMode = true;
    // CharacterDetailSheet's OnParametersSetAsync will detect IsEditMode=true
    // and call LoadEditingCharacter() to fetch the character for editing
    StateHasChanged();
}
```

5. Add or update method to handle character updates:
```csharp
private async Task HandleCharacterUpdated()
{
    // Refresh the character data
    character = await characterPortal.FetchAsync(CharacterId);
    StateHasChanged();
}
```

Note: Ensure CharacterId and TableId are available as parameters or properties in CharacterDetailModal. They should already be passed from the parent component (Play.razor).
  </action>
  <verify>
Build compiles. Run app:
1. Open GM dashboard, click character
2. From GM Actions tab, click "Edit Stats" button
3. Modal switches to Character Sheet tab AND enters edit mode automatically (inputs visible, not read-only view)
4. After saving, character data refreshes in modal
5. Dashboard cards update in real-time when stats are saved
  </verify>
  <done>CharacterDetailModal coordinates edit mode state. "Edit Stats" button in GM Actions switches to Sheet tab and enters edit mode. CharacterDetailSheet's OnParametersSetAsync handles the IsEditMode=true change by loading editingCharacter. Character refresh works after save.</done>
</task>

</tasks>

<verification>
1. Build: `dotnet build Threa.sln` passes without errors
2. Run app and verify complete stat editing flow:
   - Open GM dashboard, select a character
   - GM Actions tab shows "Edit Stats" card with button
   - Click "Edit Stats" -> switches to Sheet tab in edit mode
   - OR: Go to Sheet tab, click pencil on Attributes or Skills card
   - Edit mode shows:
     - Attribute inputs with effective value badges
     - ALL skill inputs (not just leveled skills)
     - AP Max preview with total skill levels
     - FAT/VIT max preview
   - Validation:
     - Attribute < 1: red, save disabled
     - Attribute > 14: yellow warning
     - Skill < 0: red, save disabled
     - Skill > 10: yellow warning
   - Save persists all changes
   - Dashboard updates in real-time
   - Cancel reverts all changes
3. Test health pool capping:
   - Edit character with FAT 15/15
   - Reduce END so FAT max becomes 13
   - Save -> FAT current should cap at 13
4. Test AP capping:
   - Edit character with AP at max
   - Reduce total skill levels so AP max decreases
   - Save -> AP available should cap at new max
</verification>

<success_criteria>
- GM can edit all skill levels through edit mode
- AP Max preview shows during editing and updates as skill levels change
- Validation warnings appear for skill levels < 0 (blocks save) or > 10 (warning only)
- Combined save handles both attribute and skill changes
- Health pools cap at new max if reduced
- AP caps at new max if skills reduced
- CharacterUpdateMessage published on save
- Dashboard updates in real-time
- "Edit Stats" button in GM Actions switches to Sheet tab and enters edit mode (via OnParametersSetAsync)
- Cancel reverts all unsaved changes
</success_criteria>

<output>
After completion, create `.planning/phases/21-stat-editing/21-02-SUMMARY.md`
</output>
