---
phase: 21-stat-editing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Threa/Threa.Client/Components/Shared/CharacterDetailSheet.razor
autonomous: true

must_haves:
  truths:
    - "GM can view and modify skill levels for all character skills"
    - "GM sees inline validation warnings for skill levels outside typical range"
    - "GM cannot save if any skill level is below minimum (0)"
    - "AP Max updates when skill levels change"
    - "Changes trigger real-time dashboard updates"
  artifacts:
    - path: "Threa/Threa.Client/Components/Shared/CharacterDetailSheet.razor"
      provides: "Skill editing with validation, unified save"
      contains: "skill.Level"
  key_links:
    - from: "CharacterDetailSheet.razor"
      to: "CharacterEdit.Skills"
      via: "binding to skill.Level"
      pattern: "@bind=\"skill.Level\""
---

<objective>
Add skill level editing to CharacterDetailSheet alongside attribute editing.

Purpose: Enable GM to modify character skill levels through the same edit mode, with AP Max recalculation and validation. Complete the stat editing phase by providing unified attribute + skill editing in a single edit session.

Output: CharacterDetailSheet with skill editing in the Skills card, AP Max preview during editing, validation for skill levels, and combined save that persists all stat changes.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v1.3-ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-stat-editing/21-CONTEXT.md
@.planning/phases/21-stat-editing/21-RESEARCH.md

Key existing files (will be modified by Plan 01 first, but this plan can run in parallel):
@Threa/Threa.Client/Components/Shared/CharacterDetailSheet.razor
@GameMechanics/SkillEdit.cs (Level property, TotalSkillLevels)
@GameMechanics/SkillEditList.cs (TotalSkillLevels calculation)
@GameMechanics/ActionPoints.cs (CalculateMax uses TotalSkillLevels / 10)

Note: This plan can run in parallel with Plan 01. If Plan 01 runs first, integrate skill editing into the existing edit mode. If this plan runs first, create the edit mode for skills only and Plan 01 will extend it for attributes.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add skill editing to CharacterDetailSheet</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailSheet.razor</files>
  <action>
Add skill level editing to the Skills card in CharacterDetailSheet:

1. If edit mode infrastructure doesn't exist yet (Plan 01 hasn't run), add the required dependencies and state:
```csharp
// Only add these if not already present from Plan 01
@inject IDataPortal<CharacterEdit> characterPortal
@inject ITimeEventPublisher TimeEventPublisher

[Parameter] public int CharacterId { get; set; }
[Parameter] public Guid TableId { get; set; }
[Parameter] public bool IsEditMode { get; set; }
[Parameter] public EventCallback<bool> IsEditModeChanged { get; set; }
[Parameter] public EventCallback OnCharacterUpdated { get; set; }

private CharacterEdit? editingCharacter;
private bool isProcessing;
private string? errorMessage;
private string? successMessage;
```

2. Replace the Skills card (right column) with edit-aware version:
```razor
<!-- Right Column: Skills -->
<div class="col-md-4">
    <div class="card" style="max-height: 500px; overflow-y: auto;">
        <div class="card-header d-flex justify-content-between align-items-center">
            <strong>Skills</strong>
            @if (!IsEditMode)
            {
                <button class="btn btn-sm btn-outline-primary" @onclick="EnterEditMode">
                    <i class="bi bi-pencil"></i>
                </button>
            }
        </div>
        <div class="card-body">
            @if (IsEditMode && editingCharacter != null)
            {
                <!-- AP Max preview -->
                <div class="alert alert-info py-1 mb-2 small">
                    <strong>AP Max:</strong> @editingCharacter.ActionPoints.Max
                    <span class="text-muted">(Total Levels: @editingCharacter.Skills.TotalSkillLevels)</span>
                </div>

                @foreach (var skillGroup in editingCharacter.Skills.GroupBy(s => s.PrimaryAttribute).OrderBy(g => g.Key))
                {
                    <h6 class="text-muted small mt-2 mb-1">@skillGroup.Key</h6>
                    @foreach (var skill in skillGroup.OrderBy(s => s.Name))
                    {
                        <div class="row mb-1 align-items-center">
                            <div class="col-7">
                                <span class="small">@skill.Name</span>
                            </div>
                            <div class="col-5">
                                <input type="number"
                                       class="form-control form-control-sm @GetSkillValidationClass(skill.Level)"
                                       @bind="skill.Level"
                                       @bind:event="onchange"
                                       min="0" />
                            </div>
                        </div>
                        @if (skill.Level < 0)
                        {
                            <div class="text-danger small mb-1"><i class="bi bi-x-circle me-1"></i>Minimum level is 0</div>
                        }
                        else if (skill.Level > 10)
                        {
                            <div class="text-warning small mb-1"><i class="bi bi-exclamation-triangle me-1"></i>Above typical max (10)</div>
                        }
                    }
                }

                <!-- Error/Success messages (only show if Attributes card doesn't have them) -->
                @if (!string.IsNullOrEmpty(errorMessage))
                {
                    <div class="alert alert-danger py-1 mt-2 small">@errorMessage</div>
                }

                <!-- Save/Cancel buttons for Skills section -->
                <div class="d-flex gap-2 mt-3 sticky-bottom bg-white pt-2">
                    <button class="btn btn-primary btn-sm flex-grow-1"
                            @onclick="SaveAllChanges"
                            disabled="@(!CanSaveAll() || isProcessing)">
                        <i class="bi bi-check-lg me-1"></i>Save All
                    </button>
                    <button class="btn btn-secondary btn-sm flex-grow-1"
                            @onclick="CancelEdit"
                            disabled="@isProcessing">
                        Cancel
                    </button>
                </div>
            }
            else
            {
                @foreach (var skillGroup in (Character?.Skills ?? Enumerable.Empty<SkillEdit>()).GroupBy(s => s.PrimaryAttribute).OrderBy(g => g.Key))
                {
                    <h6 class="text-muted small mt-2">@skillGroup.Key</h6>
                    @foreach (var skill in skillGroup.OrderBy(s => s.Name))
                    {
                        @if (skill.Level > 0)
                        {
                            <div class="d-flex justify-content-between small">
                                <span>@skill.Name</span>
                                <span>@skill.Level</span>
                            </div>
                        }
                    }
                }
            }
        </div>
    </div>
</div>
```

3. Add skill validation helper:
```csharp
private string GetSkillValidationClass(int level)
{
    if (level < 0) return "is-invalid";
    if (level > 10) return "border-warning";
    return "";
}
```

4. Update CanSave to include skill validation (rename to CanSaveAll if attributes also being validated):
```csharp
private bool CanSaveAll()
{
    if (editingCharacter == null) return false;

    // Validate attributes (if Plan 01 has run)
    if (editingCharacter.AttributeList.Any(a => a.BaseValue < 1))
        return false;

    // Validate skills
    if (editingCharacter.Skills.Any(s => s.Level < 0))
        return false;

    return true;
}
```

5. Update/create save method to handle both attributes and skills:
```csharp
private async Task SaveAllChanges()
{
    if (editingCharacter == null || !CanSaveAll()) return;
    isProcessing = true;
    errorMessage = null;

    try
    {
        // Cap health pools at new max if needed (attributes may have changed)
        if (editingCharacter.Fatigue.Value > editingCharacter.Fatigue.BaseValue)
            editingCharacter.Fatigue.Value = editingCharacter.Fatigue.BaseValue;
        if (editingCharacter.Vitality.Value > editingCharacter.Vitality.BaseValue)
            editingCharacter.Vitality.Value = editingCharacter.Vitality.BaseValue;

        // Cap AP at new max if needed (skills may have changed AP max)
        if (editingCharacter.ActionPoints.Available > editingCharacter.ActionPoints.Max)
            editingCharacter.ActionPoints.Available = editingCharacter.ActionPoints.Max;

        await characterPortal.UpdateAsync(editingCharacter);

        // Publish update for real-time dashboard refresh
        await TimeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
        {
            CharacterId = CharacterId,
            UpdateType = CharacterUpdateType.StatsChanged,
            CampaignId = TableId.ToString(),
            SourceId = "GM",
            Description = "Stats modified"
        });

        successMessage = "Stats saved successfully";
        await OnCharacterUpdated.InvokeAsync();

        // Exit edit mode after successful save
        editingCharacter = null;
        IsEditMode = false;
        await IsEditModeChanged.InvokeAsync(false);
    }
    catch (Exception ex)
    {
        errorMessage = $"Failed to save: {ex.Message}";
    }
    finally
    {
        isProcessing = false;
    }
}
```

6. If EnterEditMode doesn't exist yet, add it:
```csharp
private async Task EnterEditMode()
{
    try
    {
        editingCharacter = await characterPortal.FetchAsync(CharacterId);
        IsEditMode = true;
        await IsEditModeChanged.InvokeAsync(true);
        errorMessage = null;
        successMessage = null;
    }
    catch (Exception ex)
    {
        errorMessage = $"Failed to load character: {ex.Message}";
    }
}

private async Task CancelEdit()
{
    editingCharacter = null;
    IsEditMode = false;
    await IsEditModeChanged.InvokeAsync(false);
    errorMessage = null;
    successMessage = null;
}
```

Note: If Plan 01 has already run, integrate this skill editing into the existing edit mode. Remove duplicate Save/Cancel buttons from Attributes card if both plans have run - use a single set of buttons at the bottom of the modal or in a shared location.
  </action>
  <verify>
Build compiles. Run app, open GM dashboard, click character, go to Sheet tab:
1. Pencil button visible on Skills card header
2. Click pencil: inputs appear for ALL skills (not just leveled ones)
3. AP Max preview shows at top of skills list with total levels
4. Change a skill level: AP Max preview updates (business rules fire on change)
5. Set skill level to -1: red validation, Save disabled
6. Set skill level to 12: yellow warning, Save still enabled
7. Save persists all changes (both attributes and skills if edited)
8. Dashboard updates in real-time after save
  </verify>
  <done>GM can edit skill levels with AP Max preview. Validation blocks save for invalid values. Combined save handles both attribute and skill changes. Real-time updates publish on save.</done>
</task>

<task type="auto">
  <name>Task 2: Wire CharacterDetailModal to support edit mode coordination</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailModal.razor</files>
  <action>
Update CharacterDetailModal to pass required parameters to CharacterDetailSheet and coordinate edit mode:

1. Add edit mode state tracking:
```csharp
private bool isEditMode;
```

2. Update CharacterDetailSheet usage to pass required parameters:
```razor
<!-- In the tabs switch/case for "Character Sheet" -->
<CharacterDetailSheet Character="@character"
                       CharacterId="@CharacterId"
                       TableId="@TableId"
                       IsEditMode="@isEditMode"
                       IsEditModeChanged="@((bool val) => { isEditMode = val; StateHasChanged(); })"
                       OnCharacterUpdated="@HandleCharacterUpdated" />
```

3. If CharacterDetailGmActions has OnEditStatsRequested, wire it up:
```razor
<CharacterDetailGmActions Character="@character"
                          CharacterId="@CharacterId"
                          TableId="@TableId"
                          OnCharacterRemoved="@HandleCharacterRemoved"
                          OnCharacterUpdated="@HandleCharacterUpdated"
                          OnEditStatsRequested="@SwitchToSheetAndEdit" />
```

4. Add method to switch tab and trigger edit:
```csharp
private async Task SwitchToSheetAndEdit()
{
    selectedTab = "Character Sheet";
    isEditMode = true;
    // The CharacterDetailSheet will fetch the character when it sees IsEditMode=true
    // Trigger a re-fetch by invoking the edit mode flow
    StateHasChanged();
}
```

5. Add method to handle character updates (if not already present):
```csharp
private async Task HandleCharacterUpdated()
{
    // Refresh the character data
    character = await characterPortal.FetchAsync(CharacterId);
    StateHasChanged();
}
```

Note: Ensure CharacterId and TableId parameters are available. If not, they should already be passed to CharacterDetailModal from the parent component.
  </action>
  <verify>
Build compiles. Run app:
1. Open GM dashboard, click character
2. From GM Actions tab, click "Edit Stats" button
3. Modal switches to Character Sheet tab AND enters edit mode automatically
4. After saving, character data refreshes in modal
5. Dashboard cards update in real-time when stats are saved
  </verify>
  <done>CharacterDetailModal coordinates edit mode state. "Edit Stats" button in GM Actions switches to Sheet tab and enters edit mode. Character refresh works after save.</done>
</task>

</tasks>

<verification>
1. Build: `dotnet build Threa.sln` passes without errors
2. Run app and verify complete stat editing flow:
   - Open GM dashboard, select a character
   - GM Actions tab shows "Edit Stats" card with button
   - Click "Edit Stats" -> switches to Sheet tab in edit mode
   - OR: Go to Sheet tab, click pencil on Attributes or Skills card
   - Edit mode shows:
     - Attribute inputs with effective value badges
     - ALL skill inputs (not just leveled skills)
     - AP Max preview with total skill levels
     - FAT/VIT max preview
   - Validation:
     - Attribute < 1: red, save disabled
     - Attribute > 14: yellow warning
     - Skill < 0: red, save disabled
     - Skill > 10: yellow warning
   - Save persists all changes
   - Dashboard updates in real-time
   - Cancel reverts all changes
3. Test health pool capping:
   - Edit character with FAT 15/15
   - Reduce END so FAT max becomes 13
   - Save -> FAT current should cap at 13
4. Test AP capping:
   - Edit character with AP at max
   - Reduce total skill levels so AP max decreases
   - Save -> AP available should cap at new max
</verification>

<success_criteria>
- GM can edit all skill levels through edit mode
- AP Max preview shows during editing and updates as skill levels change
- Validation warnings appear for skill levels < 0 (blocks save) or > 10 (warning only)
- Combined save handles both attribute and skill changes
- Health pools cap at new max if reduced
- AP caps at new max if skills reduced
- CharacterUpdateMessage published on save
- Dashboard updates in real-time
- "Edit Stats" button in GM Actions switches to Sheet tab in edit mode
- Cancel reverts all unsaved changes
</success_criteria>

<output>
After completion, create `.planning/phases/21-stat-editing/21-02-SUMMARY.md`
</output>
