---
phase: 19-effect-management
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - GameMechanics/EffectTemplate.cs
  - GameMechanics/EffectTemplateList.cs
  - GameMechanics/Effects/Behaviors/GenericEffectBehavior.cs
autonomous: true

must_haves:
  truths:
    - "EffectTemplate CSLA object can fetch templates from DAL"
    - "EffectTemplateList provides collection of templates with filtering"
    - "GenericEffectBehavior applies EffectState modifiers to character"
  artifacts:
    - path: "GameMechanics/EffectTemplate.cs"
      provides: "CSLA ReadOnlyBase for effect templates"
      contains: "class EffectTemplate : ReadOnlyBase<EffectTemplate>"
    - path: "GameMechanics/EffectTemplateList.cs"
      provides: "CSLA ReadOnlyListBase for template collections"
      contains: "class EffectTemplateList : ReadOnlyListBase<EffectTemplateList, EffectTemplate>"
    - path: "GameMechanics/Effects/Behaviors/GenericEffectBehavior.cs"
      provides: "IEffectBehavior for user-created effects"
      contains: "class GenericEffectBehavior : IEffectBehavior"
  key_links:
    - from: "GameMechanics/EffectTemplate.cs"
      to: "IEffectTemplateDal"
      via: "Fetch operation"
      pattern: "IEffectTemplateDal.*dal"
    - from: "GameMechanics/Effects/Behaviors/GenericEffectBehavior.cs"
      to: "EffectState"
      via: "GetAttributeModifiers/GetAbilityScoreModifiers"
      pattern: "EffectState\\.Deserialize"
---

<objective>
Create CSLA business objects for effect templates and a generic effect behavior that applies EffectState modifiers.

Purpose: Enables the UI layer to fetch and display effect templates through the standard CSLA data portal pattern. The GenericEffectBehavior provides modifier calculation for GM-created custom effects.

Output: EffectTemplate.cs and EffectTemplateList.cs CSLA objects, GenericEffectBehavior.cs implementing IEffectBehavior.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-effect-management/19-CONTEXT.md
@.planning/phases/19-effect-management/19-01-SUMMARY.md (when available)
@GameMechanics/EffectRecord.cs (existing CSLA pattern)
@GameMechanics/Effects/IEffectBehavior.cs (behavior interface)
@GameMechanics/Effects/Behaviors/WoundBehavior.cs (reference behavior)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EffectTemplate CSLA ReadOnlyBase</name>
  <files>GameMechanics/EffectTemplate.cs</files>
  <action>
Create EffectTemplate class extending ReadOnlyBase<EffectTemplate>.

Properties (all read-only with PropertyInfo pattern):
- `int Id` - Template ID
- `string Name` - Template name
- `EffectType EffectType` - Effect category (use Threa.Dal.Dto.EffectType)
- `string? Description` - Effect description
- `string? IconName` - Icon identifier
- `string? Color` - Display color
- `int? DefaultDurationValue` - Default duration amount
- `DurationType DurationType` - Duration type enum
- `string? StateJson` - Serialized EffectState
- `string? Tags` - Comma-separated tags
- `bool IsSystem` - Whether built-in template

Add computed property:
- `EffectState State` - Deserializes StateJson on access (with caching)
- `string[] TagList` - Splits Tags into array

Data portal operations:
- `[Fetch]` - Load from EffectTemplateDto

Follow patterns from existing CSLA objects in codebase. Use LoadProperty for all setters.
  </action>
  <verify>
Build succeeds: `dotnet build GameMechanics/GameMechanics.csproj`
  </verify>
  <done>
EffectTemplate CSLA object exists with all properties and Fetch operation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EffectTemplateList CSLA ReadOnlyListBase</name>
  <files>GameMechanics/EffectTemplateList.cs</files>
  <action>
Create EffectTemplateList class extending ReadOnlyListBase<EffectTemplateList, EffectTemplate>.

Data portal operations:
- `[Fetch]` - Fetch all active templates using IEffectTemplateDal.GetAllTemplatesAsync()
- `[Fetch]` with EffectType parameter - Filter by type using GetTemplatesByTypeAsync()
- `[Fetch]` with string parameter - Search by term using SearchTemplatesAsync()

Use IChildDataPortal<EffectTemplate> to create child objects from DTOs.

Factory methods (static):
- `public static async Task<EffectTemplateList> GetAllAsync(IDataPortal<EffectTemplateList> portal)`
- `public static async Task<EffectTemplateList> GetByTypeAsync(IDataPortal<EffectTemplateList> portal, EffectType type)`
- `public static async Task<EffectTemplateList> SearchAsync(IDataPortal<EffectTemplateList> portal, string searchTerm)`

Follow existing list patterns in codebase.
  </action>
  <verify>
Build succeeds: `dotnet build GameMechanics/GameMechanics.csproj`
  </verify>
  <done>
EffectTemplateList exists with all fetch operations and factory methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create GenericEffectBehavior for custom effects</name>
  <files>GameMechanics/Effects/Behaviors/GenericEffectBehavior.cs</files>
  <action>
Create GenericEffectBehavior implementing IEffectBehavior.

This behavior handles Buff, Debuff, and Condition effect types using EffectState modifiers.

Implement interface methods:

**EffectType:** Return EffectType.Buff (this behavior handles multiple types via registration)

**OnAdding:** Return EffectAddResult with Outcome = Add (allow stacking by default)

**OnApply:** No immediate effect (modifiers are continuous)

**OnTick:**
- Deserialize BehaviorState to EffectState
- Apply FatDamagePerTick/VitDamagePerTick to character.Fatigue.PendingDamage/character.Vitality.PendingDamage
- Apply FatHealingPerTick/VitHealingPerTick similarly
- Return EffectTickResult.Continue

**OnExpire:** No cleanup needed

**OnRemove:** No cleanup needed

**GetAttributeModifiers:**
- Deserialize BehaviorState to EffectState
- If state.AttributeModifiers contains the queried attributeName, yield EffectModifier with that value
- Source should be effect.Name

**GetAbilityScoreModifiers:**
- Deserialize BehaviorState to EffectState
- If state.ASModifier is set, yield EffectModifier with that value (applies to all checks)
- If state.SkillModifiers contains the queried skillName, yield EffectModifier with that value
- Source should be effect.Name

**GetSuccessValueModifiers:** Return empty (no SV modifiers for generic effects)

Register in EffectBehaviorFactory for EffectType.Buff, EffectType.Debuff, and EffectType.Condition (unless those types already have dedicated behaviors - check first and only register for types without behaviors).
  </action>
  <verify>
Build succeeds: `dotnet build GameMechanics/GameMechanics.csproj`
  </verify>
  <done>
GenericEffectBehavior exists and is registered in EffectBehaviorFactory. Modifiers from EffectState are applied correctly.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` completes without errors
2. EffectTemplate can be fetched via data portal (verify pattern matches other CSLA objects)
3. EffectTemplateList fetches all templates
4. GenericEffectBehavior is registered in EffectBehaviorFactory
</verification>

<success_criteria>
- EffectTemplate provides read-only access to template data via CSLA pattern
- EffectTemplateList supports filtering by type and search
- GenericEffectBehavior correctly applies attribute, skill, and AS modifiers
- Per-tick damage/healing works in OnTick
</success_criteria>

<output>
After completion, create `.planning/phases/19-effect-management/19-02-SUMMARY.md`
</output>
