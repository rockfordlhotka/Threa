---
phase: 19-effect-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - GameMechanics/Effects/EffectState.cs
  - Threa.Dal/Dto/EffectTemplateDto.cs
  - Threa.Dal/IEffectTemplateDal.cs
  - Threa.Dal.MockDb/EffectTemplateDal.cs
  - Threa.Dal.SqlLite/EffectTemplateDal.cs
  - Threa/Threa/Program.cs
autonomous: true

must_haves:
  truths:
    - "EffectState can serialize/deserialize modifiers for attributes and skills"
    - "Effect templates can be persisted and retrieved from database"
    - "Templates support all four duration types (rounds, turns, real-time, permanent)"
  artifacts:
    - path: "GameMechanics/Effects/EffectState.cs"
      provides: "JSON-serializable state for generic effects with modifiers"
      contains: "class EffectState"
    - path: "Threa.Dal/Dto/EffectTemplateDto.cs"
      provides: "DTO for effect template persistence"
      contains: "class EffectTemplateDto"
    - path: "Threa.Dal/IEffectTemplateDal.cs"
      provides: "DAL interface for template CRUD"
      exports: ["IEffectTemplateDal"]
  key_links:
    - from: "Threa.Dal.SqlLite/EffectTemplateDal.cs"
      to: "IEffectTemplateDal"
      via: "interface implementation"
      pattern: "class EffectTemplateDal : IEffectTemplateDal"
---

<objective>
Create the data foundation for effect templates - the EffectState model for storing effect modifiers as JSON, and the DAL layer for persisting effect templates.

Purpose: Establishes the data model and persistence layer that all effect management UI will depend on. Without this foundation, effects cannot store modifiers or be saved as reusable templates.

Output: EffectState.cs with modifier serialization, EffectTemplateDto, IEffectTemplateDal interface, and MockDb/SQLite implementations.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-effect-management/19-CONTEXT.md
@.planning/phases/19-effect-management/19-RESEARCH.md
@GameMechanics/Effects/Behaviors/WoundBehavior.cs (WoundState pattern)
@Threa.Dal/IItemDal.cs (IItemTemplateDal pattern)
@Threa.Dal/Dto/EffectDefinition.cs (existing effect structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EffectState class for generic effect modifiers</name>
  <files>GameMechanics/Effects/EffectState.cs</files>
  <action>
Create EffectState class modeled after WoundState but generalized for all effect types.

Include properties:
- `string? Name` - Effect name override
- `string? Description` - Description override
- `string? IconName` - Icon for display
- `string? Color` - Color for display (hex or CSS class)
- `Dictionary<string, int>? AttributeModifiers` - Attribute name to modifier value (e.g., {"STR": 2, "DEX": -1})
- `Dictionary<string, int>? SkillModifiers` - Skill name to modifier value
- `int? ASModifier` - Global ability score modifier (applies to all checks)
- `int? FatDamagePerTick` - FAT damage per tick (for poisons, burns)
- `int? VitDamagePerTick` - VIT damage per tick
- `int? FatHealingPerTick` - FAT healing per tick (for regeneration)
- `int? VitHealingPerTick` - VIT healing per tick
- `List<string>? BehaviorTags` - Tags like ["modifier", "end-of-round-trigger", "narrative"]
- `string? CustomData` - Freeform JSON for effect-specific data

Add methods:
- `string Serialize()` - JSON serialization
- `static EffectState Deserialize(string? json)` - JSON deserialization with null safety
- `bool HasModifiers` - Returns true if any modifier is set
- `int GetAttributeModifier(string attrName)` - Get modifier for attribute, 0 if not set
- `int GetSkillModifier(string skillName)` - Get modifier for skill, 0 if not set

Use System.Text.Json for serialization. Follow existing WoundState patterns for null handling.
  </action>
  <verify>
Build succeeds: `dotnet build GameMechanics/GameMechanics.csproj`
  </verify>
  <done>
EffectState class exists with all modifier properties and serialization methods. Can serialize round-trip without data loss.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EffectTemplate DTO and DAL interface</name>
  <files>
Threa.Dal/Dto/EffectTemplateDto.cs
Threa.Dal/IEffectTemplateDal.cs
  </files>
  <action>
**EffectTemplateDto.cs:**

Create DTO class with properties:
- `int Id` - Primary key (0 for new templates)
- `string Name` - Template name (required)
- `EffectType EffectType` - Effect category
- `string? Description` - What this effect does
- `string? IconName` - Icon identifier
- `string? Color` - Display color
- `int? DefaultDurationValue` - Default duration amount
- `DurationType DurationType` - Duration type (Rounds, Turns, Minutes, Hours, Days, Permanent)
- `string? StateJson` - Serialized EffectState with modifiers
- `string? Tags` - Comma-separated tags for organization/filtering
- `bool IsSystem` - True for built-in templates that can't be deleted
- `bool IsActive` - Soft delete flag
- `DateTime CreatedAt` - Creation timestamp
- `DateTime? UpdatedAt` - Last update timestamp

Note: DurationType enum may need to be added to Threa.Dal.Dto if not present. Add if needed:
```csharp
public enum DurationType { Rounds = 0, Turns = 1, Minutes = 2, Hours = 3, Days = 4, Permanent = 5 }
```

**IEffectTemplateDal.cs:**

Create interface with methods:
- `Task<List<EffectTemplateDto>> GetAllTemplatesAsync()` - All active templates
- `Task<List<EffectTemplateDto>> GetTemplatesByTypeAsync(EffectType type)` - Filter by effect type
- `Task<List<EffectTemplateDto>> SearchTemplatesAsync(string searchTerm)` - Search by name/tags
- `Task<EffectTemplateDto?> GetTemplateAsync(int id)` - Single template by ID
- `Task<EffectTemplateDto> SaveTemplateAsync(EffectTemplateDto template)` - Create or update
- `Task DeleteTemplateAsync(int id)` - Soft delete (set IsActive = false)

Model after IItemTemplateDal pattern.
  </action>
  <verify>
Build succeeds: `dotnet build Threa.Dal/Threa.Dal.csproj`
  </verify>
  <done>
EffectTemplateDto exists with all properties. IEffectTemplateDal interface exists with CRUD methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement MockDb and SQLite DAL for effect templates</name>
  <files>
Threa.Dal.MockDb/EffectTemplateDal.cs
Threa.Dal.SqlLite/EffectTemplateDal.cs
Threa/Threa/Program.cs
  </files>
  <action>
**MockDb EffectTemplateDal:**

Implement IEffectTemplateDal with in-memory List<EffectTemplateDto> storage.
- Initialize with 5-7 seed templates for common effects:
  - "Stunned" (Condition) - ASModifier: -4, BehaviorTags: ["condition", "end-of-turn-remove"]
  - "Blessed" (Buff) - ASModifier: +2, Duration: 10 rounds
  - "Poisoned" (Poison) - FatDamagePerTick: 2, VitDamagePerTick: 1, Duration: 5 rounds
  - "Haste" (Buff) - AttributeModifiers: {"DEX": 2}, Duration: 3 rounds
  - "Weakened" (Debuff) - AttributeModifiers: {"STR": -2}, Duration: 5 rounds
  - "Regenerating" (Buff) - FatHealingPerTick: 1, VitHealingPerTick: 1, Duration: 10 rounds
- Auto-increment ID on save
- Thread-safe operations not required (single-user mock)

**SQLite EffectTemplateDal:**

Implement IEffectTemplateDal with SQLite persistence.
- Create table if not exists on first access:
```sql
CREATE TABLE IF NOT EXISTS EffectTemplates (
  Id INTEGER PRIMARY KEY AUTOINCREMENT,
  Name TEXT NOT NULL,
  EffectType INTEGER NOT NULL,
  Description TEXT,
  IconName TEXT,
  Color TEXT,
  DefaultDurationValue INTEGER,
  DurationType INTEGER NOT NULL DEFAULT 0,
  StateJson TEXT,
  Tags TEXT,
  IsSystem INTEGER NOT NULL DEFAULT 0,
  IsActive INTEGER NOT NULL DEFAULT 1,
  CreatedAt TEXT NOT NULL,
  UpdatedAt TEXT
)
```
- Use existing SQLite connection patterns from other Dal.SqlLite implementations
- Seed same templates as MockDb on empty table

**Program.cs:**

Register both DAL implementations in DI:
- MockDb: `services.AddSingleton<IEffectTemplateDal, MockDb.EffectTemplateDal>()`
- SQLite: `services.AddScoped<IEffectTemplateDal, SqlLite.EffectTemplateDal>()`

Find the existing DAL registration section and add alongside ItemTemplateDal registration.
  </action>
  <verify>
Build succeeds: `dotnet build Threa.sln`
Run app and verify no startup errors related to DI.
  </verify>
  <done>
Both MockDb and SQLite implementations exist and compile. DI registration added. Seed templates initialized in both implementations.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Threa.sln` completes without errors
2. EffectState serializes and deserializes correctly (verify in a quick test or debugger)
3. IEffectTemplateDal is registered in DI
4. Seed templates exist in both implementations
</verification>

<success_criteria>
- EffectState class supports all modifier types specified in CONTEXT.md
- EffectTemplateDto captures all template properties including duration types
- DAL interface provides full CRUD operations
- Both MockDb and SQLite implementations work identically
- Seed templates provide realistic test data
</success_criteria>

<output>
After completion, create `.planning/phases/19-effect-management/19-01-SUMMARY.md`
</output>
