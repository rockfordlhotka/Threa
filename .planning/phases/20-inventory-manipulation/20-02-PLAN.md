---
phase: 20-inventory-manipulation
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor
autonomous: true

must_haves:
  truths:
    - "GM can add items from template library to character inventory via Add Item button"
    - "GM is prompted for quantity when adding stackable items"
    - "GM can remove items from inventory via dropdown menu on each item"
    - "GM can equip unequipped items via dropdown menu"
    - "GM can unequip equipped items via dropdown menu"
    - "GM can modify quantity of stackable items via dropdown menu"
    - "GM can edit character currency (pp, gp, sp, cp) inline"
    - "Inventory and currency changes publish CharacterUpdateMessage for real-time dashboard updates"
    - "Success/error feedback displayed inline in inventory view"
  artifacts:
    - path: "Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor"
      provides: "Interactive inventory management with GM actions"
      min_lines: 300
  key_links:
    - from: "CharacterDetailInventory.razor"
      to: "ItemManagementService"
      via: "AddItemToInventoryAsync, RemoveItemFromInventoryAsync, EquipItemAsync, UnequipItemAsync"
      pattern: "itemManagementService\\.(Add|Remove|Equip|Unequip)"
    - from: "CharacterDetailInventory.razor"
      to: "ITimeEventPublisher"
      via: "PublishCharacterUpdateAsync"
      pattern: "timeEventPublisher\\.PublishCharacterUpdateAsync"
    - from: "CharacterDetailInventory.razor"
      to: "ItemTemplatePickerModal"
      via: "DialogService.OpenAsync<ItemTemplatePickerModal>"
      pattern: "DialogService\\.OpenAsync<ItemTemplatePickerModal>"
    - from: "CharacterDetailInventory.razor"
      to: "IDataPortal<CharacterEdit>"
      via: "characterPortal.FetchAsync for fresh state"
      pattern: "characterPortal\\.FetchAsync"
---

<objective>
Enhance CharacterDetailInventory with full GM manipulation capabilities including add/remove/equip/unequip items, quantity editing, and currency editing.

Purpose: Transform the read-only inventory view into an interactive GM tool for direct inventory manipulation during gameplay, completing requirements INVT-01 through INVT-08.

Output: Enhanced CharacterDetailInventory.razor with action menus, inline operations, currency editing, and real-time update publishing.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-inventory-manipulation/20-RESEARCH.md
@.planning/phases/20-inventory-manipulation/20-CONTEXT.md

# File to modify
@Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor

# Pattern references
@Threa/Threa.Client/Components/Shared/CharacterDetailEffects.razor
@Threa/Threa.Client/Components/Shared/EffectManagementModal.razor

# Core services
@GameMechanics/Items/ItemManagementService.cs
@GameMechanics/Messaging/ITimeEventPublisher.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add service injections and new parameters</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor</files>
  <action>
Add required injections and parameters to existing CharacterDetailInventory.razor.

**Add injections (after existing itemDal, templateDal):**
```razor
@inject ItemManagementService itemManagementService
@inject ITimeEventPublisher timeEventPublisher
@inject IDataPortal<CharacterEdit> characterPortal
@inject DialogService DialogService
```

**Add parameters (after existing Character parameter):**
```csharp
[Parameter]
public int CharacterId { get; set; }

[Parameter]
public Guid TableId { get; set; }
```

**Add state fields (after existing isLoading):**
```csharp
private bool isProcessing = false;
private string? feedbackMessage;
private string feedbackClass = "";
private string feedbackIcon = "";

// Currency editing state
private bool isEditingCurrency = false;
private int editPlatinum, editGold, editSilver, editCopper;

// Quantity editing state
private Guid? editingQuantityItemId = null;
private int editingQuantityValue = 0;
```

**Add feedback helper methods:**
```csharp
private void ShowFeedback(string message, string alertClass, string icon)
{
    feedbackMessage = message;
    feedbackClass = alertClass;
    feedbackIcon = icon;
    StateHasChanged();
}

private void ClearFeedback()
{
    feedbackMessage = null;
}
```
  </action>
  <verify>File compiles with all new injections and parameters</verify>
  <done>CharacterDetailInventory has all required service injections and parameter declarations</done>
</task>

<task type="auto">
  <name>Task 2: Add item operations and context menu</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor</files>
  <action>
Transform the inventory display into interactive GM tool with action menus.

**1. Add feedback alert at top of component (after opening div):**
```razor
@if (!string.IsNullOrEmpty(feedbackMessage))
{
    <div class="alert @feedbackClass alert-dismissible fade show mb-3" role="alert">
        <i class="bi @feedbackIcon me-1"></i>@feedbackMessage
        <button type="button" class="btn-close" @onclick="ClearFeedback"></button>
    </div>
}
```

**2. Add "Add Item" button to Inventory card header:**
Change the Inventory card header from:
```razor
<div class="card-header bg-primary text-white"><strong>Inventory</strong></div>
```
To:
```razor
<div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
    <strong>Inventory</strong>
    <button class="btn btn-sm btn-light" @onclick="OpenAddItemModal" disabled="@isProcessing">
        <i class="bi bi-plus-lg me-1"></i>Add Item
    </button>
</div>
```

**3. Update inventory-tile to include dropdown menu:**
Replace the existing inventory-tile div with:
```razor
<div class="inventory-tile position-relative">
    <div class="dropdown position-absolute" style="top: 2px; right: 2px;">
        <button class="btn btn-sm p-0 text-muted" data-bs-toggle="dropdown" style="line-height: 1;">
            <i class="bi bi-three-dots-vertical"></i>
        </button>
        <ul class="dropdown-menu dropdown-menu-end">
            @if (CanEquip(item))
            {
                <li><button class="dropdown-item" @onclick="() => EquipItem(item)" disabled="@isProcessing">
                    <i class="bi bi-box-arrow-in-up me-2"></i>Equip
                </button></li>
            }
            @if (IsStackable(item))
            {
                <li><button class="dropdown-item" @onclick="() => StartEditQuantity(item)" disabled="@isProcessing">
                    <i class="bi bi-hash me-2"></i>Set Quantity
                </button></li>
            }
            <li><hr class="dropdown-divider"></li>
            <li><button class="dropdown-item text-danger" @onclick="() => RemoveItem(item)" disabled="@isProcessing">
                <i class="bi bi-trash me-2"></i>Remove
            </button></li>
        </ul>
    </div>

    @if (editingQuantityItemId == item.Id)
    {
        <div class="quantity-edit-overlay">
            <input type="number" class="form-control form-control-sm" style="width: 60px;"
                   @bind="editingQuantityValue" min="1" max="@GetMaxStackSize(item)" />
            <div class="btn-group btn-group-sm mt-1">
                <button class="btn btn-success btn-sm" @onclick="() => SaveQuantity(item)">
                    <i class="bi bi-check"></i>
                </button>
                <button class="btn btn-secondary btn-sm" @onclick="CancelEditQuantity">
                    <i class="bi bi-x"></i>
                </button>
            </div>
        </div>
    }
    else
    {
        <div class="item-icon">@GetItemIcon(item)</div>
        <div class="item-name" title="@GetItemName(item)">@GetItemName(item)</div>
        @if (item.StackSize > 1)
        {
            <div class="item-quantity">x@item.StackSize</div>
        }
    }
</div>
```

**4. Update Equipment section to add unequip action:**
In the equipment slot display, change the equipped item display from:
```razor
<span>@GetItemName(equipped)</span>
```
To:
```razor
<div class="d-flex align-items-center gap-1">
    <span class="flex-grow-1">@GetItemName(equipped)</span>
    <button class="btn btn-sm btn-link text-danger p-0"
            @onclick="() => UnequipItem(equipped)"
            disabled="@isProcessing"
            title="Unequip">
        <i class="bi bi-x-circle"></i>
    </button>
</div>
```

**5. Add item operation methods:**
```csharp
private async Task OpenAddItemModal()
{
    var selectedTemplate = await DialogService.OpenAsync<ItemTemplatePickerModal>(
        "Select Item to Add",
        null,
        new DialogOptions { Width = "900px", Height = "600px", CloseDialogOnOverlayClick = true });

    if (selectedTemplate is ItemTemplateInfo template)
    {
        await AddItemFromTemplate(template);
    }
}

private async Task AddItemFromTemplate(ItemTemplateInfo template)
{
    // Get full template for IsStackable check
    var fullTemplate = await templateDal.GetTemplateAsync(template.Id);

    int quantity = 1;
    if (fullTemplate.IsStackable)
    {
        // Prompt for quantity
        var quantityResult = await DialogService.OpenAsync<QuantityPrompt>(
            $"Add {template.Name}",
            new Dictionary<string, object> { { "MaxQuantity", fullTemplate.MaxStackSize } },
            new DialogOptions { Width = "300px" });

        if (quantityResult is int qty && qty > 0)
            quantity = qty;
        else
            return; // User cancelled
    }

    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);

        var newItem = new CharacterItem
        {
            Id = Guid.NewGuid(),
            ItemTemplateId = template.Id,
            OwnerCharacterId = CharacterId,
            ContainerItemId = null,
            StackSize = quantity,
            IsEquipped = false,
            EquippedSlot = EquipmentSlot.None,
            CreatedAt = DateTime.UtcNow
        };

        var result = await itemManagementService.AddItemToInventoryAsync(character, newItem);

        if (result.Success)
        {
            await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.InventoryChanged,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"Added {quantity}x {template.Name}"
            });

            ShowFeedback($"Added {quantity}x {template.Name}", "alert-success", "bi-check-circle");
            await LoadItemsAsync();
        }
        else
        {
            ShowFeedback(result.ErrorMessage!, "alert-danger", "bi-exclamation-circle");
        }
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}

private async Task RemoveItem(CharacterItem item)
{
    var template = templates?.GetValueOrDefault(item.ItemTemplateId);
    var needsConfirmation = item.IsEquipped || (template?.Rarity >= ItemRarity.Rare);

    if (needsConfirmation)
    {
        var confirmed = await DialogService.Confirm(
            $"Remove {GetItemName(item)}?",
            "Confirm Removal",
            new ConfirmOptions { OkButtonText = "Remove", CancelButtonText = "Cancel" });

        if (confirmed != true) return;
    }

    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);

        var blockReason = itemManagementService.GetDropBlockReason(character, item.Id);
        if (blockReason != null)
        {
            ShowFeedback($"Cannot remove: {blockReason}", "alert-warning", "bi-exclamation-triangle");
            return;
        }

        var result = await itemManagementService.RemoveItemFromInventoryAsync(character, item.Id);

        if (result.Success)
        {
            await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.InventoryChanged,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"Removed {GetItemName(item)}"
            });

            ShowFeedback($"Removed {GetItemName(item)}", "alert-success", "bi-check-circle");
            await LoadItemsAsync();
        }
        else
        {
            ShowFeedback(result.ErrorMessage!, "alert-danger", "bi-exclamation-circle");
        }
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}

private async Task EquipItem(CharacterItem item)
{
    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);
        var template = templates?.GetValueOrDefault(item.ItemTemplateId);

        if (template == null)
        {
            ShowFeedback("Item template not found", "alert-danger", "bi-exclamation-circle");
            return;
        }

        var targetSlot = template.EquipmentSlot;
        if (targetSlot == EquipmentSlot.None)
        {
            ShowFeedback("This item cannot be equipped", "alert-warning", "bi-exclamation-triangle");
            return;
        }

        var result = await itemManagementService.EquipItemAsync(character, item.Id, targetSlot);

        if (result.Success)
        {
            await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.InventoryChanged,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"Equipped {GetItemName(item)}"
            });

            ShowFeedback($"Equipped {GetItemName(item)}", "alert-success", "bi-check-circle");
            await LoadItemsAsync();
        }
        else
        {
            ShowFeedback(result.ErrorMessage!, "alert-danger", "bi-exclamation-circle");
        }
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}

private async Task UnequipItem(CharacterItem item)
{
    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);

        var blockReason = itemManagementService.GetUnequipBlockReason(character, item.Id);
        if (blockReason != null)
        {
            ShowFeedback($"Cannot unequip: {blockReason}", "alert-warning", "bi-exclamation-triangle");
            return;
        }

        var result = await itemManagementService.UnequipItemAsync(character, item.Id);

        if (result.Success)
        {
            await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.InventoryChanged,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"Unequipped {GetItemName(item)}"
            });

            ShowFeedback($"Unequipped {GetItemName(item)}", "alert-success", "bi-check-circle");
            await LoadItemsAsync();
        }
        else
        {
            ShowFeedback(result.ErrorMessage!, "alert-danger", "bi-exclamation-circle");
        }
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}

private bool CanEquip(CharacterItem item)
{
    var template = templates?.GetValueOrDefault(item.ItemTemplateId);
    return template?.EquipmentSlot != EquipmentSlot.None && !item.IsEquipped;
}

private bool IsStackable(CharacterItem item)
{
    var template = templates?.GetValueOrDefault(item.ItemTemplateId);
    return template?.IsStackable ?? false;
}

private int GetMaxStackSize(CharacterItem item)
{
    var template = templates?.GetValueOrDefault(item.ItemTemplateId);
    return template?.MaxStackSize ?? 99;
}
```
  </action>
  <verify>
1. `dotnet build Threa/Threa.Client/Threa.Client.csproj` succeeds
2. Add Item button visible in Inventory card header
3. Dropdown menus appear on inventory items
4. Unequip button visible on equipped items
  </verify>
  <done>Inventory items have action menus with Equip/Remove options, equipped items show Unequip button, Add Item opens template picker</done>
</task>

<task type="auto">
  <name>Task 3: Add quantity editing and currency management</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor</files>
  <action>
Complete the inventory enhancement with quantity editing and currency management.

**1. Add quantity editing methods:**
```csharp
private void StartEditQuantity(CharacterItem item)
{
    editingQuantityItemId = item.Id;
    editingQuantityValue = item.StackSize;
}

private void CancelEditQuantity()
{
    editingQuantityItemId = null;
}

private async Task SaveQuantity(CharacterItem item)
{
    if (editingQuantityValue < 1)
    {
        ShowFeedback("Quantity must be at least 1", "alert-warning", "bi-exclamation-triangle");
        return;
    }

    if (editingQuantityValue > GetMaxStackSize(item))
    {
        editingQuantityValue = GetMaxStackSize(item);
    }

    isProcessing = true;
    ClearFeedback();

    try
    {
        // Update via DAL directly (quantity change doesn't need ItemManagementService)
        item.StackSize = editingQuantityValue;
        await itemDal.UpdateItemAsync(item);

        await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
        {
            CharacterId = CharacterId,
            UpdateType = CharacterUpdateType.InventoryChanged,
            CampaignId = TableId.ToString(),
            SourceId = "GM",
            Description = $"Set {GetItemName(item)} quantity to {editingQuantityValue}"
        });

        editingQuantityItemId = null;
        ShowFeedback($"Updated quantity to {editingQuantityValue}", "alert-success", "bi-check-circle");
        await LoadItemsAsync();
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}
```

**2. Enhance Currency card with edit mode:**
Replace the entire Currency card section with:
```razor
<!-- Currency -->
<div class="card mt-3">
    <div class="card-header d-flex justify-content-between align-items-center">
        <strong>Currency</strong>
        @if (!isEditingCurrency)
        {
            <button class="btn btn-sm btn-outline-secondary" @onclick="StartEditCurrency" disabled="@isProcessing">
                <i class="bi bi-pencil"></i>
            </button>
        }
    </div>
    <div class="card-body">
        @if (isEditingCurrency)
        {
            <div class="row g-2 align-items-end">
                <div class="col">
                    <label class="form-label small text-muted mb-0">Platinum</label>
                    <input type="number" class="form-control form-control-sm" @bind="editPlatinum" min="0" />
                </div>
                <div class="col">
                    <label class="form-label small text-muted mb-0">Gold</label>
                    <input type="number" class="form-control form-control-sm" @bind="editGold" min="0" />
                </div>
                <div class="col">
                    <label class="form-label small text-muted mb-0">Silver</label>
                    <input type="number" class="form-control form-control-sm" @bind="editSilver" min="0" />
                </div>
                <div class="col">
                    <label class="form-label small text-muted mb-0">Copper</label>
                    <input type="number" class="form-control form-control-sm" @bind="editCopper" min="0" />
                </div>
            </div>
            <div class="mt-2 d-flex gap-2">
                <button class="btn btn-sm btn-success" @onclick="SaveCurrency" disabled="@isProcessing">
                    <i class="bi bi-check me-1"></i>Save
                </button>
                <button class="btn btn-sm btn-secondary" @onclick="CancelEditCurrency" disabled="@isProcessing">
                    Cancel
                </button>
            </div>
        }
        else
        {
            <div class="d-flex gap-3">
                <span><strong>@(Character?.PlatinumCoins ?? 0)</strong> pp</span>
                <span><strong>@(Character?.GoldCoins ?? 0)</strong> gp</span>
                <span><strong>@(Character?.SilverCoins ?? 0)</strong> sp</span>
                <span><strong>@(Character?.CopperCoins ?? 0)</strong> cp</span>
            </div>
        }
    </div>
</div>
```

**3. Add currency editing methods:**
```csharp
private void StartEditCurrency()
{
    editPlatinum = Character?.PlatinumCoins ?? 0;
    editGold = Character?.GoldCoins ?? 0;
    editSilver = Character?.SilverCoins ?? 0;
    editCopper = Character?.CopperCoins ?? 0;
    isEditingCurrency = true;
}

private void CancelEditCurrency()
{
    isEditingCurrency = false;
}

private async Task SaveCurrency()
{
    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);

        character.PlatinumCoins = Math.Max(0, editPlatinum);
        character.GoldCoins = Math.Max(0, editGold);
        character.SilverCoins = Math.Max(0, editSilver);
        character.CopperCoins = Math.Max(0, editCopper);

        await character.SaveAsync();

        await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
        {
            CharacterId = CharacterId,
            UpdateType = CharacterUpdateType.InventoryChanged,
            CampaignId = TableId.ToString(),
            SourceId = "GM",
            Description = "Currency updated"
        });

        isEditingCurrency = false;
        ShowFeedback("Currency updated", "alert-success", "bi-check-circle");

        // Update local Character reference
        Character = character;
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}
```

**4. Add QuantityPrompt mini-component inside the file (before @code block):**
Since we need a simple quantity prompt for adding stackable items, add this after the main component markup but we'll use a simple JavaScript confirm or inline approach. Actually, simplify by using inline quantity input in the AddItemFromTemplate flow:

Replace the AddItemFromTemplate method to use a simpler approach:
```csharp
private async Task AddItemFromTemplate(ItemTemplateInfo template)
{
    var fullTemplate = await templateDal.GetTemplateAsync(template.Id);

    int quantity = 1;
    if (fullTemplate.IsStackable && fullTemplate.MaxStackSize > 1)
    {
        // Use simple prompt dialog
        var quantityStr = await DialogService.OpenAsync<TextPromptDialog>(
            $"Quantity for {template.Name}",
            new Dictionary<string, object>
            {
                { "Message", $"Enter quantity (1-{fullTemplate.MaxStackSize}):" },
                { "DefaultValue", "1" }
            },
            new DialogOptions { Width = "300px" });

        if (quantityStr is string str && int.TryParse(str, out int qty) && qty > 0)
        {
            quantity = Math.Min(qty, fullTemplate.MaxStackSize);
        }
        else if (quantityStr == null)
        {
            return; // User cancelled
        }
    }

    // Rest of the add item logic...
    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);

        var newItem = new CharacterItem
        {
            Id = Guid.NewGuid(),
            ItemTemplateId = template.Id,
            OwnerCharacterId = CharacterId,
            ContainerItemId = null,
            StackSize = quantity,
            IsEquipped = false,
            EquippedSlot = EquipmentSlot.None,
            CreatedAt = DateTime.UtcNow
        };

        var result = await itemManagementService.AddItemToInventoryAsync(character, newItem);

        if (result.Success)
        {
            await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.InventoryChanged,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"Added {quantity}x {template.Name}"
            });

            ShowFeedback($"Added {quantity}x {template.Name}", "alert-success", "bi-check-circle");
            await LoadItemsAsync();
        }
        else
        {
            ShowFeedback(result.ErrorMessage!, "alert-danger", "bi-exclamation-circle");
        }
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}
```

For simplicity, use Radzen's built-in Prompt dialog instead of custom component. Update the quantity prompt to use a simple Radzen.DialogService.Prompt or create inline state-based quantity input in the AddItemFromTemplate flow.

**5. Add CSS for quantity edit overlay:**
Add to the existing style block:
```css
.quantity-edit-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    border-radius: 4px;
}
```

**6. Update using statements:**
Add at the top:
```razor
@using GameMechanics.Items
@using GameMechanics.Messaging
@using Radzen
```
  </action>
  <verify>
1. `dotnet build Threa/Threa.Client/Threa.Client.csproj` succeeds
2. Currency card shows edit button and inline editing UI
3. Set Quantity option appears in dropdown for stackable items
4. All operations publish CharacterUpdateMessage
  </verify>
  <done>
CharacterDetailInventory fully enhanced with:
- Add Item button opening template picker with quantity prompt
- Remove, Equip, Unequip actions via dropdown menus
- Quantity editing for stackable items
- Inline currency editing (pp, gp, sp, cp)
- Inline success/error feedback
- CharacterUpdateMessage publishing for real-time dashboard updates
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build Threa/Threa.Client/Threa.Client.csproj`
2. All INVT requirements covered:
   - INVT-01: Add Item button opens picker, adds to inventory
   - INVT-02: Quantity prompt for stackable items
   - INVT-03: Remove action in dropdown menu
   - INVT-04: Set Quantity in dropdown menu
   - INVT-05: Equip action in dropdown menu
   - INVT-06: Unequip button on equipped items
   - INVT-07: CharacterUpdateMessage published on all changes
   - INVT-08: Inventory visible in CharacterDetailInventory tab
3. Currency editing works (per CONTEXT.md decision)
</verification>

<success_criteria>
- GM can add items via Add Item button with quantity prompt for stackable items
- GM can remove items via dropdown menu (confirms for equipped/rare items)
- GM can equip/unequip items via dropdown menus
- GM can modify quantity of stackable items
- GM can edit currency values inline
- All changes publish CharacterUpdateMessage for dashboard refresh
- Inline feedback shows success/error messages
</success_criteria>

<output>
After completion, create `.planning/phases/20-inventory-manipulation/20-02-SUMMARY.md`
</output>
