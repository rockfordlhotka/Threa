---
phase: 20-inventory-manipulation
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor
autonomous: true

must_haves:
  truths:
    - "GM can add items from template library to character inventory via Add Item button"
    - "GM is prompted for quantity when adding stackable items"
    - "GM can remove items from inventory via dropdown menu on each item"
    - "GM can equip unequipped items via dropdown menu"
    - "GM can unequip equipped items via dropdown menu"
    - "GM can modify quantity of stackable items via dropdown menu"
    - "GM can edit character currency (pp, gp, sp, cp) inline"
    - "Inventory and currency changes publish CharacterUpdateMessage for real-time dashboard updates"
    - "Success/error feedback displayed inline in inventory view"
  artifacts:
    - path: "Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor"
      provides: "Interactive inventory management with GM actions"
      min_lines: 300
  key_links:
    - from: "CharacterDetailInventory.razor"
      to: "ItemManagementService"
      via: "AddItemToInventoryAsync, RemoveItemFromInventoryAsync, EquipItemAsync, UnequipItemAsync"
      pattern: "itemManagementService\\.(Add|Remove|Equip|Unequip)"
    - from: "CharacterDetailInventory.razor"
      to: "ITimeEventPublisher"
      via: "PublishCharacterUpdateAsync"
      pattern: "timeEventPublisher\\.PublishCharacterUpdateAsync"
    - from: "CharacterDetailInventory.razor"
      to: "ItemTemplatePickerModal"
      via: "DialogService.OpenAsync<ItemTemplatePickerModal>"
      pattern: "DialogService\\.OpenAsync<ItemTemplatePickerModal>"
    - from: "CharacterDetailInventory.razor"
      to: "IDataPortal<CharacterEdit>"
      via: "characterPortal.FetchAsync for fresh state"
      pattern: "characterPortal\\.FetchAsync"
    - from: "AddItemToInventory method"
      to: "IItemTemplateDal"
      via: "templateDal.GetTemplateAsync for full template data including Effects"
      pattern: "templateDal\\.GetTemplateAsync"
---

<objective>
Enhance CharacterDetailInventory with full GM manipulation capabilities including add/remove/equip/unequip items, quantity editing, and currency editing.

Purpose: Transform the read-only inventory view into an interactive GM tool for direct inventory manipulation during gameplay, completing requirements INVT-01 through INVT-08.

Output: Enhanced CharacterDetailInventory.razor with action menus, inline operations, currency editing, and real-time update publishing.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/20-inventory-manipulation/20-RESEARCH.md
@.planning/phases/20-inventory-manipulation/20-CONTEXT.md

# File to modify
@Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor

# Pattern references
@Threa/Threa.Client/Components/Shared/CharacterDetailEffects.razor
@Threa/Threa.Client/Components/Shared/EffectManagementModal.razor

# Core services
@GameMechanics/Items/ItemManagementService.cs
@GameMechanics/Messaging/ITimeEventPublisher.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add service injections and new parameters</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor</files>
  <action>
Add required injections and parameters to existing CharacterDetailInventory.razor.

**Add injections (after existing itemDal, templateDal):**
```razor
@inject ItemManagementService itemManagementService
@inject ITimeEventPublisher timeEventPublisher
@inject IDataPortal<CharacterEdit> characterPortal
@inject DialogService DialogService
```

**Add parameters (after existing Character parameter):**
```csharp
[Parameter]
public int CharacterId { get; set; }

[Parameter]
public Guid TableId { get; set; }
```

**Add state fields (after existing isLoading):**
```csharp
private bool isProcessing = false;
private string? feedbackMessage;
private string feedbackClass = "";
private string feedbackIcon = "";

// Currency editing state
private bool isEditingCurrency = false;
private int editPlatinum, editGold, editSilver, editCopper;

// Quantity editing state (for existing items in inventory)
private Guid? editingQuantityItemId = null;
private int editingQuantityValue = 0;

// Add item flow state (for quantity prompt after template selection)
private ItemTemplateInfo? pendingAddTemplate = null;
private int pendingAddQuantity = 1;
private bool showAddQuantityPrompt = false;
```

**Add feedback helper methods:**
```csharp
private void ShowFeedback(string message, string alertClass, string icon)
{
    feedbackMessage = message;
    feedbackClass = alertClass;
    feedbackIcon = icon;
    StateHasChanged();
}

private void ClearFeedback()
{
    feedbackMessage = null;
}
```
  </action>
  <verify>File compiles with all new injections and parameters</verify>
  <done>CharacterDetailInventory has all required service injections and parameter declarations</done>
</task>

<task type="auto">
  <name>Task 2: Add item operations and context menu</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor</files>
  <action>
Transform the inventory display into interactive GM tool with action menus.

**1. Add feedback alert at top of component (after opening div):**
```razor
@if (!string.IsNullOrEmpty(feedbackMessage))
{
    <div class="alert @feedbackClass alert-dismissible fade show mb-3" role="alert">
        <i class="bi @feedbackIcon me-1"></i>@feedbackMessage
        <button type="button" class="btn-close" @onclick="ClearFeedback"></button>
    </div>
}
```

**2. Add inline quantity prompt for add-item flow (after feedback alert):**
```razor
@if (showAddQuantityPrompt && pendingAddTemplate != null)
{
    <div class="alert alert-info mb-3">
        <div class="d-flex align-items-center gap-3">
            <span>Add <strong>@pendingAddTemplate.Name</strong> - Quantity:</span>
            <input type="number" class="form-control form-control-sm" style="width: 80px;"
                   @bind="pendingAddQuantity" min="1" />
            <button class="btn btn-sm btn-success" @onclick="ConfirmAddItem" disabled="@isProcessing">
                <i class="bi bi-check me-1"></i>Add
            </button>
            <button class="btn btn-sm btn-secondary" @onclick="CancelAddItem">
                Cancel
            </button>
        </div>
    </div>
}
```

**3. Add "Add Item" button to Inventory card header:**
Change the Inventory card header from:
```razor
<div class="card-header bg-primary text-white"><strong>Inventory</strong></div>
```
To:
```razor
<div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
    <strong>Inventory</strong>
    <button class="btn btn-sm btn-light" @onclick="OpenAddItemModal" disabled="@(isProcessing || showAddQuantityPrompt)">
        <i class="bi bi-plus-lg me-1"></i>Add Item
    </button>
</div>
```

**4. Update inventory-tile to include dropdown menu:**
Replace the existing inventory-tile div with:
```razor
<div class="inventory-tile position-relative">
    <div class="dropdown position-absolute" style="top: 2px; right: 2px;">
        <button class="btn btn-sm p-0 text-muted" data-bs-toggle="dropdown" style="line-height: 1;">
            <i class="bi bi-three-dots-vertical"></i>
        </button>
        <ul class="dropdown-menu dropdown-menu-end">
            @if (CanEquip(item))
            {
                <li><button class="dropdown-item" @onclick="() => EquipItem(item)" disabled="@isProcessing">
                    <i class="bi bi-box-arrow-in-up me-2"></i>Equip
                </button></li>
            }
            @if (IsStackable(item))
            {
                <li><button class="dropdown-item" @onclick="() => StartEditQuantity(item)" disabled="@isProcessing">
                    <i class="bi bi-hash me-2"></i>Set Quantity
                </button></li>
            }
            <li><hr class="dropdown-divider"></li>
            <li><button class="dropdown-item text-danger" @onclick="() => RemoveItem(item)" disabled="@isProcessing">
                <i class="bi bi-trash me-2"></i>Remove
            </button></li>
        </ul>
    </div>

    @if (editingQuantityItemId == item.Id)
    {
        <div class="quantity-edit-overlay">
            <input type="number" class="form-control form-control-sm" style="width: 60px;"
                   @bind="editingQuantityValue" min="1" max="@GetMaxStackSize(item)" />
            <div class="btn-group btn-group-sm mt-1">
                <button class="btn btn-success btn-sm" @onclick="() => SaveQuantity(item)">
                    <i class="bi bi-check"></i>
                </button>
                <button class="btn btn-secondary btn-sm" @onclick="CancelEditQuantity">
                    <i class="bi bi-x"></i>
                </button>
            </div>
        </div>
    }
    else
    {
        <div class="item-icon">@GetItemIcon(item)</div>
        <div class="item-name" title="@GetItemName(item)">@GetItemName(item)</div>
        @if (item.StackSize > 1)
        {
            <div class="item-quantity">x@item.StackSize</div>
        }
    }
</div>
```

**5. Update Equipment section to add unequip action:**
In the equipment slot display, change the equipped item display from:
```razor
<span>@GetItemName(equipped)</span>
```
To:
```razor
<div class="d-flex align-items-center gap-1">
    <span class="flex-grow-1">@GetItemName(equipped)</span>
    <button class="btn btn-sm btn-link text-danger p-0"
            @onclick="() => UnequipItem(equipped)"
            disabled="@isProcessing"
            title="Unequip">
        <i class="bi bi-x-circle"></i>
    </button>
</div>
```

**6. Add item operation methods:**
```csharp
private async Task OpenAddItemModal()
{
    var selectedTemplate = await DialogService.OpenAsync<ItemTemplatePickerModal>(
        "Select Item to Add",
        null,
        new DialogOptions { Width = "900px", Height = "600px", CloseDialogOnOverlayClick = true });

    if (selectedTemplate is ItemTemplateInfo template)
    {
        // Check if item is stackable to determine if we need quantity prompt
        var fullTemplate = await templateDal.GetTemplateAsync(template.Id);

        if (fullTemplate.IsStackable && fullTemplate.MaxStackSize > 1)
        {
            // Show inline quantity prompt
            pendingAddTemplate = template;
            pendingAddQuantity = 1;
            showAddQuantityPrompt = true;
        }
        else
        {
            // Non-stackable: add immediately with quantity 1
            await AddItemToInventory(template, 1);
        }
    }
}

private void CancelAddItem()
{
    pendingAddTemplate = null;
    pendingAddQuantity = 1;
    showAddQuantityPrompt = false;
}

private async Task ConfirmAddItem()
{
    if (pendingAddTemplate == null) return;

    var template = pendingAddTemplate;
    var quantity = Math.Max(1, pendingAddQuantity);

    // Clear the prompt state before async operation
    pendingAddTemplate = null;
    showAddQuantityPrompt = false;

    await AddItemToInventory(template, quantity);
}

private async Task AddItemToInventory(ItemTemplateInfo templateInfo, int quantity)
{
    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);

        // Fetch full template to access Effects and other detailed properties
        var fullTemplate = await templateDal.GetTemplateAsync(templateInfo.Id);

        var newItem = new CharacterItem
        {
            Id = Guid.NewGuid(),
            ItemTemplateId = templateInfo.Id,
            OwnerCharacterId = CharacterId,
            ContainerItemId = null,
            StackSize = quantity,
            IsEquipped = false,
            EquippedSlot = EquipmentSlot.None,
            CreatedAt = DateTime.UtcNow
        };

        var result = await itemManagementService.AddItemToInventoryAsync(character, newItem);

        if (result.Success)
        {
            await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.InventoryChanged,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"Added {quantity}x {templateInfo.Name}"
            });

            ShowFeedback($"Added {quantity}x {templateInfo.Name}", "alert-success", "bi-check-circle");
            await LoadItemsAsync();
        }
        else
        {
            ShowFeedback(result.ErrorMessage!, "alert-danger", "bi-exclamation-circle");
        }
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}

private async Task RemoveItem(CharacterItem item)
{
    var template = templates?.GetValueOrDefault(item.ItemTemplateId);
    var needsConfirmation = item.IsEquipped || (template?.Rarity >= ItemRarity.Rare);

    if (needsConfirmation)
    {
        var confirmed = await DialogService.Confirm(
            $"Remove {GetItemName(item)}?",
            "Confirm Removal",
            new ConfirmOptions { OkButtonText = "Remove", CancelButtonText = "Cancel" });

        if (confirmed != true) return;
    }

    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);

        var blockReason = itemManagementService.GetDropBlockReason(character, item.Id);
        if (blockReason != null)
        {
            ShowFeedback($"Cannot remove: {blockReason}", "alert-warning", "bi-exclamation-triangle");
            return;
        }

        var result = await itemManagementService.RemoveItemFromInventoryAsync(character, item.Id);

        if (result.Success)
        {
            await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.InventoryChanged,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"Removed {GetItemName(item)}"
            });

            ShowFeedback($"Removed {GetItemName(item)}", "alert-success", "bi-check-circle");
            await LoadItemsAsync();
        }
        else
        {
            ShowFeedback(result.ErrorMessage!, "alert-danger", "bi-exclamation-circle");
        }
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}

private async Task EquipItem(CharacterItem item)
{
    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);
        var template = templates?.GetValueOrDefault(item.ItemTemplateId);

        if (template == null)
        {
            ShowFeedback("Item template not found", "alert-danger", "bi-exclamation-circle");
            return;
        }

        var targetSlot = template.EquipmentSlot;
        if (targetSlot == EquipmentSlot.None)
        {
            ShowFeedback("This item cannot be equipped", "alert-warning", "bi-exclamation-triangle");
            return;
        }

        var result = await itemManagementService.EquipItemAsync(character, item.Id, targetSlot);

        if (result.Success)
        {
            await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.InventoryChanged,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"Equipped {GetItemName(item)}"
            });

            ShowFeedback($"Equipped {GetItemName(item)}", "alert-success", "bi-check-circle");
            await LoadItemsAsync();
        }
        else
        {
            ShowFeedback(result.ErrorMessage!, "alert-danger", "bi-exclamation-circle");
        }
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}

private async Task UnequipItem(CharacterItem item)
{
    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);

        var blockReason = itemManagementService.GetUnequipBlockReason(character, item.Id);
        if (blockReason != null)
        {
            ShowFeedback($"Cannot unequip: {blockReason}", "alert-warning", "bi-exclamation-triangle");
            return;
        }

        var result = await itemManagementService.UnequipItemAsync(character, item.Id);

        if (result.Success)
        {
            await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
            {
                CharacterId = CharacterId,
                UpdateType = CharacterUpdateType.InventoryChanged,
                CampaignId = TableId.ToString(),
                SourceId = "GM",
                Description = $"Unequipped {GetItemName(item)}"
            });

            ShowFeedback($"Unequipped {GetItemName(item)}", "alert-success", "bi-check-circle");
            await LoadItemsAsync();
        }
        else
        {
            ShowFeedback(result.ErrorMessage!, "alert-danger", "bi-exclamation-circle");
        }
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}

private bool CanEquip(CharacterItem item)
{
    var template = templates?.GetValueOrDefault(item.ItemTemplateId);
    return template?.EquipmentSlot != EquipmentSlot.None && !item.IsEquipped;
}

private bool IsStackable(CharacterItem item)
{
    var template = templates?.GetValueOrDefault(item.ItemTemplateId);
    return template?.IsStackable ?? false;
}

private int GetMaxStackSize(CharacterItem item)
{
    var template = templates?.GetValueOrDefault(item.ItemTemplateId);
    return template?.MaxStackSize ?? 99;
}
```
  </action>
  <verify>
1. `dotnet build Threa/Threa.Client/Threa.Client.csproj` succeeds
2. Add Item button visible in Inventory card header
3. Dropdown menus appear on inventory items
4. Unequip button visible on equipped items
5. Quantity prompt appears inline when adding stackable items
6. Inline quantity prompt state (showAddQuantityPrompt) toggles correctly when adding stackable items, and CancelAddItem clears state properly (pendingAddTemplate=null, pendingAddQuantity=1, showAddQuantityPrompt=false)
  </verify>
  <done>Inventory items have action menus with Equip/Remove options, equipped items show Unequip button, Add Item opens template picker with inline quantity prompt for stackable items</done>
</task>

<task type="auto">
  <name>Task 3: Add quantity editing and currency management</name>
  <files>Threa/Threa.Client/Components/Shared/CharacterDetailInventory.razor</files>
  <action>
Complete the inventory enhancement with quantity editing and currency management.

**1. Add quantity editing methods:**
```csharp
private void StartEditQuantity(CharacterItem item)
{
    editingQuantityItemId = item.Id;
    editingQuantityValue = item.StackSize;
}

private void CancelEditQuantity()
{
    editingQuantityItemId = null;
}

private async Task SaveQuantity(CharacterItem item)
{
    if (editingQuantityValue < 1)
    {
        ShowFeedback("Quantity must be at least 1", "alert-warning", "bi-exclamation-triangle");
        return;
    }

    if (editingQuantityValue > GetMaxStackSize(item))
    {
        editingQuantityValue = GetMaxStackSize(item);
    }

    isProcessing = true;
    ClearFeedback();

    try
    {
        // Update via DAL directly (quantity change doesn't need ItemManagementService)
        item.StackSize = editingQuantityValue;
        await itemDal.UpdateItemAsync(item);

        await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
        {
            CharacterId = CharacterId,
            UpdateType = CharacterUpdateType.InventoryChanged,
            CampaignId = TableId.ToString(),
            SourceId = "GM",
            Description = $"Set {GetItemName(item)} quantity to {editingQuantityValue}"
        });

        editingQuantityItemId = null;
        ShowFeedback($"Updated quantity to {editingQuantityValue}", "alert-success", "bi-check-circle");
        await LoadItemsAsync();
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}
```

**2. Enhance Currency card with edit mode:**
Replace the entire Currency card section with:
```razor
<!-- Currency -->
<div class="card mt-3">
    <div class="card-header d-flex justify-content-between align-items-center">
        <strong>Currency</strong>
        @if (!isEditingCurrency)
        {
            <button class="btn btn-sm btn-outline-secondary" @onclick="StartEditCurrency" disabled="@isProcessing">
                <i class="bi bi-pencil"></i>
            </button>
        }
    </div>
    <div class="card-body">
        @if (isEditingCurrency)
        {
            <div class="row g-2 align-items-end">
                <div class="col">
                    <label class="form-label small text-muted mb-0">Platinum</label>
                    <input type="number" class="form-control form-control-sm" @bind="editPlatinum" min="0" />
                </div>
                <div class="col">
                    <label class="form-label small text-muted mb-0">Gold</label>
                    <input type="number" class="form-control form-control-sm" @bind="editGold" min="0" />
                </div>
                <div class="col">
                    <label class="form-label small text-muted mb-0">Silver</label>
                    <input type="number" class="form-control form-control-sm" @bind="editSilver" min="0" />
                </div>
                <div class="col">
                    <label class="form-label small text-muted mb-0">Copper</label>
                    <input type="number" class="form-control form-control-sm" @bind="editCopper" min="0" />
                </div>
            </div>
            <div class="mt-2 d-flex gap-2">
                <button class="btn btn-sm btn-success" @onclick="SaveCurrency" disabled="@isProcessing">
                    <i class="bi bi-check me-1"></i>Save
                </button>
                <button class="btn btn-sm btn-secondary" @onclick="CancelEditCurrency" disabled="@isProcessing">
                    Cancel
                </button>
            </div>
        }
        else
        {
            <div class="d-flex gap-3">
                <span><strong>@(Character?.PlatinumCoins ?? 0)</strong> pp</span>
                <span><strong>@(Character?.GoldCoins ?? 0)</strong> gp</span>
                <span><strong>@(Character?.SilverCoins ?? 0)</strong> sp</span>
                <span><strong>@(Character?.CopperCoins ?? 0)</strong> cp</span>
            </div>
        }
    </div>
</div>
```

**3. Add currency editing methods:**
```csharp
private void StartEditCurrency()
{
    editPlatinum = Character?.PlatinumCoins ?? 0;
    editGold = Character?.GoldCoins ?? 0;
    editSilver = Character?.SilverCoins ?? 0;
    editCopper = Character?.CopperCoins ?? 0;
    isEditingCurrency = true;
}

private void CancelEditCurrency()
{
    isEditingCurrency = false;
}

private async Task SaveCurrency()
{
    isProcessing = true;
    ClearFeedback();

    try
    {
        var character = await characterPortal.FetchAsync(CharacterId);

        character.PlatinumCoins = Math.Max(0, editPlatinum);
        character.GoldCoins = Math.Max(0, editGold);
        character.SilverCoins = Math.Max(0, editSilver);
        character.CopperCoins = Math.Max(0, editCopper);

        await character.SaveAsync();

        await timeEventPublisher.PublishCharacterUpdateAsync(new CharacterUpdateMessage
        {
            CharacterId = CharacterId,
            UpdateType = CharacterUpdateType.InventoryChanged,
            CampaignId = TableId.ToString(),
            SourceId = "GM",
            Description = "Currency updated"
        });

        isEditingCurrency = false;
        ShowFeedback("Currency updated", "alert-success", "bi-check-circle");

        // Update local Character reference
        Character = character;
    }
    catch (Exception ex)
    {
        ShowFeedback($"Error: {ex.Message}", "alert-danger", "bi-exclamation-circle");
    }
    finally
    {
        isProcessing = false;
    }
}
```

**4. Add CSS for quantity edit overlay:**
Add to the existing style block:
```css
.quantity-edit-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    border-radius: 4px;
}
```

**5. Update using statements:**
Add at the top:
```razor
@using GameMechanics.Items
@using GameMechanics.Messaging
@using Radzen
```
  </action>
  <verify>
1. `dotnet build Threa/Threa.Client/Threa.Client.csproj` succeeds
2. Currency card shows edit button and inline editing UI
3. Set Quantity option appears in dropdown for stackable items
4. All operations publish CharacterUpdateMessage
  </verify>
  <done>
CharacterDetailInventory fully enhanced with:
- Add Item button opening template picker with inline quantity prompt for stackable items
- Remove, Equip, Unequip actions via dropdown menus
- Quantity editing for stackable items
- Inline currency editing (pp, gp, sp, cp)
- Inline success/error feedback
- CharacterUpdateMessage publishing for real-time dashboard updates
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `dotnet build Threa/Threa.Client/Threa.Client.csproj`
2. All INVT requirements covered:
   - INVT-01: Add Item button opens picker, adds to inventory
   - INVT-02: Inline quantity prompt for stackable items (no external dialog component needed)
   - INVT-03: Remove action in dropdown menu
   - INVT-04: Set Quantity in dropdown menu
   - INVT-05: Equip action in dropdown menu
   - INVT-06: Unequip button on equipped items
   - INVT-07: CharacterUpdateMessage published on all changes
   - INVT-08: Inventory visible in CharacterDetailInventory tab
3. Currency editing works (per CONTEXT.md decision)
</verification>

<success_criteria>
- GM can add items via Add Item button with inline quantity prompt for stackable items
- GM can remove items via dropdown menu (confirms for equipped/rare items)
- GM can equip/unequip items via dropdown menus
- GM can modify quantity of stackable items
- GM can edit currency values inline
- All changes publish CharacterUpdateMessage for dashboard refresh
- Inline feedback shows success/error messages
</success_criteria>

<output>
After completion, create `.planning/phases/20-inventory-manipulation/20-02-SUMMARY.md`
</output>
